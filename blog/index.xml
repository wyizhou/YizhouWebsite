<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Lucas Wu</title>
    <link>https://vec6.com/blog/</link>
    <description>Recent content in Blog on Lucas Wu</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 29 Dec 2024 21:36:34 +0000</lastBuildDate>
    <atom:link href="https://vec6.com/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>用于数据科学的SQL</title>
      <link>https://vec6.com/blog/sqlforanalysis/</link>
      <pubDate>Sun, 29 Dec 2024 21:36:34 +0000</pubDate>
      <guid>https://vec6.com/blog/sqlforanalysis/</guid>
      <description>&lt;p&gt;如今在数据科学中使用SQL查询数据是常见的操作，而大部分以表格（行和列）展示数据的数据格式，几乎都支持使用SQL进行查询，比如Dataframe、Excel。&lt;/p&gt;&#xA;&lt;p&gt;同时通过Jupyter Notebook提供的Magic Statements和IPython_SQL，能够让SQL和Python进行非常方便的结合。&lt;/p&gt;&#xA;&lt;h2 id=&#34;sql&#34;&gt;SQL&lt;/h2&gt;&#xA;&lt;p&gt;SQL全称为Structured Query Language 结构化查询语言，是基于Edgar F. Codd在1970年提出的关系模型理论，该模型引入了表（表格形式的数据结构）来表示数据以及其关系的概念，所以可以理解为最初的定位是用于操作和查询关系型数据库。&lt;/p&gt;&#xA;&lt;p&gt;SQL 于 1986 年被 &lt;strong&gt;ANSI&lt;/strong&gt;（美国国家标准学会）采纳，并于 1987 年被 &lt;strong&gt;ISO&lt;/strong&gt;（国际标准化组织）采纳为关系型数据库的标准语言，所以目前制定标准的主要由ANSI和ISO两个组织。&lt;/p&gt;&#xA;&lt;p&gt;SQL是一个标准，也是一个总称，SQL的定义了两个核心部分，第一个是标准的查询语句和标准的数据类型。&lt;/p&gt;&#xA;&lt;p&gt;除了上述的这些子集，还有一些扩展的高级功能的子集，比如对非结构化数据的支持，使得SQL能够支持NoSQL、NewSQL以及大数据系统应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;查询语句&#34;&gt;查询语句&lt;/h2&gt;&#xA;&lt;p&gt;查询语句主要是围绕着DDL、DML、DCL以及TCL几个核心的子集开展，而常见的SELCT、CREATE都是属于这些子集，核心子集每个数据库（DBMS）都是支持的，但是每个数据库针对于SQL的扩展都会都会有一些差异，所以如果考虑到迁移性，应该尽可能使用标准的核心SQL语句。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ddldata-definition-language&#34;&gt;DDL（Data Definition Language）&lt;/h3&gt;&#xA;&lt;p&gt;DDL（数据定义语言），理解为数据库的地基，负责定义和修改数据库结构和对象（如表、视图和索引等），典型的语句有CREATE、ALTER和DROP等。&lt;/p&gt;&#xA;&lt;h3 id=&#34;dmldata-manipulation-language&#34;&gt;DML（Data Manipulation Language）&lt;/h3&gt;&#xA;&lt;p&gt;DML（数据操作语言），作用于操作数据库的数据，对数据库中的数据进行查询、插入、更新和删除等操作，典型的语句有 Select查询数据、 Insert插入数据、Update更新修改数据、 Delete删除数据等。&lt;/p&gt;&#xA;&lt;p&gt;DQL（Data Query Language）是专门用于查询的子集，但是是由DML下的子集，所以DML包含查询。&lt;/p&gt;&#xA;&lt;h3 id=&#34;dcldata-control-language&#34;&gt;DCL（Data Control Language）&lt;/h3&gt;&#xA;&lt;p&gt;DCL（数据控制语言），作用于控制用户权限，管理数据库对象的访问权限，典型的语句有Grant和Revoke等。&lt;/p&gt;&#xA;&lt;h3 id=&#34;tcltransaction-control-language&#34;&gt;TCL（Transaction Control Language）&lt;/h3&gt;&#xA;&lt;p&gt;TCL（事物控制语言）是SQL子集，作用于管理事物，确保数据库操作的完整性，典型的语句有Commit、Rollback和Savepoint等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;&#xA;&lt;p&gt;SQL除了操作查询数据的语句部分，还有定义了数据的类型，比如数值、字符串、日期、布尔值等，大部分都是比较好理解的，但日期则可以根据需求不同采用不同的日期类型，SQL定义了DATE、TIME和TIMESTAMP类型，主要差异在于：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;DATE：DATE类型有8位数，分别为YYYYMMDD。&lt;/li&gt;&#xA;&lt;li&gt;TIME：TIME类型有6位数，分别为HHMMSS。&lt;/li&gt;&#xA;&lt;li&gt;TIMESTAMP：TIMESTAMP有20位数，分别为YYYYXXDDHHMMSSZZZZZZ，其中XX代表月份，ZZZZZZ代表微秒。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;一些记录&#34;&gt;一些记录&lt;/h2&gt;&#xA;&lt;p&gt;大部分SQL可以很容易查询到用法，但是部分查询在性能和实现则有一定的区别，同时也有存在多种解决方式。&lt;/p&gt;&#xA;&lt;h3 id=&#34;primary-key&#34;&gt;Primary Key&lt;/h3&gt;&#xA;&lt;p&gt;数据库中主键有如下几个功能：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;唯一性：设置为主键的属性（数据库中被映射为了列），是唯一值，能够避免数据重复。&lt;/li&gt;&#xA;&lt;li&gt;一致性和完整性：主键确保表每一行都有一个唯一的标识符，这对于维护数据的一致性非常重要。&lt;/li&gt;&#xA;&lt;li&gt;关联性：在关系型数据库中，主键用于建立表与表之间的关系（通过外键引用）。&lt;/li&gt;&#xA;&lt;li&gt;加速：数据库在创建主键的时候，会为主键创建索引，使得通过主键查询会非常快。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;er模型和erd图&#34;&gt;ER模型和ERD图&lt;/h3&gt;&#xA;&lt;h4 id=&#34;entity-relationship-modeler模型&#34;&gt;Entity-Relationship Model（ER模型）&lt;/h4&gt;&#xA;&lt;p&gt;ER模型是用于设计实体关系模型的基础理论，关注实体（比如人）、实体的属性（比如人的头发、身高、体重、肤色等）以及相互之间的关联，ER模型的好处是可以针对字段进行规划关联、字段类型、主键以及多对一还是一对多等关系，同时设计完成后可以自动化生成sql进行自动建立数据库结构。&lt;/p&gt;&#xA;&lt;h4 id=&#34;entity-relationship-diagramerd图&#34;&gt;Entity Relationship Diagram（ERD图）&lt;/h4&gt;&#xA;&lt;p&gt;而ERD则是ER的一种图的实现，基于ER理论通过ERD进行设计实体关系图，会更加直观。&lt;/p&gt;&#xA;&lt;h4 id=&#34;优势&#34;&gt;优势&lt;/h4&gt;&#xA;&lt;p&gt;如果只是画图，很多都可以画，但是ER模型和ERD都是专用数据库设计的，所以有很多其它画图工具达不到的功能，比如自动根据ERD图生成SQL脚本。&lt;/p&gt;&#xA;&lt;h3 id=&#34;字符串查询和范围查询&#34;&gt;字符串查询和范围查询&lt;/h3&gt;&#xA;&lt;p&gt;SQL使用字符串进行查询，可以只给出部分关键词进行模糊查询，其中有%代表通配符（即匹配任何事情）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据科学方法论</title>
      <link>https://vec6.com/blog/data-science-methodology/</link>
      <pubDate>Wed, 20 Nov 2024 23:36:34 +0000</pubDate>
      <guid>https://vec6.com/blog/data-science-methodology/</guid>
      <description>&lt;p&gt;数据分析方法论是一个系统化的方法论，覆盖了数据科学的全生命周期，这套方法论对于新手学习数据科学也比较重要，Data Science  Methodology 包含如下的10点。&lt;/p&gt;&#xA;&lt;h2 id=&#34;business-understanding&#34;&gt;Business understanding&lt;/h2&gt;&#xA;&lt;p&gt;核心目标：是从业务的视角确定业务的核心问题和期望，确保数据科学的分析方向与业务需求一致，同时确保业务问题具体、明确，方便后续转化为数据科学问题。&lt;/p&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;明确目标：确定业务的核心问题和期望，比如“如何提高用户的复购率？”&lt;/li&gt;&#xA;&lt;li&gt;分解问题：将业务多个可操作的问题，比如哪些用户复购？复购周期是多长？用户流水的主要原因是什么？&lt;/li&gt;&#xA;&lt;li&gt;提出关键问题：针对具体业务提问，确保问题的答案能为后续分析提供明确方向，比如用户复购率的基准是什么？与行业平均水平相比如何？哪些产品复购率高？影响复购率的主要因素有哪些（价格、物流和推销等）？&lt;/li&gt;&#xA;&lt;li&gt;最终目标：将业务目标转化为数据科学问题，比如能否通过用户行为数据预测哪些用户可能复购，并针对这些用户设计个性化营销策略？&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;analytic-approach&#34;&gt;Analytic approach&lt;/h2&gt;&#xA;&lt;p&gt;核心目标：选择最合适当前业务问题的分析方法，为后续数据准备、建模等环球打下基础，将业务问题转化为数据科学问题。&lt;/p&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;描述性分析：了解过去发生了什么？比如销量趋势分析，历史销售数据。&lt;/li&gt;&#xA;&lt;li&gt;分类分析：将数据进行分组，比如将客户行为分类为优质客户、中等客户和风险客户。&lt;/li&gt;&#xA;&lt;li&gt;预测分析：通过学习历史数据，对未来的数据进行预测，比如用户推荐购买。&lt;/li&gt;&#xA;&lt;li&gt;策略性分析（优化分析）：找到最优解，比如推荐最适合的促销方式。&lt;/li&gt;&#xA;&lt;li&gt;诊断性分析：了解为什么会这样？比如为什么目标促销活动很差。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;data-requirements&#34;&gt;Data requirements&lt;/h2&gt;&#xA;&lt;p&gt;核心目标：明确分析问题需要哪些数据，以及这些数据的范围和粒度，是否与业务相关，确保后续的数据收集工作高效且有针对性。&lt;/p&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;列出所需的数据：通过明确的业务问题，确定需要的具体数据类型和字段。结合Business understading的目标，拆解具体的数据需求。确定数据来源（客户数据、交易数据、外部数据等）。&lt;/li&gt;&#xA;&lt;li&gt;定义数据范围：时间范围（一年、一月或者一周？）、粒度（按天汇总、还是按月汇总）。&lt;/li&gt;&#xA;&lt;li&gt;与业务目标结合：确保收集的数据直接服务问题，而不是获取一切可以获取的数据。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;data-collection&#34;&gt;Data collection&lt;/h2&gt;&#xA;&lt;p&gt;核心目标：从不同来源获取需要的数据，确保质量来源，为后续的数据理解、清洗和建模奠定基础。这个阶段主要关注数据来源问题，比如是否因为导入导出或者编码问题导致的异常或者无效值。&lt;/p&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;明确数据来源：内部数据和外部数据。&lt;/li&gt;&#xA;&lt;li&gt;确保数据质量：数据是否完整、是否有缺失值。数据是否一致，比如同一个字段在不同的数据库定义不一样。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;data-understanding&#34;&gt;Data understanding&lt;/h2&gt;&#xA;&lt;p&gt;核心目标：对数据进行初步的分析，发现数据中的模式和问题。这个阶段关注数据的模式、异常值和缺失的业务意义，评估数据是否满足需求，然后将这些有问题的数据进行评估和记录，到下一个数据准备阶段进行处理。&lt;/p&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;探索数据：了解数据的基本情况，比如分布、中位数，是否有缺失值和异常值，通过可视化探索数据分布情况等。&lt;/li&gt;&#xA;&lt;li&gt;回答问题：数据是否满足支持目标？数据是否存在要清洗的问题？&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;data-preparation&#34;&gt;Data preparation&lt;/h2&gt;&#xA;&lt;p&gt;核心目标：提高数据的可用性和质量。将原始数据转化为结构化、规范化的数据集，清理问题数据，增强数据的分析和建模价值。&lt;/p&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据清洗：去除数据中的错误和噪声，提高数据质量。比如处理缺失值（删除、填补）、处理异常值和处理无效值。&lt;/li&gt;&#xA;&lt;li&gt;数据格式化：确保数据的格式和类型一致，便于后续处理和分析。比如统一数据格式（日期格式一致）和标准化分类字段（比如北京和北京市）。&lt;/li&gt;&#xA;&lt;li&gt;特征工程：为建模提取和构造新特征，以提高模型性能。&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建新特征：比如从日期中提取出日、月份新字段。&lt;/li&gt;&#xA;&lt;li&gt;特征转换：比如归一化（将数值缩放到相同的范围，如0-1），标准化&lt;/li&gt;&#xA;&lt;li&gt;编码分类变量：比如将类别变量转换为数值变量，比如成都为[1,0,0]，上海为[0,1,0]。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;数据集成：将来自不同数据源的数据整合。比如合并数据集（多表通过唯一ID关联合并为一张表）、重复数据处理。&lt;/li&gt;&#xA;&lt;li&gt;数据采样：从大数据中提取有代表性的小样本，提高效率。比如随机采样（从百万数据中，随机抽取10万），分层采样（按照某些特征分层抽出样本，保证样本分布与总体一致）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;modeling&#34;&gt;Modeling&lt;/h2&gt;&#xA;&lt;p&gt;核心目标：构建数学或统计模型，捕获数据中的规律或关系，建模只适合开发描述性模型和预测性模型，这是因为有以下几个原因：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据建模的基础是数据驱动：描述性和预测性是根据已有数据构建，核心是从数据中提取规律和模式，而不需要额外的领域知识或约束条件，而诊断性和规范性则需要更多的额外知识或推理逻辑。&lt;/li&gt;&#xA;&lt;li&gt;数据建模不关注因果关系：描述性和预测性不关注数据中的因果关系，只关注数据中的相关性，诊断性和规范性分析需要解释“为什么和怎么办”，所以超出了传统的数据建模范畴。&lt;/li&gt;&#xA;&lt;li&gt;数据建模关注“是什么”和“会发生什么”：描述性分析回答“是什么（提取数据特征）”、预测性分析回答“会发生什么”（未来结果）、诊断性分析回答“为什么”，规范性分析回答“怎么办”，后两者需要不同的方法论来支持。&lt;/li&gt;&#xA;&lt;li&gt;数据建模的工具与目标契合：数据建模的工具（回归分析、决策树和神经网络等）最适合用来描述和预测。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;明确模型目标：是预测问题（回归）？还是分类问题（分类）？还是发现隐藏模式（无监督学习）？&lt;/li&gt;&#xA;&lt;li&gt;选择合适的算法：比如回归（线性回归、Lasso等）、分类（决策树、逻辑回归等）、聚类（K-means、层次聚类等）、降维（PCA、t-SNE等）和时间序列（ARIMA、LSTM等）。&lt;/li&gt;&#xA;&lt;li&gt;分割数据：将数据分为训练集、验证集和测试集，确保模型可以在未见过的数据上表现良好。&lt;/li&gt;&#xA;&lt;li&gt;模型训练：使用训练集让模型学习数据的规律。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h2&gt;&#xA;&lt;p&gt;核心目标：评估模型的性能和适用性，确保模型能够满足业务需求和预期目标，该阶段与Modeling阶段是相辅相成的，会反复在两个阶段之间来回，以让模型达到最佳和最适合业务的状态。&lt;/p&gt;&#xA;&lt;p&gt;核心评估方法-诊断措施阶段&#xA;通过一系列定量指标和可视化工具对模型进行性能评估，识别模型的优势和潜在问题，比如性能指标（如准确率、MSE）、可视化工具（如混淆矩阵、残差图）、交叉验证等&lt;/p&gt;&#xA;&lt;p&gt;常见分类模型常用的定量指标有：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;准确率（Accuracy）：用于预测正确的比例。&lt;/li&gt;&#xA;&lt;li&gt;精准率（Precision）：用于被预测为正类中实际为正的比例。&lt;/li&gt;&#xA;&lt;li&gt;召回率（Recall）：用于实际正类中被预测为正类的比例。&lt;/li&gt;&#xA;&lt;li&gt;F1分数（F1-Score）：精确率和召回率的调和平均数。&lt;/li&gt;&#xA;&lt;li&gt;ROC-AUC：衡量模型区分正负样本的能力。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;常见回归模型有：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Google Hacking Test</title>
      <link>https://vec6.com/blog/google-hacking-test/</link>
      <pubDate>Tue, 11 Oct 2022 01:52:49 +0000</pubDate>
      <guid>https://vec6.com/blog/google-hacking-test/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;学习Google搜索，其目的是用于&lt;strong&gt;让自己得到更精准的信息&lt;/strong&gt;，所以善用Google搜索对于信息收集、安全测试、查找答案等都有着非常大的帮助。而随着时间的变化Google对于语法的更新、规则都在改动，这些改动对于结果都有影响，所以使用前进行测试是非常有必要的。 查阅了诸多资料过后，将Google搜索的操作分为了三个等级，分别为&lt;strong&gt;基础搜索&lt;/strong&gt;、&lt;strong&gt;布尔操作符&lt;/strong&gt;、&lt;strong&gt;高级操作符&lt;/strong&gt;，每个级别的都可以进行配合使用，有些组合起来能够让搜索更加精准，而有些则是不能进行组合。 同时这些搜索方式会与高级搜索设置中的功能重叠，但个人偏向使用语法对比高级搜索设置方便许多，所以后面的内容均使用语法，不会涉及到搜索设置等。 除此之外，还有诸多的网站可以获取到Google语法的途径，比如&lt;a href=&#34;https://www.exploit-db.com/google-hacking-database&#34;&gt;exploit-db&lt;/a&gt;是一个用于记录安全测试的Google语法数据库，这里面记录了非常多因配置失误操作的漏洞，如获取sql备份文件&lt;code&gt;sql.bak&lt;/code&gt;等。&lt;a href=&#34;https://support.google.com/websearch/answer/2466433?hl=en&amp;amp;visit_id=638009788259931665-4261219002&amp;amp;rd=1&#34;&gt;Google Help&lt;/a&gt;提供常用的Google语法等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;影响搜索的因素&#34;&gt;影响搜索的因素&lt;/h2&gt;&#xA;&lt;p&gt;Google在&lt;a href=&#34;https://www.google.com/search/howsearchworks/how-search-works/ranking-results/&#34;&gt;搜索原理&lt;/a&gt;的一篇简单的介绍了会影响搜索结果的几个因素，分别为以下7个因素：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果为中文，需要进行分词、语法等NLP技术的信息提取。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查询理解，这个步骤典型的就是修正错别字，比如你搜索“贝京市”，那么算法会将关键词进行修正为“北京市”，所以返回的内容中也是“北京市”相关的内容。这个步骤我没有找到具体的文献，但和&lt;code&gt;步骤1&lt;/code&gt;是有较强的联系。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;内容相关性，这个步骤典型的作用就是搜索网页中任何地方是否出现与关键词命中。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;内容质量，这个步骤用于确定网页是否具备权威、专业等，除了常见的网站认证、知名度、访问量等，还有Google的基于网页链接的算法，如PageRank，这种算法类似于投票，越权威的网站被引用/超链接的次数越多。基于这些情况然后进行排序，将这些高质量的网站靠前输出。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;网页可用性，这个步骤用于确定网页是否网页是否“优秀”，而Google是有一套&lt;a href=&#34;https://developers.google.com/search/docs/appearance/page-experience&#34;&gt;公开的标准&lt;/a&gt;，典型的就是网页加载速度、适配各个访问的客户端、是否HTTPS、广告等。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;上下文设置，这个步骤和自己的历史数据、设置有关系，比如你的历史搜索中多次搜索了“巴塞罗那对阿森纳”，当你搜索“巴塞罗那”的时候，可能更加想访问的是“巴塞罗那球队”而不是“巴塞罗那地区”，该部分的影响，可以通过Google搜索主页右下角设置中的“您在Google搜索中的数据设置”删除，或者直接使用无痕模式搜索可以消除该影响。 除了这个，地区也会导致你的搜索结果会有影响，在Google右下角设置中的“搜索设置”里面的“区域设置”可以验证，比如将该设置更改为美国，你搜索&amp;quot;football&amp;quot;则是返回的NFL橄榄球职业比赛联盟，而如果将地区设置为英国，返回的则是足球。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;符号，在Google搜索中符号如&lt;code&gt;（、。，/&lt;/code&gt;等都不会影响搜索结果，比如你搜索的是/中国北京/，那么结果中&amp;quot;中国（北京&amp;hellip;&amp;ldquo;这样的结果也会匹配。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;基础搜索&#34;&gt;基础搜索&lt;/h2&gt;&#xA;&lt;p&gt;基础搜索是最常见的，里面包含了两种搜索方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;关键词查询：关键词查询就是最常用的方式，直接输入关键词查询或者给出多个以空格间隔的关键词，如/中国北京/或者/中国 北京/。但需要注意的是使用关键词查询，会尽可能的分词和理解你的意图（影响搜索的因素中的步骤一），并尽可能的返回有关的内容，那么如/中国北京/，就有可能包含/中国北京/、/中国/、/北京/等结果返回。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;准确查询：精确查询用双引号包裹一个或者多个关键词，与关键词查询不同之处在于精确查询并不会对关键词进行分词，而是原封不动的进行完整的匹配，所以你搜索/中国北京/，就有可能包含&amp;quot;中国北京&amp;rdquo;、&amp;ldquo;中国&amp;rdquo;、&amp;ldquo;北京&amp;quot;等结果返回。而搜索/&amp;ldquo;中国北京&amp;rdquo;/，则代表每一个结果都按照&amp;quot;中国北京&amp;quot;这个词进行完整的匹配，不会出现&amp;quot;中国&amp;rdquo;、&amp;ldquo;北京&amp;quot;等结果返回。 而如果精确搜索给出了多个关键词，如/&amp;ldquo;中国 北京&amp;rdquo;/，则这个中间的空格代表着顺序，说所以可以理解为查询的含义为在&amp;quot;中国&amp;quot;这个词后紧跟着&amp;quot;北京&amp;quot;这个关键词。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;除了这两种搜索之外，还包含了几个符号：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;通配符：通配符&lt;code&gt;*&lt;/code&gt;与程序中的通配符意义不一样，中文和英文搜索中这里的通配符代表的是一个词，比如/&amp;ldquo;北京市 故宫&amp;rdquo;/，将“京”替换为&lt;code&gt;*&lt;/code&gt;，也就是/&amp;ldquo;北*市 故宫&amp;rdquo;/搜索，那么返回的结果中可能包含着如“北厦门市故宫”、&amp;ldquo;北秋田市故宮&amp;quot;等结果。如果将搜索改为/&amp;rdquo;*市 故宫&amp;rdquo;/，那么你看见命中的关键词（红色标注）则为“太保市故宮”、“北京市故宫”等词。所以这说明通配符匹配的是一个词，而不是一个字，作用是尽可能的将一个词与前后的关键字进行组合成一个完整的词。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;单字任意符：这个符号对于中文不太友好，中文下呈现的大多数能匹配到标点符号，而代表任意中文字符则不行，如搜索&amp;quot;湖北省&amp;quot;、&amp;ldquo;湖南省&amp;quot;等相关信息，所以语法为/&amp;ldquo;湖*省&amp;rdquo;/，但是返回的则是&amp;quot;湖省&amp;quot;和&amp;quot;湖（省&amp;rdquo;。 而对于英文则是能替代任意字符，比如/&amp;ldquo;hac*ing&amp;rdquo;/，则能搜索到&amp;quot;hacking&amp;quot;等结果。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;括号：Google搜索中对于括号是不敏感的，所以如 /北京(（市/ 搜索中放置了一个中文一个英文的括号，都会正常返回“北京市”结果，而在精确操作中同样适用，即/&amp;ldquo;北京(（市&amp;rdquo;/也能正确返回“北京市”的结果。 而基于括号这个操作，在搜索过程中就可以利用这个特性进行符合人类识别的分块构建查询，这个在于后面的布尔操作符和高级操作符上使用较多。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;布尔操作符&#34;&gt;布尔操作符&lt;/h2&gt;&#xA;&lt;p&gt;布尔操作符可以使用于基础搜索以及高级操作符，非常灵活，对于信息筛选的帮助非常大，主要为以下三种：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;AND操作符：该操作符用&lt;code&gt;+&lt;/code&gt;表示添加在关键词前。和代码中的不一样，代码中表示的是两者都必须具备，而在Google中，代表的是多添加一个关键词进行搜索，所以这个操作符没有太大的意义，如搜索/北京 +故宫/和/北京 故宫/结果相差不大，这是因为Google本身就会将所有关键词放进搜索条件中进行搜索。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;NOT排除操作符：该操作符用&lt;code&gt;-&lt;/code&gt;表示添加在关键词前，与字面意义一样，用于排除某个条件，如关键词返回的结果等，比如想了解/故宫/的信息，但不想看旅游相关的信息，如同程，那么就可以使用该操作符搜索/故宫 -同程/。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;OR操作符：该操作符用&lt;code&gt;|&lt;/code&gt;表示添加在两个关键词之间，代表的意义为两个关键词匹配任意一个匹配网页的内容都可以返回，比如/北京|重庆 /，那么将返回北京或者重庆相关的页面。 OR操作符可以用于关键词的多选组合，比如查看北京的地铁规划，那么&amp;quot;地铁&amp;quot;一词可能也叫&amp;quot;轨道&amp;quot;，&amp;ldquo;规划&amp;quot;一词也可能叫&amp;quot;计划&amp;rdquo;，那么这个时候就可以通过OR操作符搜索/&amp;ldquo;北京 地铁|轨道 规划|计划&amp;rdquo;/（也可以利用括号进行分组，即/&amp;ldquo;北京 (地铁|轨道) (规划|计划)&amp;quot;/），那么Google将尝试组合“北京地铁计划”、“北京轨道计划”、“北京地铁规划”、“北京轨道规划”等关键词搜索。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;高级操作符&#34;&gt;高级操作符&lt;/h2&gt;&#xA;&lt;p&gt;Google提供的搜索结果中，每条记录包含了六个部分，分别为标题、正文（简介）、URL、时间、缓存、文件类型，所有高级操作符也是围绕着这几个部分进行更为精细的控制，比如针对标题的搜索、正文的搜索、url的搜索等。 操作符有着严格的格式，高级操作符的语法为&lt;code&gt;Operator:value&lt;/code&gt;，并且操作符、冒号、值之间不能有空格。如果不按照该格式，Google搜索将会把高级操作符当作关键词进行搜索，而查看自己是否有语法的错误，可以通过返回的结果中命中的红色关键词是否有异常，比如是否包含了高级操作符。 除此之外，前面精准搜索、布尔操作符都可以与高级操作符结合。&lt;/p&gt;&#xA;&lt;h3 id=&#34;标题类&#34;&gt;标题类&lt;/h3&gt;&#xA;&lt;p&gt;标题类操作符为&lt;code&gt;intitle&lt;/code&gt;和&lt;code&gt;allintitle&lt;/code&gt;，用于搜索网页的标题，意味着你关键词的搜索范围仅限于标题。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;intitle&lt;/code&gt;：用于搜索单个词是否包含在标题中，比如搜索/intitle:&amp;ldquo;北京市&amp;rdquo;/，如果你要查询多个关键词用于搜索标题符合的网页，那么可以使用多个&lt;code&gt;intitle&lt;/code&gt;或者使用&lt;code&gt;allintitle&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;allintitle&lt;/code&gt;：该高级操作符是会将后面所有的单词用于搜索标题，所以如&lt;code&gt;intitle&lt;/code&gt;搜索标题中包含&amp;quot;北京市&amp;quot;和&amp;quot;故宫&amp;quot;的关键词，那么需要写两个&lt;code&gt;intitle&lt;/code&gt;，而&lt;code&gt;allintitle&lt;/code&gt;则只需要写一个/allintitle:&amp;ldquo;北京市&amp;rdquo; &amp;ldquo;故宫&amp;rdquo;/，但需要注意&lt;code&gt;all&lt;/code&gt;开头的大部分高级操作符与其他操作符进行组合使用的时候会出现问题，所以如果你只是单独的搜索标题那么可以使用&lt;code&gt;allintitle&lt;/code&gt;，而如果要与其他条件进行组合，那么建议使用&lt;code&gt;intitle&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;正文类&#34;&gt;正文类&lt;/h3&gt;&#xA;&lt;p&gt;正文类操作符为&lt;code&gt;intext&lt;/code&gt;和&lt;code&gt;allintext&lt;/code&gt;，用于搜索网页的正文，意味着你的关键词的搜索范围仅限于正文/简介。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;intext&lt;/code&gt;：用于搜索单个词是否包含在正文中，比如搜索/intext:北京市/，如果你查询多个同样使用多个&lt;code&gt;intext&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;allintext&lt;/code&gt;：用于搜索正文中的多个词，同样与&lt;code&gt;allintitle&lt;/code&gt;用法一样。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;url类&#34;&gt;URL类&lt;/h3&gt;&#xA;&lt;p&gt;URL类用于搜索网址，涉及的高级操作符有4个，分为：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;inurl&lt;/code&gt;和&lt;code&gt;allinurl&lt;/code&gt;：&lt;code&gt;inurl&lt;/code&gt;和&lt;code&gt;allinurl&lt;/code&gt;的使用方法和标题类、正文类一致。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;site&lt;/code&gt;：&lt;code&gt;site&lt;/code&gt;高级操作符用于搜索某个特定的域名或者域，比如只搜索微博关于故宫的信息，那么搜索语法为/site:weibo.com 故宫/。而搜索特定的域，则指的是&lt;code&gt;com&lt;/code&gt;、&lt;code&gt;cn&lt;/code&gt;、&lt;code&gt;edu.cn&lt;/code&gt;等域名的后缀，如搜索所有的国内学校研究生招生的情况，则搜索语法为/site:edu.cn 研究生招生/。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;inanchor&lt;/code&gt;：&lt;code&gt;inanchor&lt;/code&gt;高级操作符用于搜索超链接的文本。比如链接地址为&lt;code&gt;weibo.com/xxx&lt;/code&gt;，而这个链接的文本则显示为“我的微博”，在html表示为&lt;code&gt;&amp;lt;a href=&amp;quot;https://weibo.com/xxx&amp;quot;&amp;gt;我的微博&amp;lt;/a&amp;gt;&lt;/code&gt;，&lt;code&gt;inanchor&lt;/code&gt;就是用于搜索这个链接文本“我的微博”。 该操作符搜索返回的结果并非是网页中是否包含，而是直接返回该链接，比如“我的微博”这个链接存放在我的主页，Google并不会返回我的主页作为结果，而是将&amp;quot;我的微博&amp;quot;这条链接直接作为结果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>前端的技术栈理解</title>
      <link>https://vec6.com/blog/frontend-terms/</link>
      <pubDate>Fri, 22 Apr 2022 01:52:54 +0000</pubDate>
      <guid>https://vec6.com/blog/frontend-terms/</guid>
      <description>&lt;p&gt;最近几年单页应用程序发展非常迅速，从早期通过Javascript写入大量&lt;code&gt;html模版&lt;/code&gt;去做单页程序（SPA），到现在的React、Vue（最为流行），但不得不说，前端的技术进步太快了，稍不关注技术，就会出来很多的新的技术。&lt;/p&gt;&#xA;&lt;p&gt;但归根结底，每次新的技术出来，埋头深入发现远比想象的复杂，而到了一定的时间后则能够想明白一些事情，这也就是&amp;quot;深入浅出&amp;quot;的道理。 单页应用是一个复杂的技术，要解决这些问题，出现了很多&amp;quot;框架&amp;quot;、工具，比如React、Vue、React-router、Redux等。对于新手来说更是学了一圈后出来也是懵的。但总体来说，React和Vue这类库本质都没有什么区别，都是为了解决SPA提出的方案。这类库大部分主要的理念是将Web应用划分为一个一个的组件为单元，这些组件可以包含另一个组件，以此来达到复用性。&lt;/p&gt;&#xA;&lt;p&gt;而每个组件不可能都显示一样，那这样复用性是没有意义的。 那这个时候提出了“状态”的概念，来让每个复用的组件显示不同的内容，状态分为了&lt;code&gt;props&lt;/code&gt;和&lt;code&gt;state&lt;/code&gt;，&lt;code&gt;props&lt;/code&gt;是由外部传入进来的状态，&lt;code&gt;state&lt;/code&gt;则是组件内部自己的状态。而这类UI库对于状态的变化，都会根据一些优秀的算法去重新渲染组件，并且渲染的时候仅仅涉及到改变的那一部分内容。&lt;/p&gt;&#xA;&lt;p&gt;之所以需要状态，其实告诉React这类库需要监听哪些值，方便在改变这些值的时候，React可以及时的进行计算和重新渲染组件。 比如下面的代码就可以通过传递&lt;code&gt;name&lt;/code&gt;值进行重复使用包含&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;标签的组件，这种方式传递的状态在内部就是使用&lt;code&gt;props&lt;/code&gt;获取。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Header&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&amp;gt; // 输出：&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt;Hello&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Header&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&amp;gt; // 输出：&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt;world&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而&lt;code&gt;state&lt;/code&gt;则更多用于组件内部，比如当你鼠标点击需要获取一个报价，这个时候组件内部会发起一个请求，从服务器获取到报价后返回，改变状态，UI库进行重新渲染，这个时候就能获取到报价。 虽然说React提供了这些方便的功能，也提倡组件化和重复使用，但很多的组件是需要自己去一个一个写的。那这个时候，就有很多个人、组织开发出了&amp;quot;组件库&amp;quot;，&amp;ldquo;组件库&amp;quot;中包含了很多已经开发好可复用的组件，可以直接通过调用直接使用，这就是我们为什么看见除了React还有Ant Design、MaterialUI库。&lt;/p&gt;&#xA;&lt;p&gt;介绍完UI库和组件库后，单页应用还差一个东西，就是路由功能，路由也可以通过简单的Javascript来判断，比如当点击了一个链接后，Javascript将当前页面内容清除（隐藏），然后再渲染点击的目标内容。但是这个时候有一些问题，比如需要编写大量的代码、丢失浏览器的前进后退、没有办法收藏等问题（后面两个问题可以再通过增加代码去解决）。所以React-router-dom`这类的库就出现了，把所有的底层的逻辑和代码都进行封装提供一些接口，即大部分的人不需要再编写、理解这类的代码直接可以开箱即用，这也就是这类路由库出现的原因。 我们从前面了解到了状态分别为&lt;code&gt;props&lt;/code&gt;和&lt;code&gt;state&lt;/code&gt;，一个是外部，一个是内部的。&lt;/p&gt;&#xA;&lt;p&gt;那这个时候如果组件的嵌套过于&amp;quot;多层次&amp;quot;了后，比如从顶层的组件需要传递一个状态到第N层的组件中，那么每一层即使不需要不处理也要将状态进行传递，那这个时候涉及到的组件其中会包含非常多的和组件无关的代码。 所以这个时候需要一个通用的状态管理的解决方案（如Redux），让整个Web应用都共享一个大的状态，需要多层传递的状态则可以放在这个大状态内部，让不关心有些状态的组件不用去关心无关状态，而有些状态的组件去关心自己关心的状态。&lt;/p&gt;&#xA;&lt;p&gt;Redux本身设计是非常有趣的，整个应用的状态不能直接修改，这是因为如果大家都直接修改很有可能会造成状态的管理的混乱，所以Redux的修改状态流程是组件发起动作-&amp;gt;Dispatch函数接收动作-&amp;gt;reducer处理动作-&amp;gt;影响状态-&amp;gt;重新渲染组件。&lt;/p&gt;</description>
    </item>
    <item>
      <title>人工智能基础名词理解</title>
      <link>https://vec6.com/blog/inteliigence-terms/</link>
      <pubDate>Sat, 26 Jun 2021 06:48:33 +0000</pubDate>
      <guid>https://vec6.com/blog/inteliigence-terms/</guid>
      <description>&lt;h2 id=&#34;人工智能artificial-intelligence-ai&#34;&gt;人工智能（Artificial Intelligence, AI）&lt;/h2&gt;&#xA;&lt;p&gt;人工智能是一个比较广泛的概念，这个概念实际上指的是让机器像人一样思考，其最早由计算机科学之父阿兰图灵在1950年的一篇《计算机器与智能》论文中写出“如果电脑能在5分钟能回答由人类测试者提出的一系列的问题，且超过30%回答让测试者误认为人类所答，则电脑通过测试”，这段话也直接启蒙式的开启了人工智能领域的研究。 而“人工智能”一词，第一次出现在1956年，达特茅斯大学召开的学术会议室，由人工智能之父约翰·麦卡锡首次提出。 通常人工智能被分为弱人工智能和强人工智能，前者可以让机器有一定程度的学习、理解和推理能力，后者则是由自适应能力，比如解决一些之前没有遇见过的问题，我们常在电影里看见的机器人就是一种强人工智能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;机器学习machine-learning-ml&#34;&gt;机器学习（Machine Learning, ML）&lt;/h2&gt;&#xA;&lt;p&gt;机器学习为人工智能的一个子领域，也可以理解为弱人工智能的一种实现，而机器学习做的事情是让机器取模拟和实现人类的学习行为，以获得新的技能和知识。 人工智能领域的先驱Arthur Samuel在1959年给出的机器学习定义为“不直接编程，却能赋予计算机提供能力的方法”，而美国工程院院士Tom Mitchell则给出了一个更明确的含义，指出“机器学习是通过某项人物的经验数据提高了在该人物上的能力”。&lt;/p&gt;&#xA;&lt;p&gt;机器学习关注的是通过从数据中学习，并得到能够作出预测或决策的算法/模型（机器训练的产物），这里的特点是机器通过数据进行学习，而不是通过硬编码。&lt;/p&gt;&#xA;&lt;p&gt;而如今机器学习已在多个领域得到了很好的应用，大致上可以将机器学习的分为几个研究方向：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;模式识别&lt;/li&gt;&#xA;&lt;li&gt;自然语言处理&lt;/li&gt;&#xA;&lt;li&gt;数据挖掘&lt;/li&gt;&#xA;&lt;li&gt;计算机视觉&lt;/li&gt;&#xA;&lt;li&gt;语言识别&lt;/li&gt;&#xA;&lt;li&gt;统计学习&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;算法模型&#34;&gt;算法/模型&lt;/h2&gt;&#xA;&lt;p&gt;机器学习中，算法和模型（两者意思一样）实际上指的是一个东西，这是因为在训练前需要根据自己需求找到一个合适的算法，这个算法此时是通用的、未做调整和以及初始化的一个工具，而通过训练，即数据驱动下的优化（数据的学习）、参数的调整后，这个算法则具备了特定任务执行的能力，常见的算法比如回归算法、SVM向量机、聚类算法、降维算法、决策树、朴素贝叶斯等。&lt;/p&gt;&#xA;&lt;p&gt;而根据这些算法可以分为&lt;strong&gt;监督学习&lt;/strong&gt;、&lt;strong&gt;无监督学习&lt;/strong&gt;、&lt;strong&gt;半监督学习&lt;/strong&gt;、&lt;strong&gt;强化学习&lt;/strong&gt;，其中&lt;strong&gt;监督学习&lt;/strong&gt;在日语中被称为“有老师的学习”，本质上是让机器学习带有“&lt;strong&gt;标准答案&lt;/strong&gt;”的数据，然后再让机器学习做题，根据做题的结果对比标准答案，根据误差进行调整，经过多次反复，让机器的误差越来越小。 像上面这样在带有标签（答案）的数据上学习的过程被称为“&lt;strong&gt;训练&lt;/strong&gt;”，而训练用到的数据被称为“&lt;strong&gt;训练集&lt;/strong&gt;”，但也被叫做“&lt;strong&gt;数据集&lt;/strong&gt;”，因为该数据集是被拿来训练的，所以被称为训练集，同样训练集在自然语言处理中被称为“&lt;strong&gt;语料库&lt;/strong&gt;”，在训练集里面每一个数据被称为“&lt;strong&gt;样本&lt;/strong&gt;”，在训练过程中反复针对误差作出的调整则被称为“&lt;strong&gt;调参&lt;/strong&gt;”。&lt;/p&gt;&#xA;&lt;p&gt;而训练出来的结果则为称为“&lt;strong&gt;模型&lt;/strong&gt;”，模型其实也是算法，但为了区分，所以将机器学习的结果称为模型。模型可以用来针对训练集相似类型的问题去得到一个结论（值），这个过程则被称为&amp;quot;&lt;strong&gt;预测&lt;/strong&gt;&amp;quot; 。&lt;/p&gt;&#xA;&lt;p&gt;上述的步骤实际上就是针对一个算法，然后通过数据驱动的优化、不断的调整参数，具备了特定任务的执行能力后，而得到的一个模型，这个模型可以去执行特定的任务，比如识别这个是不是“猫”。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;无监督学习&lt;/strong&gt;在日语中被称为“没有老师的学习”，这就意味着数据不含标准答案，其作用是通过数据本身的结构或分布中来进行学习，典型的就是聚类，比如你给一只狗的照片和一只鸟的照片，虽然不能识别出这是鸟或狗，但无监督学习相关算法能做到这两张照片不是一类数据。&lt;/p&gt;&#xA;&lt;p&gt;无监督学习算法并不是完整不需要数据驱动的优化，而是不依赖于有明确答案的数据指导，但仍然可以从数据中学习和调整参数来实现目标。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;半监督学习&lt;/strong&gt;是利用多个模型对同一个数据进行预测，如果这些结果多数一致，则可以将这个数据和结果放在一起作为新的训练集，由于半监督学习可以利用标注数据来丰富未标注数据，所以目前正是热门的研究。&lt;/p&gt;&#xA;&lt;p&gt;之所以半监督学习这样热门是因为带有“标准答案”的数据集几乎都是由人工整理和标注，需要大量的人力、成本、时间，也被叫为“&lt;strong&gt;黄金数据（Gold Data）&lt;/strong&gt;”，所以半监督学习则可以用少量的标注数据集来得到更多的标注数据集来减少其人工、成本、时间。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;强化学习&lt;/strong&gt;则是针对的是需要一系列彼此关联决策的问题，比如自动驾驶、电子竞技等，这类问题往往需要一边预测，一边跟着环境的反馈规划下一次决策。&lt;/p&gt;&#xA;&lt;h2 id=&#34;人工神经网络artificial-neural-networks-ann&#34;&gt;人工神经网络（Artificial Neural Networks, ANN）&lt;/h2&gt;&#xA;&lt;p&gt;人工神经网络在1943年提出，人工神经网络通过模仿人脑的神经系统以及连接方式，所以人工神经网络更是一个框架或者计算模型，而人脑最基本单元的&lt;strong&gt;神经元&lt;/strong&gt;在神经网络中被称为&lt;strong&gt;感知器&lt;/strong&gt;（1958年），而通过很多的感知器进行组合，模仿组合成人脑的神经网络。&lt;/p&gt;&#xA;&lt;p&gt;这里需要注意的是感知器实际上算法模型，但是是一个简单的线性分类器，但是无数个线性分类器就可以解决很复杂的任务。&lt;/p&gt;&#xA;&lt;h2 id=&#34;深度学习deep-learning-dl&#34;&gt;深度学习（Deep Learning, DL）&lt;/h2&gt;&#xA;&lt;p&gt;深度学习是机器学习的一个子领域，主要包含了使用多层神经网络（DNN）类似的结构的机器学习方法，深度学习包含深度神经网络（DNN）、卷积神经网络（CNN）、递归神经网络（RNN）等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;参考文章&#34;&gt;参考文章&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/33892253&#34;&gt;什么是机器学习？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/wangzhongqiu/p/9856628.html&#34;&gt;人工智能、机器学习、深度学习、神经网络概念说明&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/50422088/answer/120936714&#34;&gt;神经网络啥时候改名叫“深度学习”了？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/30545893/answer/152317466&#34;&gt;深度学习和人工智能之间是什么样的关系？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/34856701/&#34;&gt;《自然语言处理入门》&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>(二)漫话中文分词：Trie、KMP、AC自动机</title>
      <link>https://vec6.com/blog/chinesecutwords-2/</link>
      <pubDate>Wed, 18 Nov 2020 08:51:13 +0000</pubDate>
      <guid>https://vec6.com/blog/chinesecutwords-2/</guid>
      <description>&lt;h2 id=&#34;trie树&#34;&gt;Trie树&lt;/h2&gt;&#xA;&lt;p&gt;在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[&amp;lsquo;中国人&amp;rsquo;, &amp;lsquo;中东人&amp;rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词&lt;code&gt;retrieval&lt;/code&gt;，发音和&lt;code&gt;try&lt;/code&gt;相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如&amp;quot;中国人&amp;quot;、&amp;ldquo;中东人&amp;quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以&amp;quot;中&amp;quot;开头，所以可以使用同一个父辈节点。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1605767937-1-0012449.jpg&#34; alt=&#34;1605767937-1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如&lt;code&gt;中国人&lt;/code&gt;，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1605767940-2-0012449.jpg&#34; alt=&#34;1605767940-2&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Trie树的查找方式则是通过层层查询，而不是直接遍历词典，比如&amp;quot;中国人&amp;rdquo;，首先会查找第一层中是否有&amp;quot;中&amp;quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找&amp;quot;中&amp;quot;字符对应的下一层是否有&amp;quot;国&amp;quot;，如果没有则返回查询识别，如果有则继续查找&amp;quot;国&amp;quot;下一层是否有&amp;quot;人&amp;quot;，此时找到存在&amp;quot;人&amp;quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查询词&lt;/li&gt;&#xA;&lt;li&gt;添加词&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回&amp;quot;False&amp;quot;表示为未查询到或设置失败，而返回&amp;quot;True&amp;quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的&lt;code&gt;__value&lt;/code&gt;表示是否为结束节点（即一个词的尾字符），如果是则为&lt;code&gt;True&lt;/code&gt;，不是则为&lt;code&gt;False&lt;/code&gt;，整体可以采用函数或者类来定义。 实现代码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Trie&lt;/span&gt;():  &lt;span style=&#34;color:#75715e&#34;&gt;#定义一个Trie类型&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self):  &lt;span style=&#34;color:#75715e&#34;&gt;#为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_children &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_add_word&lt;/span&gt;(self, word):  &lt;span style=&#34;color:#75715e&#34;&gt;# 定义一个添加词的实例方法&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_children  &lt;span style=&#34;color:#75715e&#34;&gt;# 首先会将_children的对象赋值给child&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i,char &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(word):  &lt;span style=&#34;color:#75715e&#34;&gt;# 然后从头遍历添加词的每一个字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; char &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; child:  &lt;span style=&#34;color:#75715e&#34;&gt;# 查看当前字符是否存在Trie树上&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                child[char] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__value&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;} &lt;span style=&#34;color:#75715e&#34;&gt;# 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; (len(word) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):  &lt;span style=&#34;color:#75715e&#34;&gt;# 判断是否为结尾字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                child[char][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__value&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 如果是则将特殊key：__value设为True，表明为结尾字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; child[char]  &lt;span style=&#34;color:#75715e&#34;&gt;# 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 添加完成返回True&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_get_word&lt;/span&gt;(self, word):  &lt;span style=&#34;color:#75715e&#34;&gt;# 查找词&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_children  &lt;span style=&#34;color:#75715e&#34;&gt;# 同样设置一个child变量，用于控制当前的字符对象 &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; char &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; word:  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; child&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(char)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; child &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt; :  &lt;span style=&#34;color:#75715e&#34;&gt;# 只要其中一个没有查找到，那么说明匹配识别，则返回False&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; child[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__value&amp;#39;&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;# 如果没有匹配失败则返回特殊__value的值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#回True表示词典中存在该词，返回False表示不存在或者传递进来的词不成词 &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将Trie实现后，就可以在正向或者反向等算法中来进行使用，从而提高运算的效率，但是使用Trie树的时候，可能无法动态的计算其词的长度，所以根据上一篇文章当中修改的最大正向匹配算法的长度计算我手动计算填写。 下面的代码是基于&lt;a href=&#34;https://vec6.com/posts/2022-04-15-1-chinese-words-cut/&#34;&gt;《[一]漫话中文分词：最大匹配,双向最大,最小词数》&lt;/a&gt;文章中的最大正向匹配算法，但其中的词典则是使用Trie结构，改动了两处：&lt;/p&gt;</description>
    </item>
    <item>
      <title>(一)漫话中文分词：最大匹配,双向最大,最小词数</title>
      <link>https://vec6.com/blog/chinesecutwords-1/</link>
      <pubDate>Sun, 08 Nov 2020 10:36:34 +0000</pubDate>
      <guid>https://vec6.com/blog/chinesecutwords-1/</guid>
      <description>&lt;p&gt;中文分词是指将文本拆分为单词的过程，而结果集合连接起来是等于原始的文本，而中文分词一直作为NLP领域的比较重要的领域，而大多数的文本挖掘都是以分词为基础，但中文不同于英文，英文每个单词是用空格分隔，整体语义上相对于中文难度低很多。 而业务上一直有中文分词的需求，但是之前因为在忙于另外一个项目，所以一直没有研究。 近期稍空闲开始研究了相关的中文分词算法，发现中文分词总体算比较成熟，但是其中对于未登录词或者某个特定专业领域文本大部分算法分词的结果不尽人意，需要结合多种算法或者人工词典才能达到稍微好一点的效果。 中文分词的方式一共有两种，分别为：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;词典分词：如正向最大匹配算法、反向最大匹配算法、双向最大匹配算法、最少词数法等&lt;/li&gt;&#xA;&lt;li&gt;字标注分词：如HMM（隐马尔可夫）模型等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;而这几种方式很难说出谁好谁坏，比如词典分词的方式速度非常快，但对于未登录词的识别又不太好，而HMM和Pkuseg都能识别部分未登录词，但是运行速度又降下来了，这对于在实际应用场景当中是非常致命的问题，所以最大的优解就是集各家所长，比如结巴分词就使用了词典分词算法识别能识别的词，而不能识别的则继续使用了HMM模型来处理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;词典分词&#34;&gt;词典分词&lt;/h2&gt;&#xA;&lt;p&gt;基于词典的分词算法实际上就是对于类似字典的数据结构进行查询，对于未在词典内的词识别较弱和交集型歧义理解能力也较弱，比如“结婚的和尚未结婚的”，理想的情况是&amp;quot;结婚/的/和/尚未/结婚/的&amp;quot;，而实际中则会被分词为&amp;quot;结婚/的/和尚/未/结婚/的&amp;quot;。 但好在词典分词的速度则非常快，词典分词目前已有非常成熟高效的解决方案，并且有非常多的工具来帮你实现相关的高效数据结构和查询方式，比如&lt;a href=&#34;https://zh.wikipedia.org/wiki/Trie&#34;&gt;Trie树&lt;/a&gt;和&lt;a href=&#34;https://zh.wikipedia.org/wiki/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%97%E6%B3%95&#34;&gt;AC自动机&lt;/a&gt;，但在这里为了方便理解和记录，只采用了尽可能简单的方式来记录其几种算法的实现和原理。&lt;/p&gt;&#xA;&lt;h3 id=&#34;正向最大匹配算法forward-maximum-matching&#34;&gt;正向最大匹配算法（Forward Maximum Matching）&lt;/h3&gt;&#xA;&lt;p&gt;正向最大匹配算法类似于人的阅读习惯，即从左到右进行识别，而其中的&amp;quot;最大&amp;quot;是基于词典中最长字符的长度作为最大的匹配宽度，然后每次根据这个宽度对文本进行切分并取出来查询词典。如果当前取出来的词能在词典当中查询当则返回，并下一次切分的开始位置为该词的位置+1。而如果当前取出的部分没有在词典中查找到，则将该部分去掉最后一个字符后再进行查找，一直重复直到匹配到了词典中的词。如果整个部分只剩余一个字符，并没有匹配到词典中的词，则将最后剩余的这个字符输出，然后根据这个字符的位置+1开始再次进行切分和查询。 比如，有一段文本&amp;quot;中文分词算法&amp;quot;，字典中只包含了一个词&amp;quot;分词&amp;quot;，这个时候最大的匹配宽度也为2，所以整段文本按照2个字符进行切分。第一次得到&amp;quot;中文&amp;quot;文本，查找词典并无该词，则在该部分上去掉最后的字符，得到&amp;quot;中&amp;quot;，再次查询词典并无该词，此时查找结束，所以不需要再进行匹配，则这个切分记为[&amp;ldquo;中&amp;rdquo;]。 继续进行第二次切分，得到的文本为&amp;quot;文分&amp;quot;，进行查询词典，第一次查询&amp;quot;文分&amp;quot;在字典中不存在，去掉最后一个字符，继续以剩余部分&amp;rsquo;文&amp;rsquo;查询第二次，未查询到，那么返回最后这个字符&amp;quot;文&amp;quot;，加上次的结果记作[&amp;ldquo;中&amp;rdquo;,&amp;ldquo;文&amp;rdquo;] 继续第三次切分，得到文本&amp;quot;分词&amp;quot;，进行查询词典，查询到该词在字典当中，所以直接记录在之前的结果当中，记作[&amp;ldquo;中&amp;rdquo;, &amp;ldquo;文&amp;rdquo;, &amp;ldquo;分词&amp;rdquo;]。 继续第四次切分，得到文本&amp;quot;算法&amp;quot;，进行查询字典，第一次查询&amp;quot;算法&amp;quot;在字典中不存在，去掉最后一个字符，继续以剩余部分&amp;rsquo;算&amp;rsquo;查询第二次，未查询到，那么返回最后这个字符&amp;quot;算&amp;quot;，加上次的结果记作[&amp;ldquo;中&amp;rdquo;, &amp;ldquo;文&amp;rdquo;, &amp;ldquo;分词&amp;rdquo;, &amp;ldquo;算&amp;rdquo;] 继续第五次切分，因为最后只剩余一个字符，所以这个时候可以不进行匹配即返回，所以最终的结果为[&amp;ldquo;中&amp;rdquo;, &amp;ldquo;文&amp;rdquo;, &amp;ldquo;分词&amp;rdquo;, &amp;ldquo;算&amp;rdquo;, &amp;ldquo;法&amp;rdquo;] 整体分词的过程本质对每个分块进行查找，并依次去掉最后字符查询，而网上还有一部分是没有使用最大宽度切分，即会对每个字符到文本结束的位置都会依次遍历，这样的方式实际上会浪费较多的资源，因为即使从头到尾依次遍历匹配，但最长词的长度是固定的，所以真正开始匹配还是从最长词的长度开始，而其余的遍历都是浪费了资源。 正向最大匹配算法具体的实现代码：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sentence = &amp;#39;中文分词算法&amp;#39; # 输入的句子&#xA;cutList = [&amp;#39;分词&amp;#39;]  # 分词词典&#xA;&#xA;start = 0 #设置切分起始位置&#xA;maxWidth = len(max(cutList, key=len)) # 得到字典当中最大的切分宽度&#xA;cut_result = [] # 设置一个空的分词结果&#xA;&#xA;while (start &amp;lt;= len(sentence)):  #开始循环，如果start大于等于句子长度则停止分词&#xA;    end = start + maxWidth     # 计算每次切分的停止位置&#xA;    word = sentence[start: end] # 开始切分，文本为变量start和end的区间内字符&#xA;    while ( word ) :  # python对于空字符串会转换为False&#xA;        if ( word in cutList ) :  # 查看第一次切分后是否能在词典中匹配，如果匹配则放入最终的分词结果列表cut_result,并跳出循环&#xA;            cut_result.append(word)&#xA;            start = start + len(word) - 1  # 然后将开始位置设置为当前开始位置加上被匹配词的长度&#xA;            break &#xA;        if (len(word[:-1]) == 0):&#xA;            cut_result.append(word) # 如果最后一个字符也没有被匹配到，那么返回最后一个字符&#xA;            break&#xA;        word = word[:-1]  # 将word去掉最后一个字符串并重新计算&#xA;    start = start + 1  # 将位置加1&#xA;&#xA;print(cut_result)&#xA;#[&amp;#39;中&amp;#39;, &amp;#39;文&amp;#39;, &amp;#39;分词&amp;#39;, &amp;#39;算&amp;#39;, &amp;#39;法&amp;#39;] &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;反向最大匹配算法backward-maximum-matching&#34;&gt;反向最大匹配算法（Backward Maximum Matching）&lt;/h3&gt;&#xA;&lt;p&gt;反向最大匹配算法与正向最大匹配算法是相反的，比如&amp;quot;中文分词算法&amp;quot;文本的正向最大匹配算法在切分宽度为2的时候，是从&amp;quot;中文&amp;quot;开始切分的，而反向则是从&amp;quot;算法&amp;quot;开始切分的。 除了反向的切分，其中对于切分块内的文本依次去掉最后一个字符也变为了依次去掉第一个字符，比如正向第一个切分块&amp;quot;中文&amp;quot;后，如果没有匹配到，则去掉&amp;quot;文&amp;quot;，再对&amp;quot;中&amp;quot;字符进行匹配，而反向则是拿到&amp;quot;算法&amp;quot;后，如果没有匹配到，则是去掉&amp;quot;算&amp;quot;，再对&amp;quot;法&amp;quot;进行匹配。 反向最大匹配算法对比于正向最大匹配算法来说，可以解决一定的交集型歧义，比如本文&amp;quot;他说的确实在理&amp;quot;，理想情况下希望的分词结果中包含&amp;quot;确实&amp;quot;这一词，而正向最大匹配算法结果为&amp;quot;他/说/的确/实/在理&amp;quot;，而反向最大匹配算法的结果为&amp;quot;他/说/的/确实/在理&amp;quot;。 这两种方式很难区分到底谁好谁坏，比如上面的问题中，如果你希望的分词为&amp;quot;的确&amp;quot;，但是如果使用反向的话就很难被分出来。 反向最大匹配算法具体的实现代码：&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解条件概率</title>
      <link>https://vec6.com/blog/learning-conditional-probability/</link>
      <pubDate>Tue, 03 Nov 2020 09:03:53 +0000</pubDate>
      <guid>https://vec6.com/blog/learning-conditional-probability/</guid>
      <description>&lt;h2 id=&#34;样本空间ω&#34;&gt;样本空间（Ω）&lt;/h2&gt;&#xA;&lt;p&gt;样本空间通常指实验或随机所有可能的集合，我们常在说一个概率的时候，实际上是默认忽略掉了样本空间，比如说事件A的概率，实际上指样本空间中，事件A的数量与样本空间的占比。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604372452-AC4572F1-2252-4346-BB20-0D4FFDF6358B.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;比如丢硬币，硬币只有正面和反面，那么硬币的样本空间则为 ${正面，反面}$，这个时候常说的正面的概率为二分之一，实际指的是正面事件的数量与样本空间的占比，也就是1/2。 再比如说丢骰子，一个骰子有6种可能，分别对应1-6不同的数值，那么丢骰子的样本空间则为${1，2，3，4，5，6}$，这个时候丢到5个事件概率则为数字5在样本空间出现的次数与样本空间总数的占比。&lt;/p&gt;&#xA;&lt;h2 id=&#34;独立事件&#34;&gt;独立事件&lt;/h2&gt;&#xA;&lt;p&gt;独立事件是指不受过去已发生的事件而影响的事件，典型的例子就是抛硬币，不管你抛多少次硬币始终正面或反面的概率为0.5，而该硬币的样本空间如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604371899-47382406-BF21-44F0-9AE6-589942D9B6A6.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;独立事件的概率计算公式为如下：&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;事件发生的概率(P) = 事件在样本空间中的数量 / 样本空间的事件总数&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;比如用抛硬币的例子，计算正面的概率则为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604373310-20201103111444.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;而除了单个独立事件，有些时候也会求多个独立事件的概率，而多个独立事件的概率则是每个独立事件发生的概率的积。 比如掷3次骰子都为6的概率是多少？需要注意因为掷骰子是一个独立事件，即每次掷的骰子样本空间都一样，并且没有因为第一次掷骰子的结果会影响到下一次。 骰子的样本空间为下，从中能够得到单次掷骰子为6的概率为1/6：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604373121-30D9A77B-E1A3-4F16-95E6-EF8235C3F866.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;而这个时候只需要将三次掷骰子的概率相乘就得到了三次都为6的概率：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604374119-20201103112708.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;相关事件&#34;&gt;相关事件&lt;/h2&gt;&#xA;&lt;p&gt;相关事件和独立事件是相对的，相关事件的发生概率会受到过去已发生事件的影响，每个事件都和上一个事件有关联，这些事件便是相关的。 比如一个布袋中有5个球，其中包含2个蓝球，三个红球，布袋(样本空间)则为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604371925-C998AEB6-33C2-48A6-AD8E-7036323E6712.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个时候如果随机拿一颗蓝球的概率是多少？概率为2/5。 但是此时求第二次拿到蓝球的概率是多少？这个时候就会有两种情况发生：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第一次拿到红球，这个时候整个样本空间少了一个红球，所以第二次拿到蓝球的概率为2/4&lt;/li&gt;&#xA;&lt;li&gt;第二次拿到蓝球，这个时候整个样本空间少了一个篮球，所以第二次拿到蓝球的概率为1/4&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;用图表示则为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604371934-961D07E9-2DF6-4261-A652-87E57CFB1409.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以此时，如果算第一次拿到红球后，第二次拿到蓝球的概率则为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604374574-20201103113211.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果算第一次拿到蓝球后，第二次拿到红球的概率则为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604374656-20201103113722.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;条件概率&#34;&gt;条件概率&lt;/h2&gt;&#xA;&lt;p&gt;条件概率是研究相关事件的，指的是当B事件发生后，A事件发生的概率，用&amp;quot;｜&amp;ldquo;来表示&amp;quot;以下发生的条件下&amp;rdquo;，表示为公式：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604374815-20201103114005.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;比如上面的例子，第二个蓝球的概率是多少，这个问题就是条件概率，因为第二次抽中蓝球的概率是基于第一次拿了一颗球过后发生的事件。 这个时候可以将第一次抽中红球记作事件A，第二次抽蓝球为事件B，因为第二次抽球是在事件A发生的情况下而发生的，所以记作 $P(B|A)$ ，表示在A发生后，B发生的概率。 而这个概率可以根据下图来得到，即2/4：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604371988-1DEFAE68-FA91-4A6E-A8FD-4B12F30AA11F.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里的条件概率本质是二级概率，该情况可以用图来表达，第一次抽球的样本空间为整个样本空间：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604371925-C998AEB6-33C2-48A6-AD8E-7036323E6712.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当第一次抽球(A事件)发生后，B事件的样本空间则是基于A事件发生后的样本空间，即下图中A圆圈内的样本空间：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604371951-540848F0-26C1-40AC-B189-0B5CC4401917.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;联合概率&#34;&gt;联合概率&lt;/h2&gt;&#xA;&lt;p&gt;联合概率指两个事件共同发生的概率，比如A和B事件共同发生的概率表示为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604376279-20201103120425.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;联合概率的计算分为两种情况，一种为独立事件，比如前面掷骰子，计算公式则为多个独立事件事件的积，表示为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604376368-20201103120543.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;另一种则为相关事件，比如上面的抽球的例子，则可以通过反推来计算，表示为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604376495-20201103120806.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里这样计算是因为P(B|A)只得到了B在A发生后的概率，也就是在发生后的样本空间上计算的，所以P(B|A)表示的只有下图这么一部分发生的概率：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604371954-4D7A59FE-7518-40A1-998A-4690DCA7D29F.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;而在这个时候乘以P(A)的概率，则就能表示如下这整个部分：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604487745-2020110412e.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;全概率&#34;&gt;全概率&lt;/h2&gt;&#xA;&lt;p&gt;导致一个事件发生的原因有很多种，那么该事件发生的概率就是每种原因引起该事件发生的概率总和，这句话能够很好的解释全概率。 而全概率公式就可以计算出一个事件的全部概率，公式为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1604376800-20201103121300.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;而根据联合概率的计算方法，可以写成下面这样：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images//2020/11/1604376795-20201103121234.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;还是拿红蓝球的例子来说，如果需要计算P(B)，这个时候可以利用全概率公式，则将能引起事件B发生的每个概率相加，即可得到P(B)。 在红篮球例子当中，引起事件B的原因有两种，分别为：先拿到红球，然后抽中蓝球的概率和先拿到蓝球抽中蓝球的概率。 根据图中第一种先拿到了红球引起B事件的发生的概率为 $(3/5) * (2/4) = 0.3$&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解连续数据和离散数据</title>
      <link>https://vec6.com/blog/continuous-data-and-discrete-data/</link>
      <pubDate>Tue, 27 Oct 2020 07:35:35 +0000</pubDate>
      <guid>https://vec6.com/blog/continuous-data-and-discrete-data/</guid>
      <description>&lt;p&gt;统计学中，将一种类型的数据总称为变量，而变量的数据称为观测，而变量的具体取值为观测值，比如下面的数据中，age和name都是变量，而18和’大红’都具体的取值被称为观测值。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;age,name&#xA;18,’大红’&#xA;21,’小花’ &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同理，在统计学中，离散数据也被称为离散变量，连续数据也被称为连续变量，而如何区分两种变量的区别？ 连续变量可以理解为取值范围在理论上是连续不断的，而离散变量则可以理解为取值范围是间断不连续的，他们之间的区别并无数量之分，都是无穷个。 比如家庭数量人口只有1、2、3、4个人口，不可能为1.2、1.8、2.4这样来表示人口，所以家庭人口是离散变量。 而年龄取值上通常为了方便而说是18岁、17岁、30岁，但是如果按照实际取值，则可以取为18.32、17.55、30.67岁，17.55岁则表示年龄为17岁6个月18天，而且出生的时间还可以精确到小时、分、秒等单位，所以年龄为连续变量。&lt;/p&gt;&#xA;&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/101155810&#34;&gt;关于连续和离散的理解&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/152635216&#34;&gt;定量和定性变量、连续和离散变量，到底怎么分？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1eW411E7eu?p=23&#34;&gt;图解概率笔记：葉丙成概率公开课&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Short XSS</title>
      <link>https://vec6.com/blog/short-xss/</link>
      <pubDate>Wed, 21 Aug 2013 14:04:13 +0000</pubDate>
      <guid>https://vec6.com/blog/short-xss/</guid>
      <description>&lt;p&gt;文章作者：xsscript(原网名Crackkay)&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x00-背景&#34;&gt;0x00 背景&lt;/h3&gt;&#xA;&lt;p&gt;关键时候长度不够怎么办？&lt;/p&gt;&#xA;&lt;p&gt;在实际的情况中如果你不够长怎么办呢？看医生？吃药？做手术？。。。。。。。。。。。。。。算了，既然自身硬件不足，那么就把缺点变优点吧。熟话说：小是小威力好。&lt;/p&gt;&#xA;&lt;p&gt;熟话说的好，要能长能短，收放自如。在很多的情况中，我们构造的语句是被限制在一定的字符数内。所以这个就是考验你能短的时候能不能短，能长的时候能不能长的时候到了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x01-现实中的悲剧&#34;&gt;0x01 现实中的悲剧&lt;/h3&gt;&#xA;&lt;p&gt;这是一个活生生的悲剧，一个平台上面，一个二逼朋友有妹子的平台账号，但是二逼朋友想进妹子的QQ空间，用平台的备注插QQ-XSS代码，但是因为限制的字符太短，最终抱头痛哭。于是就有了下图所发生：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/1.jpg&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x02-怎么变短&#34;&gt;0x02 怎么变”短”&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;&amp;quot;&amp;gt;alert(1)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;..27 letters?&lt;/p&gt;&#xA;&lt;h4 id=&#34;alert1-no-run&#34;&gt;Alert(1)? No Run?&lt;/h4&gt;&#xA;&lt;h3 id=&#34;impossible&#34;&gt;Impossible?&lt;/h3&gt;&#xA;&lt;h3 id=&#34;no&#34;&gt;No!&lt;/h3&gt;&#xA;&lt;p&gt;在实际情况中，可以通过&lt;!-- raw HTML omitted --&gt;短向量或者其他的短向量去测试存在XSS的地方，为什么可以这样？HTML是一门”不太严格”的解释语言，即使没有，很多浏览器也照样可以解释为&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;h1&amp;gt;xss&#xA;&#xA;可以解释为:&#xA;&#xA;&amp;lt;h1&amp;gt;xss&amp;lt;/h1&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;S1:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/2.jpg&#34; alt=&#34;2&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;S2:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/3.jpg&#34; alt=&#34;3&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;S3：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/4.jpg&#34; alt=&#34;4&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;但是如果在攻击的时候，我往往需要用到很多标签、属性来达到我们的目的。下面列出一些比较猥琐的利用&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;&amp;lt;svg/onload=domain=id&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;S1:在chrome浏览器存在一个同域读取漏洞，为什么说同域呢？&lt;/p&gt;&#xA;&lt;p&gt;S2:在chrome下如果我们访问www.baidu.com，通过控制台来设置一下域为空，document.domain=&amp;quot;&amp;quot;，就会出现以下的错误。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/5.jpg&#34; alt=&#34;5&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;S3:为什么说chrome浏览器存在一个同域读取漏洞呢?下面我们通过访问www.baidu.com.来访问一下（com后面还有一个.）并设置一下域为空&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;document.domain=&amp;quot;&amp;quot;&lt;/code&gt;设置结果就会出现以下图片所示。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/6.jpg&#34; alt=&#34;6&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;S4:这个怎么利用？&lt;/p&gt;&#xA;&lt;p&gt;首先说一个问题，就是说，在同域的情况下，DOM是互通的。就相当于我a可以写b的，b也可以同样写a的。那我们该怎么来利用呢？我们可以干很多事情，比如说重写页面钓鱼，或者盗取同域Cookie。下面我就用Chrome的控制台来演示一下这个内容读取漏洞。&lt;/p&gt;&#xA;&lt;p&gt;S5:先来看看两段代码：&lt;/p&gt;&#xA;&lt;p&gt;本地构造的攻击页面如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&#xA;&amp;lt;html&amp;gt;&#xA;　　&amp;lt;body&amp;gt;&#xA;    &amp;lt;h1&amp;gt;这是a.com./12.html&amp;lt;/h1&amp;gt;&#xA;    &amp;lt;svg/onload=domain=id&amp;gt;&#xA;　　&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;存在缺陷的XSS页面如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&#xA;&amp;lt;html&amp;gt;&#xA;　　&amp;lt;body&amp;gt;&#xA;    &amp;lt;h1&amp;gt;这是b.com./11.html&amp;lt;/h1&amp;gt;&#xA;　　  &amp;lt;svg/onload=domain=id&amp;gt;&#xA;　　&amp;lt;/body&amp;gt;&#xA;&amp;lt;/html&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;S6:下面我们通过访问我们构造的攻击页面，也就是&lt;code&gt;a.com./12.html&lt;/code&gt;，然后读取domain看看，结果如下图：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/7.jpg&#34; alt=&#34;7&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;S7:然后我们在控制台里面用window.open()方法打开打开存在缺陷的XSS页面.然后同样用domain查看域.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/8.jpg&#34; alt=&#34;8&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;S8:我们从上面就可以查看出，现在a.com.和b.com.都是处于同一域下面，那么就可以实现DOM相通的概念了。&lt;/p&gt;&#xA;&lt;p&gt;S9:通过DOM重写页面测试，测试结果如下图：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2017/08/9.jpg&#34; alt=&#34;9&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;S10:其实这个方法的用处很多，比如说我找到XXX的XSS页面，我通过把域置空，然后在自己站上构造一个页面，怎么构造就要看你的思维了，通过同域的DOM操作，可以钓鱼的方式盗取COOKIE、密码等。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;&amp;lt;svg/onload=eval(name)&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;S1:先把代码文译一下：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
