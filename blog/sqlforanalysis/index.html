<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>用于数据科学的SQL | Lucas Wu</title>
<meta name="title" content="用于数据科学的SQL" />
<meta name="description" content="如今在数据科学中使用SQL查询数据是常见的操作，而大部分以表格（行和列）展示数据的数据格式，几乎都支持使用SQL进行查询，比如Dataframe、Excel。
同时通过Jupyter Notebook提供的Magic Statements和IPython_SQL，能够让SQL和Python进行非常方便的结合。
SQL
SQL全称为Structured Query Language 结构化查询语言，是基于Edgar F. Codd在1970年提出的关系模型理论，该模型引入了表（表格形式的数据结构）来表示数据以及其关系的概念，所以可以理解为最初的定位是用于操作和查询关系型数据库。
SQL 于 1986 年被 ANSI（美国国家标准学会）采纳，并于 1987 年被 ISO（国际标准化组织）采纳为关系型数据库的标准语言，所以目前制定标准的主要由ANSI和ISO两个组织。
SQL是一个标准，也是一个总称，SQL的定义了两个核心部分，第一个是标准的查询语句和标准的数据类型。
除了上述的这些子集，还有一些扩展的高级功能的子集，比如对非结构化数据的支持，使得SQL能够支持NoSQL、NewSQL以及大数据系统应用。
查询语句
查询语句主要是围绕着DDL、DML、DCL以及TCL几个核心的子集开展，而常见的SELCT、CREATE都是属于这些子集，核心子集每个数据库（DBMS）都是支持的，但是每个数据库针对于SQL的扩展都会都会有一些差异，所以如果考虑到迁移性，应该尽可能使用标准的核心SQL语句。
DDL（Data Definition Language）
DDL（数据定义语言），理解为数据库的地基，负责定义和修改数据库结构和对象（如表、视图和索引等），典型的语句有CREATE、ALTER和DROP等。
DML（Data Manipulation Language）
DML（数据操作语言），作用于操作数据库的数据，对数据库中的数据进行查询、插入、更新和删除等操作，典型的语句有 Select查询数据、 Insert插入数据、Update更新修改数据、 Delete删除数据等。
DQL（Data Query Language）是专门用于查询的子集，但是是由DML下的子集，所以DML包含查询。
DCL（Data Control Language）
DCL（数据控制语言），作用于控制用户权限，管理数据库对象的访问权限，典型的语句有Grant和Revoke等。
TCL（Transaction Control Language）
TCL（事物控制语言）是SQL子集，作用于管理事物，确保数据库操作的完整性，典型的语句有Commit、Rollback和Savepoint等。
数据类型
SQL除了操作查询数据的语句部分，还有定义了数据的类型，比如数值、字符串、日期、布尔值等，大部分都是比较好理解的，但日期则可以根据需求不同采用不同的日期类型，SQL定义了DATE、TIME和TIMESTAMP类型，主要差异在于：

DATE：DATE类型有8位数，分别为YYYYMMDD。
TIME：TIME类型有6位数，分别为HHMMSS。
TIMESTAMP：TIMESTAMP有20位数，分别为YYYYXXDDHHMMSSZZZZZZ，其中XX代表月份，ZZZZZZ代表微秒。

一些记录
大部分SQL可以很容易查询到用法，但是部分查询在性能和实现则有一定的区别，同时也有存在多种解决方式。
Primary Key
数据库中主键有如下几个功能：

唯一性：设置为主键的属性（数据库中被映射为了列），是唯一值，能够避免数据重复。
一致性和完整性：主键确保表每一行都有一个唯一的标识符，这对于维护数据的一致性非常重要。
关联性：在关系型数据库中，主键用于建立表与表之间的关系（通过外键引用）。
加速：数据库在创建主键的时候，会为主键创建索引，使得通过主键查询会非常快。

ER模型和ERD图
Entity-Relationship Model（ER模型）
ER模型是用于设计实体关系模型的基础理论，关注实体（比如人）、实体的属性（比如人的头发、身高、体重、肤色等）以及相互之间的关联，ER模型的好处是可以针对字段进行规划关联、字段类型、主键以及多对一还是一对多等关系，同时设计完成后可以自动化生成sql进行自动建立数据库结构。
Entity Relationship Diagram（ERD图）
而ERD则是ER的一种图的实现，基于ER理论通过ERD进行设计实体关系图，会更加直观。
优势
如果只是画图，很多都可以画，但是ER模型和ERD都是专用数据库设计的，所以有很多其它画图工具达不到的功能，比如自动根据ERD图生成SQL脚本。
字符串查询和范围查询
SQL使用字符串进行查询，可以只给出部分关键词进行模糊查询，其中有%代表通配符（即匹配任何事情）。" />
<meta name="keywords" content="SQL," />


<meta property="og:url" content="https://vec6.com/blog/sqlforanalysis/">
  <meta property="og:site_name" content="Lucas Wu">
  <meta property="og:title" content="用于数据科学的SQL">
  <meta property="og:description" content="如今在数据科学中使用SQL查询数据是常见的操作，而大部分以表格（行和列）展示数据的数据格式，几乎都支持使用SQL进行查询，比如Dataframe、Excel。
同时通过Jupyter Notebook提供的Magic Statements和IPython_SQL，能够让SQL和Python进行非常方便的结合。
SQL SQL全称为Structured Query Language 结构化查询语言，是基于Edgar F. Codd在1970年提出的关系模型理论，该模型引入了表（表格形式的数据结构）来表示数据以及其关系的概念，所以可以理解为最初的定位是用于操作和查询关系型数据库。
SQL 于 1986 年被 ANSI（美国国家标准学会）采纳，并于 1987 年被 ISO（国际标准化组织）采纳为关系型数据库的标准语言，所以目前制定标准的主要由ANSI和ISO两个组织。
SQL是一个标准，也是一个总称，SQL的定义了两个核心部分，第一个是标准的查询语句和标准的数据类型。
除了上述的这些子集，还有一些扩展的高级功能的子集，比如对非结构化数据的支持，使得SQL能够支持NoSQL、NewSQL以及大数据系统应用。
查询语句 查询语句主要是围绕着DDL、DML、DCL以及TCL几个核心的子集开展，而常见的SELCT、CREATE都是属于这些子集，核心子集每个数据库（DBMS）都是支持的，但是每个数据库针对于SQL的扩展都会都会有一些差异，所以如果考虑到迁移性，应该尽可能使用标准的核心SQL语句。
DDL（Data Definition Language） DDL（数据定义语言），理解为数据库的地基，负责定义和修改数据库结构和对象（如表、视图和索引等），典型的语句有CREATE、ALTER和DROP等。
DML（Data Manipulation Language） DML（数据操作语言），作用于操作数据库的数据，对数据库中的数据进行查询、插入、更新和删除等操作，典型的语句有 Select查询数据、 Insert插入数据、Update更新修改数据、 Delete删除数据等。
DQL（Data Query Language）是专门用于查询的子集，但是是由DML下的子集，所以DML包含查询。
DCL（Data Control Language） DCL（数据控制语言），作用于控制用户权限，管理数据库对象的访问权限，典型的语句有Grant和Revoke等。
TCL（Transaction Control Language） TCL（事物控制语言）是SQL子集，作用于管理事物，确保数据库操作的完整性，典型的语句有Commit、Rollback和Savepoint等。
数据类型 SQL除了操作查询数据的语句部分，还有定义了数据的类型，比如数值、字符串、日期、布尔值等，大部分都是比较好理解的，但日期则可以根据需求不同采用不同的日期类型，SQL定义了DATE、TIME和TIMESTAMP类型，主要差异在于：
DATE：DATE类型有8位数，分别为YYYYMMDD。 TIME：TIME类型有6位数，分别为HHMMSS。 TIMESTAMP：TIMESTAMP有20位数，分别为YYYYXXDDHHMMSSZZZZZZ，其中XX代表月份，ZZZZZZ代表微秒。 一些记录 大部分SQL可以很容易查询到用法，但是部分查询在性能和实现则有一定的区别，同时也有存在多种解决方式。
Primary Key 数据库中主键有如下几个功能：
唯一性：设置为主键的属性（数据库中被映射为了列），是唯一值，能够避免数据重复。 一致性和完整性：主键确保表每一行都有一个唯一的标识符，这对于维护数据的一致性非常重要。 关联性：在关系型数据库中，主键用于建立表与表之间的关系（通过外键引用）。 加速：数据库在创建主键的时候，会为主键创建索引，使得通过主键查询会非常快。 ER模型和ERD图 Entity-Relationship Model（ER模型） ER模型是用于设计实体关系模型的基础理论，关注实体（比如人）、实体的属性（比如人的头发、身高、体重、肤色等）以及相互之间的关联，ER模型的好处是可以针对字段进行规划关联、字段类型、主键以及多对一还是一对多等关系，同时设计完成后可以自动化生成sql进行自动建立数据库结构。
Entity Relationship Diagram（ERD图） 而ERD则是ER的一种图的实现，基于ER理论通过ERD进行设计实体关系图，会更加直观。
优势 如果只是画图，很多都可以画，但是ER模型和ERD都是专用数据库设计的，所以有很多其它画图工具达不到的功能，比如自动根据ERD图生成SQL脚本。
字符串查询和范围查询 SQL使用字符串进行查询，可以只给出部分关键词进行模糊查询，其中有%代表通配符（即匹配任何事情）。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2024-12-29T21:36:34+00:00">
    <meta property="article:modified_time" content="2024-12-29T21:36:34+00:00">
    <meta property="article:tag" content="SQL">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="用于数据科学的SQL">
  <meta name="twitter:description" content="如今在数据科学中使用SQL查询数据是常见的操作，而大部分以表格（行和列）展示数据的数据格式，几乎都支持使用SQL进行查询，比如Dataframe、Excel。
同时通过Jupyter Notebook提供的Magic Statements和IPython_SQL，能够让SQL和Python进行非常方便的结合。
SQL SQL全称为Structured Query Language 结构化查询语言，是基于Edgar F. Codd在1970年提出的关系模型理论，该模型引入了表（表格形式的数据结构）来表示数据以及其关系的概念，所以可以理解为最初的定位是用于操作和查询关系型数据库。
SQL 于 1986 年被 ANSI（美国国家标准学会）采纳，并于 1987 年被 ISO（国际标准化组织）采纳为关系型数据库的标准语言，所以目前制定标准的主要由ANSI和ISO两个组织。
SQL是一个标准，也是一个总称，SQL的定义了两个核心部分，第一个是标准的查询语句和标准的数据类型。
除了上述的这些子集，还有一些扩展的高级功能的子集，比如对非结构化数据的支持，使得SQL能够支持NoSQL、NewSQL以及大数据系统应用。
查询语句 查询语句主要是围绕着DDL、DML、DCL以及TCL几个核心的子集开展，而常见的SELCT、CREATE都是属于这些子集，核心子集每个数据库（DBMS）都是支持的，但是每个数据库针对于SQL的扩展都会都会有一些差异，所以如果考虑到迁移性，应该尽可能使用标准的核心SQL语句。
DDL（Data Definition Language） DDL（数据定义语言），理解为数据库的地基，负责定义和修改数据库结构和对象（如表、视图和索引等），典型的语句有CREATE、ALTER和DROP等。
DML（Data Manipulation Language） DML（数据操作语言），作用于操作数据库的数据，对数据库中的数据进行查询、插入、更新和删除等操作，典型的语句有 Select查询数据、 Insert插入数据、Update更新修改数据、 Delete删除数据等。
DQL（Data Query Language）是专门用于查询的子集，但是是由DML下的子集，所以DML包含查询。
DCL（Data Control Language） DCL（数据控制语言），作用于控制用户权限，管理数据库对象的访问权限，典型的语句有Grant和Revoke等。
TCL（Transaction Control Language） TCL（事物控制语言）是SQL子集，作用于管理事物，确保数据库操作的完整性，典型的语句有Commit、Rollback和Savepoint等。
数据类型 SQL除了操作查询数据的语句部分，还有定义了数据的类型，比如数值、字符串、日期、布尔值等，大部分都是比较好理解的，但日期则可以根据需求不同采用不同的日期类型，SQL定义了DATE、TIME和TIMESTAMP类型，主要差异在于：
DATE：DATE类型有8位数，分别为YYYYMMDD。 TIME：TIME类型有6位数，分别为HHMMSS。 TIMESTAMP：TIMESTAMP有20位数，分别为YYYYXXDDHHMMSSZZZZZZ，其中XX代表月份，ZZZZZZ代表微秒。 一些记录 大部分SQL可以很容易查询到用法，但是部分查询在性能和实现则有一定的区别，同时也有存在多种解决方式。
Primary Key 数据库中主键有如下几个功能：
唯一性：设置为主键的属性（数据库中被映射为了列），是唯一值，能够避免数据重复。 一致性和完整性：主键确保表每一行都有一个唯一的标识符，这对于维护数据的一致性非常重要。 关联性：在关系型数据库中，主键用于建立表与表之间的关系（通过外键引用）。 加速：数据库在创建主键的时候，会为主键创建索引，使得通过主键查询会非常快。 ER模型和ERD图 Entity-Relationship Model（ER模型） ER模型是用于设计实体关系模型的基础理论，关注实体（比如人）、实体的属性（比如人的头发、身高、体重、肤色等）以及相互之间的关联，ER模型的好处是可以针对字段进行规划关联、字段类型、主键以及多对一还是一对多等关系，同时设计完成后可以自动化生成sql进行自动建立数据库结构。
Entity Relationship Diagram（ERD图） 而ERD则是ER的一种图的实现，基于ER理论通过ERD进行设计实体关系图，会更加直观。
优势 如果只是画图，很多都可以画，但是ER模型和ERD都是专用数据库设计的，所以有很多其它画图工具达不到的功能，比如自动根据ERD图生成SQL脚本。
字符串查询和范围查询 SQL使用字符串进行查询，可以只给出部分关键词进行模糊查询，其中有%代表通配符（即匹配任何事情）。">




  <meta itemprop="name" content="用于数据科学的SQL">
  <meta itemprop="description" content="如今在数据科学中使用SQL查询数据是常见的操作，而大部分以表格（行和列）展示数据的数据格式，几乎都支持使用SQL进行查询，比如Dataframe、Excel。
同时通过Jupyter Notebook提供的Magic Statements和IPython_SQL，能够让SQL和Python进行非常方便的结合。
SQL SQL全称为Structured Query Language 结构化查询语言，是基于Edgar F. Codd在1970年提出的关系模型理论，该模型引入了表（表格形式的数据结构）来表示数据以及其关系的概念，所以可以理解为最初的定位是用于操作和查询关系型数据库。
SQL 于 1986 年被 ANSI（美国国家标准学会）采纳，并于 1987 年被 ISO（国际标准化组织）采纳为关系型数据库的标准语言，所以目前制定标准的主要由ANSI和ISO两个组织。
SQL是一个标准，也是一个总称，SQL的定义了两个核心部分，第一个是标准的查询语句和标准的数据类型。
除了上述的这些子集，还有一些扩展的高级功能的子集，比如对非结构化数据的支持，使得SQL能够支持NoSQL、NewSQL以及大数据系统应用。
查询语句 查询语句主要是围绕着DDL、DML、DCL以及TCL几个核心的子集开展，而常见的SELCT、CREATE都是属于这些子集，核心子集每个数据库（DBMS）都是支持的，但是每个数据库针对于SQL的扩展都会都会有一些差异，所以如果考虑到迁移性，应该尽可能使用标准的核心SQL语句。
DDL（Data Definition Language） DDL（数据定义语言），理解为数据库的地基，负责定义和修改数据库结构和对象（如表、视图和索引等），典型的语句有CREATE、ALTER和DROP等。
DML（Data Manipulation Language） DML（数据操作语言），作用于操作数据库的数据，对数据库中的数据进行查询、插入、更新和删除等操作，典型的语句有 Select查询数据、 Insert插入数据、Update更新修改数据、 Delete删除数据等。
DQL（Data Query Language）是专门用于查询的子集，但是是由DML下的子集，所以DML包含查询。
DCL（Data Control Language） DCL（数据控制语言），作用于控制用户权限，管理数据库对象的访问权限，典型的语句有Grant和Revoke等。
TCL（Transaction Control Language） TCL（事物控制语言）是SQL子集，作用于管理事物，确保数据库操作的完整性，典型的语句有Commit、Rollback和Savepoint等。
数据类型 SQL除了操作查询数据的语句部分，还有定义了数据的类型，比如数值、字符串、日期、布尔值等，大部分都是比较好理解的，但日期则可以根据需求不同采用不同的日期类型，SQL定义了DATE、TIME和TIMESTAMP类型，主要差异在于：
DATE：DATE类型有8位数，分别为YYYYMMDD。 TIME：TIME类型有6位数，分别为HHMMSS。 TIMESTAMP：TIMESTAMP有20位数，分别为YYYYXXDDHHMMSSZZZZZZ，其中XX代表月份，ZZZZZZ代表微秒。 一些记录 大部分SQL可以很容易查询到用法，但是部分查询在性能和实现则有一定的区别，同时也有存在多种解决方式。
Primary Key 数据库中主键有如下几个功能：
唯一性：设置为主键的属性（数据库中被映射为了列），是唯一值，能够避免数据重复。 一致性和完整性：主键确保表每一行都有一个唯一的标识符，这对于维护数据的一致性非常重要。 关联性：在关系型数据库中，主键用于建立表与表之间的关系（通过外键引用）。 加速：数据库在创建主键的时候，会为主键创建索引，使得通过主键查询会非常快。 ER模型和ERD图 Entity-Relationship Model（ER模型） ER模型是用于设计实体关系模型的基础理论，关注实体（比如人）、实体的属性（比如人的头发、身高、体重、肤色等）以及相互之间的关联，ER模型的好处是可以针对字段进行规划关联、字段类型、主键以及多对一还是一对多等关系，同时设计完成后可以自动化生成sql进行自动建立数据库结构。
Entity Relationship Diagram（ERD图） 而ERD则是ER的一种图的实现，基于ER理论通过ERD进行设计实体关系图，会更加直观。
优势 如果只是画图，很多都可以画，但是ER模型和ERD都是专用数据库设计的，所以有很多其它画图工具达不到的功能，比如自动根据ERD图生成SQL脚本。
字符串查询和范围查询 SQL使用字符串进行查询，可以只给出部分关键词进行模糊查询，其中有%代表通配符（即匹配任何事情）。">
  <meta itemprop="datePublished" content="2024-12-29T21:36:34+00:00">
  <meta itemprop="dateModified" content="2024-12-29T21:36:34+00:00">
  <meta itemprop="wordCount" content="413">
  <meta itemprop="keywords" content="SQL">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.20/dist/katex.min.css" integrity="sha384-sMefv1J1YJCHsg0mTa9YG+n/9KnJb9lGrJUUY5arg6bAL1qps/oZjmUwaHlX5Ugg" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.20/dist/katex.min.js" integrity="sha384-i9p+YmlwbK0lT9RcfgdAo/Cikui1KeFMeV/0Fwsu+rzgsCvas6oUptNOmo29C33p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.20/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          output: 'html',
        
          
          throwOnError : false,
          newLineInDisplayMode: true,
          strict: false
        });
    });
</script>
<style>
    .katex * {
        font-size: 97%;
    }
    .katex-html {
        overflow: scroll;
    }
</style>




      <script async src="https://www.googletagmanager.com/gtag/js?id=G-V5WKEHZ2PS"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-V5WKEHZ2PS');
        }
      </script>

<style>
  body {
       
      font-family: Georgia,serif;
       
  }

  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
  
  table { 
    border-collapse: collapse; 
    text-align: center;
    font-size: 80%;
  }

  tr {
    border: solid 1px;
  }

  hr {
    border: 0;
    border-top: 1px dashed;
  }
</style>



<script>
    window.onload = function(){
        title = document.getElementsByClassName('title')[0];
        if (document.URL.split('/')[3] == 'en') {
            title.href = '/en';
        } else {
            title.href = '/';
        }
    }
</script>








<div class="toc">
  <hr />
    <details close>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#sql" aria-label="SQL">SQL</a></li>
                <li>
                    <a href="#%e6%9f%a5%e8%af%a2%e8%af%ad%e5%8f%a5" aria-label="查询语句">查询语句</a><ul>
                        
                <li>
                    <a href="#ddldata-definition-language" aria-label="DDL（Data Definition Language）">DDL（Data Definition Language）</a></li>
                <li>
                    <a href="#dmldata-manipulation-language" aria-label="DML（Data Manipulation Language）">DML（Data Manipulation Language）</a></li>
                <li>
                    <a href="#dcldata-control-language" aria-label="DCL（Data Control Language）">DCL（Data Control Language）</a></li>
                <li>
                    <a href="#tcltransaction-control-language" aria-label="TCL（Transaction Control Language）">TCL（Transaction Control Language）</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="数据类型">数据类型</a></li>
                <li>
                    <a href="#%e4%b8%80%e4%ba%9b%e8%ae%b0%e5%bd%95" aria-label="一些记录">一些记录</a><ul>
                        
                <li>
                    <a href="#primary-key" aria-label="Primary Key">Primary Key</a></li>
                <li>
                    <a href="#er%e6%a8%a1%e5%9e%8b%e5%92%8cerd%e5%9b%be" aria-label="ER模型和ERD图">ER模型和ERD图</a><ul>
                        
                <li>
                    <a href="#entity-relationship-modeler%e6%a8%a1%e5%9e%8b" aria-label="Entity-Relationship Model（ER模型）">Entity-Relationship Model（ER模型）</a></li>
                <li>
                    <a href="#entity-relationship-diagramerd%e5%9b%be" aria-label="Entity Relationship Diagram（ERD图）">Entity Relationship Diagram（ERD图）</a></li>
                <li>
                    <a href="#%e4%bc%98%e5%8a%bf" aria-label="优势">优势</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9f%a5%e8%af%a2%e5%92%8c%e8%8c%83%e5%9b%b4%e6%9f%a5%e8%af%a2" aria-label="字符串查询和范围查询">字符串查询和范围查询</a></li>
                <li>
                    <a href="#%e6%8e%92%e5%ba%8f" aria-label="排序">排序</a></li>
                <li>
                    <a href="#%e5%88%86%e7%bb%84" aria-label="分组">分组</a><ul>
                        
                <li>
                    <a href="#group-by" aria-label="GROUP BY">GROUP BY</a></li>
                <li>
                    <a href="#having" aria-label="HAVING">HAVING</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%90%e6%9f%a5%e8%af%a2" aria-label="子查询">子查询</a><ul>
                        
                <li>
                    <a href="#select" aria-label="SELECT">SELECT</a></li>
                <li>
                    <a href="#where" aria-label="WHERE">WHERE</a></li>
                <li>
                    <a href="#from%e6%88%96join" aria-label="FROM或JOIN">FROM或JOIN</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%81%9a%e5%90%88%e5%87%bd%e6%95%b0" aria-label="聚合函数">聚合函数</a><ul>
                        
                <li>
                    <a href="#%e6%97%a5%e6%9c%9f%e5%87%bd%e6%95%b0" aria-label="日期函数">日期函数</a></li>
                <li>
                    <a href="#%e6%a0%87%e9%87%8f%e5%92%8c%e8%81%9a%e5%90%88" aria-label="标量和聚合">标量和聚合</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%9a%e8%a1%a8%e6%9f%a5%e8%af%a2" aria-label="多表查询">多表查询</a><ul>
                        
                <li>
                    <a href="#%e5%ad%90%e6%9f%a5%e8%af%a2-1" aria-label="子查询">子查询</a></li>
                <li>
                    <a href="#%e9%9a%90%e5%bc%8fjoin" aria-label="隐式JOIN">隐式JOIN</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>

    <hr />
</div>

<script>
  window.onload = function(){
    toc = document.querySelector('.toc')
    document.querySelector('h1').nextElementSibling.after(toc)
  }
</script>
</head>

<body>
  <header><a href="/" class="title">
  <h2>Lucas Wu</h2>
</a>
<nav>
</nav>
</header>
  <main>

<h1>用于数据科学的SQL</h1>


<div class="asset-footer">
  
  <h3>文档信息</h3>
  <ul>
  <li>版权声明：自由转载-商用-保持署名（<a href="https://creativecommons.org/licenses/by/4.0/deed.zh-hans">创意共享4.0许可证</a>）</li>
  <li>发表日期： <abbr class="published" title="2024-12-29">2024-12-29</abbr></li>
  <li>分类信息：  
    <a href="https://vec6.com/categories/datascience/">#DataScience</a>
    
  </li>
  <li>标签信息：  
    <a href="https://vec6.com/tags/sql/">#SQL</a>
    
  </li>
  
  </ul>
</div>




<content>
  <p>如今在数据科学中使用SQL查询数据是常见的操作，而大部分以表格（行和列）展示数据的数据格式，几乎都支持使用SQL进行查询，比如Dataframe、Excel。</p>
<p>同时通过Jupyter Notebook提供的Magic Statements和IPython_SQL，能够让SQL和Python进行非常方便的结合。</p>
<h2 id="sql">SQL</h2>
<p>SQL全称为Structured Query Language 结构化查询语言，是基于Edgar F. Codd在1970年提出的关系模型理论，该模型引入了表（表格形式的数据结构）来表示数据以及其关系的概念，所以可以理解为最初的定位是用于操作和查询关系型数据库。</p>
<p>SQL 于 1986 年被 <strong>ANSI</strong>（美国国家标准学会）采纳，并于 1987 年被 <strong>ISO</strong>（国际标准化组织）采纳为关系型数据库的标准语言，所以目前制定标准的主要由ANSI和ISO两个组织。</p>
<p>SQL是一个标准，也是一个总称，SQL的定义了两个核心部分，第一个是标准的查询语句和标准的数据类型。</p>
<p>除了上述的这些子集，还有一些扩展的高级功能的子集，比如对非结构化数据的支持，使得SQL能够支持NoSQL、NewSQL以及大数据系统应用。</p>
<h2 id="查询语句">查询语句</h2>
<p>查询语句主要是围绕着DDL、DML、DCL以及TCL几个核心的子集开展，而常见的SELCT、CREATE都是属于这些子集，核心子集每个数据库（DBMS）都是支持的，但是每个数据库针对于SQL的扩展都会都会有一些差异，所以如果考虑到迁移性，应该尽可能使用标准的核心SQL语句。</p>
<h3 id="ddldata-definition-language">DDL（Data Definition Language）</h3>
<p>DDL（数据定义语言），理解为数据库的地基，负责定义和修改数据库结构和对象（如表、视图和索引等），典型的语句有CREATE、ALTER和DROP等。</p>
<h3 id="dmldata-manipulation-language">DML（Data Manipulation Language）</h3>
<p>DML（数据操作语言），作用于操作数据库的数据，对数据库中的数据进行查询、插入、更新和删除等操作，典型的语句有 Select查询数据、 Insert插入数据、Update更新修改数据、 Delete删除数据等。</p>
<p>DQL（Data Query Language）是专门用于查询的子集，但是是由DML下的子集，所以DML包含查询。</p>
<h3 id="dcldata-control-language">DCL（Data Control Language）</h3>
<p>DCL（数据控制语言），作用于控制用户权限，管理数据库对象的访问权限，典型的语句有Grant和Revoke等。</p>
<h3 id="tcltransaction-control-language">TCL（Transaction Control Language）</h3>
<p>TCL（事物控制语言）是SQL子集，作用于管理事物，确保数据库操作的完整性，典型的语句有Commit、Rollback和Savepoint等。</p>
<h2 id="数据类型">数据类型</h2>
<p>SQL除了操作查询数据的语句部分，还有定义了数据的类型，比如数值、字符串、日期、布尔值等，大部分都是比较好理解的，但日期则可以根据需求不同采用不同的日期类型，SQL定义了DATE、TIME和TIMESTAMP类型，主要差异在于：</p>
<ol>
<li>DATE：DATE类型有8位数，分别为YYYYMMDD。</li>
<li>TIME：TIME类型有6位数，分别为HHMMSS。</li>
<li>TIMESTAMP：TIMESTAMP有20位数，分别为YYYYXXDDHHMMSSZZZZZZ，其中XX代表月份，ZZZZZZ代表微秒。</li>
</ol>
<h2 id="一些记录">一些记录</h2>
<p>大部分SQL可以很容易查询到用法，但是部分查询在性能和实现则有一定的区别，同时也有存在多种解决方式。</p>
<h3 id="primary-key">Primary Key</h3>
<p>数据库中主键有如下几个功能：</p>
<ol>
<li>唯一性：设置为主键的属性（数据库中被映射为了列），是唯一值，能够避免数据重复。</li>
<li>一致性和完整性：主键确保表每一行都有一个唯一的标识符，这对于维护数据的一致性非常重要。</li>
<li>关联性：在关系型数据库中，主键用于建立表与表之间的关系（通过外键引用）。</li>
<li>加速：数据库在创建主键的时候，会为主键创建索引，使得通过主键查询会非常快。</li>
</ol>
<h3 id="er模型和erd图">ER模型和ERD图</h3>
<h4 id="entity-relationship-modeler模型">Entity-Relationship Model（ER模型）</h4>
<p>ER模型是用于设计实体关系模型的基础理论，关注实体（比如人）、实体的属性（比如人的头发、身高、体重、肤色等）以及相互之间的关联，ER模型的好处是可以针对字段进行规划关联、字段类型、主键以及多对一还是一对多等关系，同时设计完成后可以自动化生成sql进行自动建立数据库结构。</p>
<h4 id="entity-relationship-diagramerd图">Entity Relationship Diagram（ERD图）</h4>
<p>而ERD则是ER的一种图的实现，基于ER理论通过ERD进行设计实体关系图，会更加直观。</p>
<h4 id="优势">优势</h4>
<p>如果只是画图，很多都可以画，但是ER模型和ERD都是专用数据库设计的，所以有很多其它画图工具达不到的功能，比如自动根据ERD图生成SQL脚本。</p>
<h3 id="字符串查询和范围查询">字符串查询和范围查询</h3>
<p>SQL使用字符串进行查询，可以只给出部分关键词进行模糊查询，其中有%代表通配符（即匹配任何事情）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tablename <span style="color:#66d9ef">where</span> name <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;R%&#39;</span>
</span></span></code></pre></div><p>范围查询可以使用between和in关键词，比如查询2000-2010年之间的数据，使用比较运算符的大于等于和小于等于进行查询：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tablename <span style="color:#66d9ef">where</span> RealseYear <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2000</span> <span style="color:#66d9ef">AND</span> RealseYear <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2010</span>;
</span></span></code></pre></div><p>而上面的方式，同样使用比较运算符between和and等替：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tablename <span style="color:#66d9ef">where</span> RealseYear <span style="color:#66d9ef">BETWEEN</span> <span style="color:#ae81ff">2000</span> <span style="color:#66d9ef">and</span> <span style="color:#ae81ff">2010</span>;
</span></span></code></pre></div><p>再比如检查是不是等于某些值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tablename <span style="color:#66d9ef">where</span> Country <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;UK&#39;</span> <span style="color:#66d9ef">OR</span> Country <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;US&#39;</span>;
</span></span></code></pre></div><p>这样给定几个值的查询可以使用in关键词，然后给定一个元组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tablename <span style="color:#66d9ef">where</span> Country <span style="color:#66d9ef">in</span> (<span style="color:#e6db74">&#39;UK&#39;</span>,<span style="color:#e6db74">&#39;US&#39;</span>);
</span></span></code></pre></div><h3 id="排序">排序</h3>
<p>SQL的排序使用语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> <span style="color:#66d9ef">COLUMN</span>
</span></span></code></pre></div><p>指定排序列是一种方式，也可以给数值选定列排序，比如选择返回的数据集中的第二列进行排序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> <span style="color:#ae81ff">2</span>
</span></span></code></pre></div><h3 id="分组">分组</h3>
<p>SQL中使用GROUP BY关键词对结果进行分组，GROUP BY常与 聚合函数（如MAX、 MIN、COUNT、SUM）一起使用，对每组数据进行汇总计算，同时还可以使用HAVING关键词对分组结果进行过滤筛选。</p>
<h4 id="group-by">GROUP BY</h4>
<p>SQL中使用GROUP BY关键词对结果进行分组，将具有相同值的行归为一组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> column1, column2 <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> column1, column2;
</span></span></code></pre></div><p>比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>| product | category | quantity |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>|---------|----------|----------|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| apple  | fruit  | 10    |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| banana | fruit  | 20    |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| carrot | vegetable| 15    |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| apple  | fruit  | 5    |
</span></span></code></pre></div><p>然后分组进行计算：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> category, <span style="color:#66d9ef">SUM</span>(quantity) <span style="color:#66d9ef">AS</span> total_quantity
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> sales
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> category;
</span></span></code></pre></div><p>结果为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>| category  | total_quantity |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>|------------|----------------|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| fruit   | 15       |
</span></span></code></pre></div><h4 id="having">HAVING</h4>
<p>HAVING关键词用于筛选分组后的结果，与where不同的是，where会在分组前对原始数据进行筛选，而HAVING则是分组后的数据筛选，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> category, <span style="color:#66d9ef">SUM</span>(quantity) <span style="color:#66d9ef">AS</span> total_quantity
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> sales
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> category
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">HAVING</span> total_quantity <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">20</span>;
</span></span></code></pre></div><h3 id="子查询">子查询</h3>
<p>子查询与嵌套查询是一个意思，都是指SQL中将一个查询语句嵌套在另外一个查询语句中作为<strong>条件</strong>或者<strong>数据源</strong>。</p>
<p>子查询根据使用不同，可以返回单个值或者多个值来配合外部的查询。</p>
<p>一般在SQL语句中，子查询用括号包裹，并且存在于SELECT中作为列，WHERE作为条件，FROM或JOIN作为表。</p>
<h4 id="select">SELECT</h4>
<p>子查询返回多个或者单个值，作为外部查询的列值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span>, ( <span style="color:#66d9ef">SELECT</span> name <span style="color:#66d9ef">FROM</span> table2 ) <span style="color:#66d9ef">as</span> name <span style="color:#66d9ef">FROM</span> table1;
</span></span></code></pre></div><h4 id="where">WHERE</h4>
<p>子查询返回一个或者多个值，用于过滤外部查询的结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> table1 <span style="color:#66d9ef">WHERE</span> age <span style="color:#f92672">&gt;</span> ( <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">avg</span>(age) <span style="color:#66d9ef">FROM</span> table2 <span style="color:#66d9ef">where</span> age <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">18</span>) ;
</span></span></code></pre></div><p>返回子查询中的结果，也就是name和age。</p>
<h4 id="from或join">FROM或JOIN</h4>
<p>子查询返回一张虚拟表，供外部查询和使用，但作为这种使用，子查询必须有一个别名，不然SQL引擎无法识别子查询的结果表。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> (<span style="color:#66d9ef">SELECT</span> name,age <span style="color:#66d9ef">FROM</span> table2 <span style="color:#66d9ef">where</span> age <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">18</span>) <span style="color:#66d9ef">as</span> subquery ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">----第二种
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> t1.name, t1.age <span style="color:#66d9ef">FROM</span> table1 <span style="color:#66d9ef">AS</span> t1 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">（</span><span style="color:#66d9ef">SELECT</span> name, age <span style="color:#66d9ef">from</span> table2 <span style="color:#66d9ef">where</span> age <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">18</span><span style="color:#960050;background-color:#1e0010">）</span> <span style="color:#66d9ef">AS</span> t2 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ON</span> t1.name <span style="color:#f92672">=</span> t2.name
</span></span></code></pre></div><h3 id="聚合函数">聚合函数</h3>
<p>聚合函数不是SQL语言内置的，功能是由DBMS提供实现的，但SQL定义了一些基础的标准聚合函数，这些函数是可以达到夸平台的通用基础聚合函数，被大部分DBMS实现：</p>
<ol>
<li>COUNT：计算行数</li>
<li>SUM：计算列的综合</li>
<li>AVG：计算列的平均值</li>
<li>MAX：计算列的最大值</li>
<li>MIN：计算列的最小值</li>
</ol>
<p>除此之外，SQL还定义了部分稍微高级的聚合函数，比如<strong>EVERY、ANY、SOME</strong>等，但这些都不是被DBMS默认实现，所以不同的数据库提供的聚合函数可能有一些差异，</p>
<p>除此之外还有一个MID函数比较有意思，可以从字段的值里面提取指定位置的字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> MID(<span style="color:#66d9ef">column_name</span>, <span style="color:#66d9ef">start</span>, <span style="color:#66d9ef">length</span>) <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">table_name</span>;
</span></span></code></pre></div><p>其中start为开始位置，而length为从开始位置开始计算提取多长。</p>
<h4 id="日期函数">日期函数</h4>
<p>日期函数有助于在时间格式提取相关的值，比如YEAR、MONTH、DAY、WEEK、HOUR、MINUTE等，可以提取日期中的年、月、天、星期、小时和分钟，而还有DATEDIFF则可以计算两个日期之间的间隔，FROM_DAYS则是将天转换为日期，适用于日期相减的结果的时候使用。</p>
<p>除此之外，还有一些特殊的寄存器，比如CURRENT_DATE、CURRENT_TIME储存着当前的日期和当前的时间。</p>
<h4 id="标量和聚合">标量和聚合</h4>
<p>SQL的函数可以分位聚合和标量函数，标量函数即对每一行进行计算，返回每一行的单个值，即输入多少行，返回多少行，典型的比如MONTH提取每行的月份和ROUND对输入的行的数值进行小数位设定。</p>
<p>聚合函数即对多行数据进行计算，并返回单个值的函数，即输入多行，返回单个值，典型的就是COUNT函数。</p>
<h3 id="多表查询">多表查询</h3>
<p>多表查询有<strong>子查询、隐式JOIN和JOIN ON操作符</strong>来进行多表的查询。</p>
<h4 id="子查询-1">子查询</h4>
<p>比如下面的查询，想筛选部门地址为’10001’的所有员工，但是employees表没有部门的地址信息，只有departments表有，所有就可以通过子查询进行多表筛选。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> employees 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> DEP_ID <span style="color:#66d9ef">IN</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">SELECT</span> DEPT_ID_DEP <span style="color:#66d9ef">FROM</span> departments <span style="color:#66d9ef">where</span> loc_id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;10001&#39;</span>)
</span></span></code></pre></div><h4 id="隐式join">隐式JOIN</h4>
<p>当查询中未指定连接条件（例如 ON 或 WHERE），每张表的每一行会与另一张表的每一行组合，形成笛卡尔积。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>table1:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>id<span style="color:#f92672">**</span>	<span style="color:#f92672">**</span>name<span style="color:#f92672">**</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>	Alice
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>	Bob
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Table2:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>product_id<span style="color:#f92672">**</span>	<span style="color:#f92672">**</span>product_name<span style="color:#f92672">**</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">101</span>	Laptop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">102</span>	Smartphone
</span></span></code></pre></div><p>查询结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> table1, table2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">**</span>id<span style="color:#f92672">**</span>	<span style="color:#f92672">**</span>name<span style="color:#f92672">**</span>	<span style="color:#f92672">**</span>product_id<span style="color:#f92672">**</span>	<span style="color:#f92672">**</span>product_name<span style="color:#f92672">**</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>	Alice	<span style="color:#ae81ff">101</span>	Laptop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>	Alice	<span style="color:#ae81ff">102</span>	Smartphone
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>	Bob	<span style="color:#ae81ff">101</span>	Laptop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>	Bob	<span style="color:#ae81ff">102</span>	Smartphone
</span></span></code></pre></div><p>但隐式JOIN可以通过条件来限定返回的内容，限定了过后，实际上是和Inner Join逻辑是相同的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> TABLE1, TABLE2 <span style="color:#66d9ef">WHERE</span> TABLE1.name <span style="color:#f92672">=</span> TABLE2.name;
</span></span></code></pre></div>
  (完)
</content>



<hr />


  </main>
  <footer><p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><span
        property="dct:title">Lucas's blog</span> by <a rel="cc:attributionURL dct:creator" property="cc:attributionName"
        href="http://vec6.com">lucas</a> is licensed under <a
        href="https://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank"
        rel="license noopener noreferrer" style="display:inline-block;">CC BY 4.0<img
            style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
            src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img
            style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
            src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""></a>
    | theme: <a href="https://github.com/janraasch/hugo-bearblog/">Bear</a> 
    <br />
    Language Switcher: 

    
    
    
    <a title="English" href="/en">English</a>
    
    
    

    
</p>


</footer>

    </body>

</html>
