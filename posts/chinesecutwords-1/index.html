<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>(一)漫话中文分词：最大匹配,双向最大,最小词数 | Yizhou&#39;s Website</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="中文分词是指将文本拆分为单词的过程，而结果集合连接起来是等于原始的文本，而中文分词一直作为NLP领域的比较重要的领域，而大多数的文本挖掘都是">
<meta name="generator" content="Hugo 0.121.1">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  





    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          "HTML-CSS": { scale: 85 },
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true
          }
        });
    </script>
    
    <script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>





  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	<a href="/posts">归档</a>
	<a href="/tags">标签</a>
	<a href="/about">关于</a>

	

	
	  <a class="button" href="https://wuyizhou.com/index.xml">订阅</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">(一)漫话中文分词：最大匹配,双向最大,最小词数</h1>

    <div class="tip">
        <time datetime="2020-11-08 10:36:34 &#43;0000 UTC">2020年11月08日</time>
        <span class="split">
          ·
        </span>
        <span>
          4144字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          9分钟
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#词典分词">词典分词</a>
      <ul>
        <li><a href="#正向最大匹配算法forward-maximum-matching">正向最大匹配算法（Forward Maximum Matching）</a></li>
        <li><a href="#反向最大匹配算法backward-maximum-matching">反向最大匹配算法（Backward Maximum Matching）</a></li>
        <li><a href="#双向最大匹配算法bidirectional-maximum-match">双向最大匹配算法（Bidirectional Maximum Match）</a></li>
        <li><a href="#最少词数算法minimal-word-count">最少词数算法（Minimal Word Count）</a></li>
      </ul>
    </li>
    <li><a href="#参考文档">参考文档</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>中文分词是指将文本拆分为单词的过程，而结果集合连接起来是等于原始的文本，而中文分词一直作为NLP领域的比较重要的领域，而大多数的文本挖掘都是以分词为基础，但中文不同于英文，英文每个单词是用空格分隔，整体语义上相对于中文难度低很多。 而业务上一直有中文分词的需求，但是之前因为在忙于另外一个项目，所以一直没有研究。 近期稍空闲开始研究了相关的中文分词算法，发现中文分词总体算比较成熟，但是其中对于未登录词或者某个特定专业领域文本大部分算法分词的结果不尽人意，需要结合多种算法或者人工词典才能达到稍微好一点的效果。 中文分词的方式一共有两种，分别为：</p>
<ol>
<li>词典分词：如正向最大匹配算法、反向最大匹配算法、双向最大匹配算法、最少词数法等</li>
<li>字标注分词：如HMM（隐马尔可夫）模型等</li>
</ol>
<p>而这几种方式很难说出谁好谁坏，比如词典分词的方式速度非常快，但对于未登录词的识别又不太好，而HMM和Pkuseg都能识别部分未登录词，但是运行速度又降下来了，这对于在实际应用场景当中是非常致命的问题，所以最大的优解就是集各家所长，比如结巴分词就使用了词典分词算法识别能识别的词，而不能识别的则继续使用了HMM模型来处理。</p>
<h2 id="词典分词">词典分词 <a href="#%e8%af%8d%e5%85%b8%e5%88%86%e8%af%8d" class="anchor">🔗</a></h2><p>基于词典的分词算法实际上就是对于类似字典的数据结构进行查询，对于未在词典内的词识别较弱和交集型歧义理解能力也较弱，比如“结婚的和尚未结婚的”，理想的情况是&quot;结婚/的/和/尚未/结婚/的&quot;，而实际中则会被分词为&quot;结婚/的/和尚/未/结婚/的&quot;。 但好在词典分词的速度则非常快，词典分词目前已有非常成熟高效的解决方案，并且有非常多的工具来帮你实现相关的高效数据结构和查询方式，比如<a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">Trie树</a>和<a href="https://zh.wikipedia.org/wiki/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">AC自动机</a>，但在这里为了方便理解和记录，只采用了尽可能简单的方式来记录其几种算法的实现和原理。</p>
<h3 id="正向最大匹配算法forward-maximum-matching">正向最大匹配算法（Forward Maximum Matching） <a href="#%e6%ad%a3%e5%90%91%e6%9c%80%e5%a4%a7%e5%8c%b9%e9%85%8d%e7%ae%97%e6%b3%95forward-maximum-matching" class="anchor">🔗</a></h3><p>正向最大匹配算法类似于人的阅读习惯，即从左到右进行识别，而其中的&quot;最大&quot;是基于词典中最长字符的长度作为最大的匹配宽度，然后每次根据这个宽度对文本进行切分并取出来查询词典。如果当前取出来的词能在词典当中查询当则返回，并下一次切分的开始位置为该词的位置+1。而如果当前取出的部分没有在词典中查找到，则将该部分去掉最后一个字符后再进行查找，一直重复直到匹配到了词典中的词。如果整个部分只剩余一个字符，并没有匹配到词典中的词，则将最后剩余的这个字符输出，然后根据这个字符的位置+1开始再次进行切分和查询。 比如，有一段文本&quot;中文分词算法&quot;，字典中只包含了一个词&quot;分词&quot;，这个时候最大的匹配宽度也为2，所以整段文本按照2个字符进行切分。第一次得到&quot;中文&quot;文本，查找词典并无该词，则在该部分上去掉最后的字符，得到&quot;中&quot;，再次查询词典并无该词，此时查找结束，所以不需要再进行匹配，则这个切分记为[&ldquo;中&rdquo;]。 继续进行第二次切分，得到的文本为&quot;文分&quot;，进行查询词典，第一次查询&quot;文分&quot;在字典中不存在，去掉最后一个字符，继续以剩余部分&rsquo;文&rsquo;查询第二次，未查询到，那么返回最后这个字符&quot;文&quot;，加上次的结果记作[&ldquo;中&rdquo;,&ldquo;文&rdquo;] 继续第三次切分，得到文本&quot;分词&quot;，进行查询词典，查询到该词在字典当中，所以直接记录在之前的结果当中，记作[&ldquo;中&rdquo;, &ldquo;文&rdquo;, &ldquo;分词&rdquo;]。 继续第四次切分，得到文本&quot;算法&quot;，进行查询字典，第一次查询&quot;算法&quot;在字典中不存在，去掉最后一个字符，继续以剩余部分&rsquo;算&rsquo;查询第二次，未查询到，那么返回最后这个字符&quot;算&quot;，加上次的结果记作[&ldquo;中&rdquo;, &ldquo;文&rdquo;, &ldquo;分词&rdquo;, &ldquo;算&rdquo;] 继续第五次切分，因为最后只剩余一个字符，所以这个时候可以不进行匹配即返回，所以最终的结果为[&ldquo;中&rdquo;, &ldquo;文&rdquo;, &ldquo;分词&rdquo;, &ldquo;算&rdquo;, &ldquo;法&rdquo;] 整体分词的过程本质对每个分块进行查找，并依次去掉最后字符查询，而网上还有一部分是没有使用最大宽度切分，即会对每个字符到文本结束的位置都会依次遍历，这样的方式实际上会浪费较多的资源，因为即使从头到尾依次遍历匹配，但最长词的长度是固定的，所以真正开始匹配还是从最长词的长度开始，而其余的遍历都是浪费了资源。 正向最大匹配算法具体的实现代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>sentence = &#39;中文分词算法&#39; # 输入的句子
</span></span><span style="display:flex;"><span>cutList = [&#39;分词&#39;]  # 分词词典
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start = 0 #设置切分起始位置
</span></span><span style="display:flex;"><span>maxWidth = len(max(cutList, key=len)) # 得到字典当中最大的切分宽度
</span></span><span style="display:flex;"><span>cut_result = [] # 设置一个空的分词结果
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (start &lt;= len(sentence)):  #开始循环，如果start大于等于句子长度则停止分词
</span></span><span style="display:flex;"><span>    end = start + maxWidth     # 计算每次切分的停止位置
</span></span><span style="display:flex;"><span>    word = sentence[start: end] # 开始切分，文本为变量start和end的区间内字符
</span></span><span style="display:flex;"><span>    while ( word ) :  # python对于空字符串会转换为False
</span></span><span style="display:flex;"><span>        if ( word in cutList ) :  # 查看第一次切分后是否能在词典中匹配，如果匹配则放入最终的分词结果列表cut_result,并跳出循环
</span></span><span style="display:flex;"><span>            cut_result.append(word)
</span></span><span style="display:flex;"><span>            start = start + len(word) - 1  # 然后将开始位置设置为当前开始位置加上被匹配词的长度
</span></span><span style="display:flex;"><span>            break 
</span></span><span style="display:flex;"><span>        if (len(word[:-1]) == 0):
</span></span><span style="display:flex;"><span>            cut_result.append(word) # 如果最后一个字符也没有被匹配到，那么返回最后一个字符
</span></span><span style="display:flex;"><span>            break
</span></span><span style="display:flex;"><span>        word = word[:-1]  # 将word去掉最后一个字符串并重新计算
</span></span><span style="display:flex;"><span>    start = start + 1  # 将位置加1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(cut_result)
</span></span><span style="display:flex;"><span>#[&#39;中&#39;, &#39;文&#39;, &#39;分词&#39;, &#39;算&#39;, &#39;法&#39;] 
</span></span></code></pre></div><h3 id="反向最大匹配算法backward-maximum-matching">反向最大匹配算法（Backward Maximum Matching） <a href="#%e5%8f%8d%e5%90%91%e6%9c%80%e5%a4%a7%e5%8c%b9%e9%85%8d%e7%ae%97%e6%b3%95backward-maximum-matching" class="anchor">🔗</a></h3><p>反向最大匹配算法与正向最大匹配算法是相反的，比如&quot;中文分词算法&quot;文本的正向最大匹配算法在切分宽度为2的时候，是从&quot;中文&quot;开始切分的，而反向则是从&quot;算法&quot;开始切分的。 除了反向的切分，其中对于切分块内的文本依次去掉最后一个字符也变为了依次去掉第一个字符，比如正向第一个切分块&quot;中文&quot;后，如果没有匹配到，则去掉&quot;文&quot;，再对&quot;中&quot;字符进行匹配，而反向则是拿到&quot;算法&quot;后，如果没有匹配到，则是去掉&quot;算&quot;，再对&quot;法&quot;进行匹配。 反向最大匹配算法对比于正向最大匹配算法来说，可以解决一定的交集型歧义，比如本文&quot;他说的确实在理&quot;，理想情况下希望的分词结果中包含&quot;确实&quot;这一词，而正向最大匹配算法结果为&quot;他/说/的确/实/在理&quot;，而反向最大匹配算法的结果为&quot;他/说/的/确实/在理&quot;。 这两种方式很难区分到底谁好谁坏，比如上面的问题中，如果你希望的分词为&quot;的确&quot;，但是如果使用反向的话就很难被分出来。 反向最大匹配算法具体的实现代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>sentence = &#39;他说的确实在理&#39; # 输入的句子
</span></span><span style="display:flex;"><span>cutList = [&#39;的确&#39;, &#39;确实&#39;]  # 分词词典
</span></span><span style="display:flex;"><span>start = len(sentence) #设置切分起始位置为该文本的最后一个字符
</span></span><span style="display:flex;"><span>maxWidth = len(max(cutList, key=len)) # 得到字典当中最大的切分宽度
</span></span><span style="display:flex;"><span>cut_result = [] # 设置一个空的分词结果
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>while (start &gt; 0):  #开始循环，如果start大于等于句子长度则停止分词
</span></span><span style="display:flex;"><span>    end = start - maxWidth   # 计算结束位置，结束位置为开始位置减去宽度
</span></span><span style="display:flex;"><span>    word = sentence[end: start] # 开始切分，文本为变量end和start的区间内字符
</span></span><span style="display:flex;"><span>    while ( word ) :  # python对于空字符串会转换为False
</span></span><span style="display:flex;"><span>        if ( word in cutList ) :  # 查看第一次切分后是否能在词典中匹配，如果匹配则放入最终的分词结果列表cut_result,并跳出循环
</span></span><span style="display:flex;"><span>            cut_result.insert(0,word)
</span></span><span style="display:flex;"><span>            start = start - len(word) + 1  # 然后将开始位置设置为当前开始位置加上被匹配词的长度
</span></span><span style="display:flex;"><span>            break
</span></span><span style="display:flex;"><span>        if (len(word) == 1):
</span></span><span style="display:flex;"><span>            cut_result.insert(0, word) # 返回最后一个字符
</span></span><span style="display:flex;"><span>            break
</span></span><span style="display:flex;"><span>        word = word[1:]  # 将word去掉第一个字符串并重新计算
</span></span><span style="display:flex;"><span>    start = start - 1  # 将位置减1
</span></span><span style="display:flex;"><span>cut_result.insert(0, sentence[0]) # 将剩余的第一个字符添加进结果
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(cut_result)
</span></span><span style="display:flex;"><span>#[&#39;他&#39;, &#39;说&#39;, &#39;的&#39;, &#39;确实&#39;, &#39;在&#39;, &#39;理&#39;] 
</span></span></code></pre></div><h3 id="双向最大匹配算法bidirectional-maximum-match">双向最大匹配算法（Bidirectional Maximum Match） <a href="#%e5%8f%8c%e5%90%91%e6%9c%80%e5%a4%a7%e5%8c%b9%e9%85%8d%e7%ae%97%e6%b3%95bidirectional-maximum-match" class="anchor">🔗</a></h3><p>双向最大匹配算法是将正向和反向结果的颗粒度进行比较的一种算法，本质上是一种规则系统，该规则为如下：</p>
<ol>
<li>返回词数最少的结果</li>
<li>返回单字词更少的结果</li>
<li>如果两则都相同优先返回反向最大匹配算法结果</li>
</ol>
<p>因为双向最大匹配算法实际上是一种规则系统，只需要对结果进行判断优先返回哪种结果，所以这里就不过多的说明。但需要注意的是采用双向最大匹配算法实际上运行了两种算法，所以对于运算量来说是双倍。</p>
<h3 id="最少词数算法minimal-word-count">最少词数算法（Minimal Word Count） <a href="#%e6%9c%80%e5%b0%91%e8%af%8d%e6%95%b0%e7%ae%97%e6%b3%95minimal-word-count" class="anchor">🔗</a></h3><p>最少词数算法也被称为最少切分算法，最少词数算法的本质是将一段文本分词的结果最少，最少次数算法整个过程是将字典按照长度进行排序，首先对最长的字典中的词进行匹配字符串，如果有则切分，并继续匹配下一个字典中的词，如果没有则继续匹配按照顺序匹配。 比如&quot;独立自主和平等互利的原则&quot;，正向匹配的结果为&quot;独立自主/和平/等/互利/的/原则&quot;，而最少词数的结果&quot;独立自主/和/平等互利/的/原则&quot;。 下面为一个非常简单的实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>sentence = &#39;独立自主和平等互利的原则&#39; # 输入的句子
</span></span><span style="display:flex;"><span>cutList = [&#39;独立自主&#39;, &#39;平等互利&#39;, &#39;独立&#39;, &#39;自主&#39;, &#39;和平&#39;, &#39;平等&#39;, &#39;互利&#39;, &#39;原则&#39;]  # 分词词典
</span></span><span style="display:flex;"><span>cutList = sorted(cutList, key=len, reverse=True) # 字典排序
</span></span><span style="display:flex;"><span>for cut in cutList:
</span></span><span style="display:flex;"><span>    if(&#39;/%s&#39;%cut not in sentence and &#39;%s/&#39;%cut not in sentence and cut in sentence) :
</span></span><span style="display:flex;"><span>        sentence = sentence.replace(cut, &#39;/%s/&#39;%cut)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(sentence)
</span></span><span style="display:flex;"><span>#/独立自主/和/平等互利/的/原则 
</span></span></code></pre></div><h2 id="参考文档">参考文档 <a href="#%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3" class="anchor">🔗</a></h2><ol>
<li><a href="https://www.cnblogs.com/cyandn/p/10891608.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyandn/p/10891608.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/103392455" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103392455</a></li>
<li><a href="http://www.matrix67.com/blog/archives/4212" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/4212</a></li>
<li><a href="https://kexue.fm/archives/3908" target="_blank" rel="noopener">https://kexue.fm/archives/3908</a></li>
</ol>

    </div>

    
        <div class="tags">
            
                <a href="https://wuyizhou.com/tags/%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95">数学与算法</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/wyizhou" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://stackoverflow.com/users/11949960" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>stackoverflow</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-488.000000, -1163.000000)">
            <g id="stackoverflow" transform="translate(488.000000, 1163.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M42.0860128,53.5922927 L22.9745951,53.6011499 L22.9729497,49.5538824 L42.0835447,49.5440929 L42.0860128,53.5922927 L42.0860128,53.5922927 Z M55,30.6708298 L51.7306912,12 L47.7087256,12.6920259 L50.9775643,31.3628557 L55,30.6708298 L55,30.6708298 Z M42.5455518,44.3547147 L23.5156994,42.616026 L23.1410164,46.6470941 L42.1712214,48.3841513 L42.5455518,44.3547147 L42.5455518,44.3547147 Z M43.8009984,39.0731519 L25.3459811,34.1539179 L24.285633,38.0621508 L42.7419431,42.9819676 L43.8009984,39.0731519 L43.8009984,39.0731519 Z M46.2103463,34.4436411 L29.7494464,24.8164635 L27.6748215,28.3015328 L44.1365441,37.9292931 L46.2103463,34.4436411 L46.2103463,34.4436411 Z M50.2466504,31.6088756 L46.8745036,33.8883189 L36.106599,18.2318456 L39.4792159,15.9517031 L50.2466504,31.6088756 Z M45.3315807,40.2784283 L48.5799693,40.2784283 L48.5799693,60 L17,60 L17,40.2784283 L20.2648427,40.2784283 L20.2648427,56.8243495 L45.3315807,56.8243495 L45.3315807,40.2784283 Z" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://twitter.com/5yizhou" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"
	 xml:space="preserve">
<g>
	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123
		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126
		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225
		C438.532,59.576,430.49,40.204,414.41,24.123z M335.471,168.735c0.191,1.713,0.288,4.278,0.288,7.71
		c0,15.989-2.334,32.025-6.995,48.104c-4.661,16.087-11.8,31.504-21.416,46.254c-9.606,14.749-21.074,27.791-34.396,39.115
		c-13.325,11.32-29.311,20.365-47.968,27.117c-18.648,6.762-38.637,10.143-59.953,10.143c-33.116,0-63.76-8.952-91.931-26.836
		c4.568,0.568,9.329,0.855,14.275,0.855c27.6,0,52.439-8.565,74.519-25.7c-12.941-0.185-24.506-4.179-34.688-11.991
		c-10.185-7.803-17.273-17.699-21.271-29.691c4.947,0.76,8.658,1.137,11.132,1.137c4.187,0,9.042-0.76,14.56-2.279
		c-13.894-2.669-25.598-9.562-35.115-20.697c-9.519-11.136-14.277-23.84-14.277-38.114v-0.571
		c10.085,4.755,19.602,7.229,28.549,7.422c-17.321-11.613-25.981-28.265-25.981-49.963c0-10.66,2.758-20.747,8.278-30.264
		c15.035,18.464,33.311,33.213,54.816,44.252c21.507,11.038,44.54,17.227,69.092,18.558c-0.95-3.616-1.427-8.186-1.427-13.704
		c0-16.562,5.853-30.692,17.56-42.399c11.703-11.706,25.837-17.561,42.394-17.561c17.515,0,32.079,6.283,43.688,18.846
		c13.134-2.474,25.892-7.33,38.26-14.56c-4.757,14.652-13.613,25.788-26.55,33.402c12.368-1.716,23.88-4.95,34.537-9.708
		C357.458,149.793,347.462,160.166,335.471,168.735z"/>
</g>
</svg>

    </a>


</div>

    

    <div class="copyright">
    
        © Copyright 2023 Yizhou
    
    </div>

    
</footer>



  </body>
</html>
