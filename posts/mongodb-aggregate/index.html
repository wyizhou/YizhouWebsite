<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Mongodb 聚合 | Yizhou</title>
<meta name="keywords" content="服务和运维">
<meta name="description" content="参考 MongoDB权威指南(第2版)
Mongodb Docs
前言 Mongodb提供了一个强大的处理框架，可以对集合中的文档进行各种组合、过滤、输出，如果你通过Mongodb其他的查询方法无法处理你的查询或者查询难度很高，那么你可以试试聚合。
这里我们只讲解一下常用的聚合管道操作符，其他的可以自行到官方文档进行查询。
语法 官方文档的聚合语法是这样的：
db.collection.aggregate（pipeline，options); 聚合：计算集合或视图中数据的聚合值，并且聚合接受一个数组，数组的每一个成员都是对象，对象里面子键都代表一个管道操作，按照顺序的从第一个管道操作到最后一个，每次操作完的文档返回给下一个管道操作。
pipeline： 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算，在版本2.6中更改：该方法仍然可以将流水线阶段接受为单独的参数，而不是数组中的元素; 但是，如果不指定pipeline为数组，则不能指定 options参数。
options:可选的。aggregate()传递给aggregate命令的附加选项。版本2.6中的新功能，仅当您指定pipeline为数组时可用。
大概我们可以把聚合理解为对文档进行一系列的操作从而达到我们需要的查询文档，聚合提供了很多管道操作符，这些管道操作符就像一根一根的管道一些，而我们通过聚合操作的文档就像管道里面的水，这根管道流下来的水继续流到下一根管道，直到没有了管道，水就流出来了。 我将在下面讲解几个常用的管道操作符，你也可以单独使用其中任意的管道操作符，分别为：
match(过滤): 过滤文档流，只允许匹配的文档未修改地传递到下一个流水线阶段。$match 使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零个文档（不匹配）。
$project(映射)：重新整理流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。
$group(分组)：通过一些指定的累加器将组文档输出到下一阶段，为每个不同的分组输出文档。
$unwind(拆分)：从输入文档中解构一个数组字段，以输出每个元素的文档。每个输出文档用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组可以为零。
$sort(排序)：按指定的排序键重新排序文档流。
$limit(限制)：将前n个文档传递到管道，n是一个数字。
$skip(跳过)：将前n个文档丢弃，后面的部分传递到管道。
上面的顺序一般是我们常用的顺序，首先我们筛选一部分文档，然后从筛选中整理一份更加便于我们操作的文档，然后在对整理好的文档通过一些表达式来分组整理，然后通过排序、限制、跳过，得到我们最终的结果。 在管道操作符中如果需要指定文档中的某个键的时候，需要在键名前面加上$符号，比如文档中的name键，在管道操作中要指定它就得这样写$name。 并且我们所有的操作的文档都不是操作储存在硬盘中的数据，我们操作的文档都是储存在内存当中，所以不影响原始数据。
管道操作符 $match $match应尽量放在聚合的最前面，因为$match使用的是Mongodb的标准查询，所以可以使用索引来提高我们的效率，其次是可以过滤掉不需要的文档，让后续的操作更加效率。 既然是标准的查询我们就可以使用标准查询里面所有操作符。 下面来大概演示一下$match的操作方法： 实例的文档结构如下:
{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 } { &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 } { &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 } { &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 查询author键的值为dave的文档：">
<meta name="author" content="">
<link rel="canonical" href="https://wuyizhou.com/posts/mongodb-aggregate/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a8f329a89028c2356cb4f3650b14732202f51894615d7b3cfa1c3da20473eba1.css" integrity="sha256-qPMpqJAowjVstPNlCxRzIgL1GJRhXXs8&#43;hw9ogRz66E=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://wuyizhou.com/images/favicon.ico">

<link rel="apple-touch-icon" href="https://wuyizhou.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://wuyizhou.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" /><meta property="og:title" content="Mongodb 聚合" />
<meta property="og:description" content="参考 MongoDB权威指南(第2版)
Mongodb Docs
前言 Mongodb提供了一个强大的处理框架，可以对集合中的文档进行各种组合、过滤、输出，如果你通过Mongodb其他的查询方法无法处理你的查询或者查询难度很高，那么你可以试试聚合。
这里我们只讲解一下常用的聚合管道操作符，其他的可以自行到官方文档进行查询。
语法 官方文档的聚合语法是这样的：
db.collection.aggregate（pipeline，options); 聚合：计算集合或视图中数据的聚合值，并且聚合接受一个数组，数组的每一个成员都是对象，对象里面子键都代表一个管道操作，按照顺序的从第一个管道操作到最后一个，每次操作完的文档返回给下一个管道操作。
pipeline： 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算，在版本2.6中更改：该方法仍然可以将流水线阶段接受为单独的参数，而不是数组中的元素; 但是，如果不指定pipeline为数组，则不能指定 options参数。
options:可选的。aggregate()传递给aggregate命令的附加选项。版本2.6中的新功能，仅当您指定pipeline为数组时可用。
大概我们可以把聚合理解为对文档进行一系列的操作从而达到我们需要的查询文档，聚合提供了很多管道操作符，这些管道操作符就像一根一根的管道一些，而我们通过聚合操作的文档就像管道里面的水，这根管道流下来的水继续流到下一根管道，直到没有了管道，水就流出来了。 我将在下面讲解几个常用的管道操作符，你也可以单独使用其中任意的管道操作符，分别为：
match(过滤): 过滤文档流，只允许匹配的文档未修改地传递到下一个流水线阶段。$match 使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零个文档（不匹配）。
$project(映射)：重新整理流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。
$group(分组)：通过一些指定的累加器将组文档输出到下一阶段，为每个不同的分组输出文档。
$unwind(拆分)：从输入文档中解构一个数组字段，以输出每个元素的文档。每个输出文档用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组可以为零。
$sort(排序)：按指定的排序键重新排序文档流。
$limit(限制)：将前n个文档传递到管道，n是一个数字。
$skip(跳过)：将前n个文档丢弃，后面的部分传递到管道。
上面的顺序一般是我们常用的顺序，首先我们筛选一部分文档，然后从筛选中整理一份更加便于我们操作的文档，然后在对整理好的文档通过一些表达式来分组整理，然后通过排序、限制、跳过，得到我们最终的结果。 在管道操作符中如果需要指定文档中的某个键的时候，需要在键名前面加上$符号，比如文档中的name键，在管道操作中要指定它就得这样写$name。 并且我们所有的操作的文档都不是操作储存在硬盘中的数据，我们操作的文档都是储存在内存当中，所以不影响原始数据。
管道操作符 $match $match应尽量放在聚合的最前面，因为$match使用的是Mongodb的标准查询，所以可以使用索引来提高我们的效率，其次是可以过滤掉不需要的文档，让后续的操作更加效率。 既然是标准的查询我们就可以使用标准查询里面所有操作符。 下面来大概演示一下$match的操作方法： 实例的文档结构如下:
{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 } { &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 } { &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 } { &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 查询author键的值为dave的文档：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wuyizhou.com/posts/mongodb-aggregate/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-10T14:18:52+00:00" />
<meta property="article:modified_time" content="2017-08-10T14:18:52+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Mongodb 聚合"/>
<meta name="twitter:description" content="参考 MongoDB权威指南(第2版)
Mongodb Docs
前言 Mongodb提供了一个强大的处理框架，可以对集合中的文档进行各种组合、过滤、输出，如果你通过Mongodb其他的查询方法无法处理你的查询或者查询难度很高，那么你可以试试聚合。
这里我们只讲解一下常用的聚合管道操作符，其他的可以自行到官方文档进行查询。
语法 官方文档的聚合语法是这样的：
db.collection.aggregate（pipeline，options); 聚合：计算集合或视图中数据的聚合值，并且聚合接受一个数组，数组的每一个成员都是对象，对象里面子键都代表一个管道操作，按照顺序的从第一个管道操作到最后一个，每次操作完的文档返回给下一个管道操作。
pipeline： 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算，在版本2.6中更改：该方法仍然可以将流水线阶段接受为单独的参数，而不是数组中的元素; 但是，如果不指定pipeline为数组，则不能指定 options参数。
options:可选的。aggregate()传递给aggregate命令的附加选项。版本2.6中的新功能，仅当您指定pipeline为数组时可用。
大概我们可以把聚合理解为对文档进行一系列的操作从而达到我们需要的查询文档，聚合提供了很多管道操作符，这些管道操作符就像一根一根的管道一些，而我们通过聚合操作的文档就像管道里面的水，这根管道流下来的水继续流到下一根管道，直到没有了管道，水就流出来了。 我将在下面讲解几个常用的管道操作符，你也可以单独使用其中任意的管道操作符，分别为：
match(过滤): 过滤文档流，只允许匹配的文档未修改地传递到下一个流水线阶段。$match 使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零个文档（不匹配）。
$project(映射)：重新整理流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。
$group(分组)：通过一些指定的累加器将组文档输出到下一阶段，为每个不同的分组输出文档。
$unwind(拆分)：从输入文档中解构一个数组字段，以输出每个元素的文档。每个输出文档用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组可以为零。
$sort(排序)：按指定的排序键重新排序文档流。
$limit(限制)：将前n个文档传递到管道，n是一个数字。
$skip(跳过)：将前n个文档丢弃，后面的部分传递到管道。
上面的顺序一般是我们常用的顺序，首先我们筛选一部分文档，然后从筛选中整理一份更加便于我们操作的文档，然后在对整理好的文档通过一些表达式来分组整理，然后通过排序、限制、跳过，得到我们最终的结果。 在管道操作符中如果需要指定文档中的某个键的时候，需要在键名前面加上$符号，比如文档中的name键，在管道操作中要指定它就得这样写$name。 并且我们所有的操作的文档都不是操作储存在硬盘中的数据，我们操作的文档都是储存在内存当中，所以不影响原始数据。
管道操作符 $match $match应尽量放在聚合的最前面，因为$match使用的是Mongodb的标准查询，所以可以使用索引来提高我们的效率，其次是可以过滤掉不需要的文档，让后续的操作更加效率。 既然是标准的查询我们就可以使用标准查询里面所有操作符。 下面来大概演示一下$match的操作方法： 实例的文档结构如下:
{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 } { &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 } { &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 } { &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 查询author键的值为dave的文档："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://wuyizhou.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Mongodb 聚合",
      "item": "https://wuyizhou.com/posts/mongodb-aggregate/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mongodb 聚合",
  "name": "Mongodb 聚合",
  "description": "参考 MongoDB权威指南(第2版)\nMongodb Docs\n前言 Mongodb提供了一个强大的处理框架，可以对集合中的文档进行各种组合、过滤、输出，如果你通过Mongodb其他的查询方法无法处理你的查询或者查询难度很高，那么你可以试试聚合。\n这里我们只讲解一下常用的聚合管道操作符，其他的可以自行到官方文档进行查询。\n语法 官方文档的聚合语法是这样的：\ndb.collection.aggregate（pipeline，options); 聚合：计算集合或视图中数据的聚合值，并且聚合接受一个数组，数组的每一个成员都是对象，对象里面子键都代表一个管道操作，按照顺序的从第一个管道操作到最后一个，每次操作完的文档返回给下一个管道操作。\npipeline： 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算，在版本2.6中更改：该方法仍然可以将流水线阶段接受为单独的参数，而不是数组中的元素; 但是，如果不指定pipeline为数组，则不能指定 options参数。\noptions:可选的。aggregate()传递给aggregate命令的附加选项。版本2.6中的新功能，仅当您指定pipeline为数组时可用。\n大概我们可以把聚合理解为对文档进行一系列的操作从而达到我们需要的查询文档，聚合提供了很多管道操作符，这些管道操作符就像一根一根的管道一些，而我们通过聚合操作的文档就像管道里面的水，这根管道流下来的水继续流到下一根管道，直到没有了管道，水就流出来了。 我将在下面讲解几个常用的管道操作符，你也可以单独使用其中任意的管道操作符，分别为：\nmatch(过滤): 过滤文档流，只允许匹配的文档未修改地传递到下一个流水线阶段。$match 使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零个文档（不匹配）。\n$project(映射)：重新整理流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。\n$group(分组)：通过一些指定的累加器将组文档输出到下一阶段，为每个不同的分组输出文档。\n$unwind(拆分)：从输入文档中解构一个数组字段，以输出每个元素的文档。每个输出文档用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组可以为零。\n$sort(排序)：按指定的排序键重新排序文档流。\n$limit(限制)：将前n个文档传递到管道，n是一个数字。\n$skip(跳过)：将前n个文档丢弃，后面的部分传递到管道。\n上面的顺序一般是我们常用的顺序，首先我们筛选一部分文档，然后从筛选中整理一份更加便于我们操作的文档，然后在对整理好的文档通过一些表达式来分组整理，然后通过排序、限制、跳过，得到我们最终的结果。 在管道操作符中如果需要指定文档中的某个键的时候，需要在键名前面加上$符号，比如文档中的name键，在管道操作中要指定它就得这样写$name。 并且我们所有的操作的文档都不是操作储存在硬盘中的数据，我们操作的文档都是储存在内存当中，所以不影响原始数据。\n管道操作符 $match $match应尽量放在聚合的最前面，因为$match使用的是Mongodb的标准查询，所以可以使用索引来提高我们的效率，其次是可以过滤掉不需要的文档，让后续的操作更加效率。 既然是标准的查询我们就可以使用标准查询里面所有操作符。 下面来大概演示一下$match的操作方法： 实例的文档结构如下:\n{ \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;512bc95fe835e68f199c8686\u0026#34;), \u0026#34;author\u0026#34; : \u0026#34;dave\u0026#34;, \u0026#34;score\u0026#34; : 80, \u0026#34;views\u0026#34; : 100 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;512bc962e835e68f199c8687\u0026#34;), \u0026#34;author\u0026#34; : \u0026#34;dave\u0026#34;, \u0026#34;score\u0026#34; : 85, \u0026#34;views\u0026#34; : 521 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;55f5a192d4bede9ac365b257\u0026#34;), \u0026#34;author\u0026#34; : \u0026#34;ahn\u0026#34;, \u0026#34;score\u0026#34; : 60, \u0026#34;views\u0026#34; : 1000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;55f5a192d4bede9ac365b258\u0026#34;), \u0026#34;author\u0026#34; : \u0026#34;li\u0026#34;, \u0026#34;score\u0026#34; : 55, \u0026#34;views\u0026#34; : 5000 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;55f5a1d3d4bede9ac365b259\u0026#34;), \u0026#34;author\u0026#34; : \u0026#34;annT\u0026#34;, \u0026#34;score\u0026#34; : 60, \u0026#34;views\u0026#34; : 50 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;55f5a1d3d4bede9ac365b25a\u0026#34;), \u0026#34;author\u0026#34; : \u0026#34;li\u0026#34;, \u0026#34;score\u0026#34; : 94, \u0026#34;views\u0026#34; : 999 } { \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;55f5a1d3d4bede9ac365b25b\u0026#34;), \u0026#34;author\u0026#34; : \u0026#34;ty\u0026#34;, \u0026#34;score\u0026#34; : 95, \u0026#34;views\u0026#34; : 1000 } 查询author键的值为dave的文档：",
  "keywords": [
    "服务和运维"
  ],
  "articleBody": "参考 MongoDB权威指南(第2版)\nMongodb Docs\n前言 Mongodb提供了一个强大的处理框架，可以对集合中的文档进行各种组合、过滤、输出，如果你通过Mongodb其他的查询方法无法处理你的查询或者查询难度很高，那么你可以试试聚合。\n这里我们只讲解一下常用的聚合管道操作符，其他的可以自行到官方文档进行查询。\n语法 官方文档的聚合语法是这样的：\ndb.collection.aggregate（pipeline，options); 聚合：计算集合或视图中数据的聚合值，并且聚合接受一个数组，数组的每一个成员都是对象，对象里面子键都代表一个管道操作，按照顺序的从第一个管道操作到最后一个，每次操作完的文档返回给下一个管道操作。\npipeline： 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算，在版本2.6中更改：该方法仍然可以将流水线阶段接受为单独的参数，而不是数组中的元素; 但是，如果不指定pipeline为数组，则不能指定 options参数。\noptions:可选的。aggregate()传递给aggregate命令的附加选项。版本2.6中的新功能，仅当您指定pipeline为数组时可用。\n大概我们可以把聚合理解为对文档进行一系列的操作从而达到我们需要的查询文档，聚合提供了很多管道操作符，这些管道操作符就像一根一根的管道一些，而我们通过聚合操作的文档就像管道里面的水，这根管道流下来的水继续流到下一根管道，直到没有了管道，水就流出来了。 我将在下面讲解几个常用的管道操作符，你也可以单独使用其中任意的管道操作符，分别为：\nmatch(过滤): 过滤文档流，只允许匹配的文档未修改地传递到下一个流水线阶段。$match 使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零个文档（不匹配）。\n$project(映射)：重新整理流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。\n$group(分组)：通过一些指定的累加器将组文档输出到下一阶段，为每个不同的分组输出文档。\n$unwind(拆分)：从输入文档中解构一个数组字段，以输出每个元素的文档。每个输出文档用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组可以为零。\n$sort(排序)：按指定的排序键重新排序文档流。\n$limit(限制)：将前n个文档传递到管道，n是一个数字。\n$skip(跳过)：将前n个文档丢弃，后面的部分传递到管道。\n上面的顺序一般是我们常用的顺序，首先我们筛选一部分文档，然后从筛选中整理一份更加便于我们操作的文档，然后在对整理好的文档通过一些表达式来分组整理，然后通过排序、限制、跳过，得到我们最终的结果。 在管道操作符中如果需要指定文档中的某个键的时候，需要在键名前面加上$符号，比如文档中的name键，在管道操作中要指定它就得这样写$name。 并且我们所有的操作的文档都不是操作储存在硬盘中的数据，我们操作的文档都是储存在内存当中，所以不影响原始数据。\n管道操作符 $match $match应尽量放在聚合的最前面，因为$match使用的是Mongodb的标准查询，所以可以使用索引来提高我们的效率，其次是可以过滤掉不需要的文档，让后续的操作更加效率。 既然是标准的查询我们就可以使用标准查询里面所有操作符。 下面来大概演示一下$match的操作方法： 实例的文档结构如下:\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"author\" : \"li\", \"score\" : 55, \"views\" : 5000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"author\" : \"annT\", \"score\" : 60, \"views\" : 50 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } 查询author键的值为dave的文档：\ndb.blog.aggregate([ { $match: { author: 'dave' } } ]); 返回的文档为：\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } $project 映射管道操作就如最开始介绍的，整理文档便于我们后面更好的操作，它可以重新命名键，还可以去除不需要的键。 实例的文档结构如下:\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"author\" : \"li\", \"score\" : 55, \"views\" : 5000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"author\" : \"annT\", \"score\" : 60, \"views\" : 50 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } 重新命名author为name，这里需要注意的是重新命名键需要给文档中原始的键名前面加上一个$符号，并只输出name和score： 代码：\ndb.blog.aggregate([ { $project: { name: '$author', score: 1, } } ]); 返回的文档内容（Mongodb中所有的文档是默认返回_id，除非显示的声明它不需要返回）：\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"score\" : 80, \"name\" : \"dave\" } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"score\" : 85, \"name\" : \"dave\" } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"score\" : 60, \"name\" : \"ahn\" } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"score\" : 55, \"name\" : \"li\" } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"score\" : 60, \"name\" : \"annT\" } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"score\" : 94, \"name\" : \"li\" } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"score\" : 95, \"name\" : \"ty\" } $project管道操作符同样支持Mongodb规定的表达式，大家有兴趣可以去看看。 通过表达式我们能更好的操作文档，比如下面，我想给下面的文档中author键为dave的文档中的score加上10分，那么需要用到表达式中的$add操作符，可以像下面这样来操作： 实例的文档结构如下:\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"author\" : \"li\", \"score\" : 55, \"views\" : 5000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"author\" : \"annT\", \"score\" : 60, \"views\" : 50 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } 执行的代码：\ndb.blog.aggregate([ { $match: { author: 'dave' } }, { $project: { score: { $add: ['$score', 10] }, author: 1, _id: 0 } } ]); 返回的文档内容：\n{ \"author\" : \"dave\", \"score\" : 90 } { \"author\" : \"dave\", \"score\" : 95 } $group 分组的作用是将文档中键的值，分成不同的组，然后通过累加器操作，然后输出文档，在进行$group管道操作中，_id键是必须存在的。 比如下面我需要将文档中author键的值相同的文档作一个统计： 实例的文档结构如下:\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"author\" : \"li\", \"score\" : 55, \"views\" : 5000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"author\" : \"annT\", \"score\" : 60, \"views\" : 50 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } 执行的代码：\ndb.blog.aggregate([ { $group: { _id: '$author', total: { $sum: 1 } } } ]); 返回的文档内容：\n{ \"_id\" : \"ty\", \"total\" : 1 } { \"_id\" : \"annT\", \"total\" : 1 } { \"_id\" : \"li\", \"total\" : 2 } { \"_id\" : \"ahn\", \"total\" : 1 } { \"_id\" : \"dave\", \"total\" : 2 } $unwind $unwind管道操作符可以将数组中的每个成员拆分为一个单独的文档，并输出给下一个管道操作。 比如下面的文档中a键包含了3个数组，使用$unwind管道操作符将成员拆分为单独的文档并输出。 实例的文档结构如下:\n{ a: [ { b: 1 }, { b: 2 }, { b: 3 } ] } 执行的代码：\ndb.blog.aggregate([ { $unwind: '$a' } ]); 返回的文档内容：\n{ \"_id\" : ObjectId(\"598c5807841dccce335a0e98\"), \"a\" : { \"b\" : 1 } } { \"_id\" : ObjectId(\"598c5807841dccce335a0e98\"), \"a\" : { \"b\" : 2 } } { \"_id\" : ObjectId(\"598c5807841dccce335a0e98\"), \"a\" : { \"b\" : 3 } } $sort 排序是将上一个管道操作符输入进来的文档进行排序，它指定排序的键然后值为升序1和降序-1。 比如需要对下面的文档中的score键的值进行降序排序： 实例的文档结构如下:\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"author\" : \"li\", \"score\" : 55, \"views\" : 5000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"author\" : \"annT\", \"score\" : 60, \"views\" : 50 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } 执行的代码：\ndb.blog.aggregate([ { $sort: { score: -1 } } ]); 返回的文档：\n{ \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"author\" : \"annT\", \"score\" : 60, \"views\" : 50 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"author\" : \"li\", \"score\" : 55, \"views\" : 5000 } $limit $limint管道操作符接受一个数字，将前n个文档输出。 比如下面输出下面文档的前3个文档：\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"author\" : \"li\", \"score\" : 55, \"views\" : 5000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"author\" : \"annT\", \"score\" : 60, \"views\" : 50 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } 执行的代码：\ndb.blog.aggregate([ { $limit: 3 } ]); 返回的文档内容：\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } $skip $limint管道操作符接受一个数字，将前n个文档后的文档输出到下一个管道。 比如下面输出下面文档的后2个文档：\n{ \"_id\" : ObjectId(\"512bc95fe835e68f199c8686\"), \"author\" : \"dave\", \"score\" : 80, \"views\" : 100 } { \"_id\" : ObjectId(\"512bc962e835e68f199c8687\"), \"author\" : \"dave\", \"score\" : 85, \"views\" : 521 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b257\"), \"author\" : \"ahn\", \"score\" : 60, \"views\" : 1000 } { \"_id\" : ObjectId(\"55f5a192d4bede9ac365b258\"), \"author\" : \"li\", \"score\" : 55, \"views\" : 5000 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b259\"), \"author\" : \"annT\", \"score\" : 60, \"views\" : 50 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } 执行的代码：\ndb.blog.aggregate([ { $skip: 5 } ]); 返回的文档内容：\n{ \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25a\"), \"author\" : \"li\", \"score\" : 94, \"views\" : 999 } { \"_id\" : ObjectId(\"55f5a1d3d4bede9ac365b25b\"), \"author\" : \"ty\", \"score\" : 95, \"views\" : 1000 } 其他 Mongodb不允许单一聚合操作符占用超过20%的内存，如果超过了就会直接抛出错误，并且尽可能的让$match管道操作符在前面，因为它可以使用索引，然后通过$project、$group尽可能的过滤掉不需要的数据。\n",
  "wordCount" : "1233",
  "inLanguage": "en",
  "datePublished": "2017-08-10T14:18:52Z",
  "dateModified": "2017-08-10T14:18:52Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://wuyizhou.com/posts/mongodb-aggregate/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Yizhou",
    "logo": {
      "@type": "ImageObject",
      "url": "https://wuyizhou.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wuyizhou.com" accesskey="h" title="Yizhou (Alt + H)">Yizhou</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wuyizhou.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Mongodb 聚合
    </h1>
    <div class="post-meta"><span title='2017-08-10 14:18:52 +0000 UTC'>August 10, 2017</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a></li>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#%e8%af%ad%e6%b3%95" aria-label="语法">语法</a></li>
                <li>
                    <a href="#%e7%ae%a1%e9%81%93%e6%93%8d%e4%bd%9c%e7%ac%a6" aria-label="管道操作符">管道操作符</a><ul>
                        
                <li>
                    <a href="#match" aria-label="$match">$match</a></li>
                <li>
                    <a href="#project" aria-label="$project">$project</a></li>
                <li>
                    <a href="#group" aria-label="$group">$group</a></li>
                <li>
                    <a href="#unwind" aria-label="$unwind">$unwind</a></li>
                <li>
                    <a href="#sort" aria-label="$sort">$sort</a></li>
                <li>
                    <a href="#limit" aria-label="$limit">$limit</a></li>
                <li>
                    <a href="#skip" aria-label="$skip">$skip</a></li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00HLX035Q/ref=sr_1_1?ie=UTF8&amp;qid=1501597098&amp;sr=8-1&amp;keywords=mongodb">MongoDB权威指南(第2版)</a></p>
<p><a href="https://docs.mongodb.com/manual/">Mongodb Docs</a></p>
<h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>Mongodb提供了一个强大的处理框架，可以对集合中的文档进行各种组合、过滤、输出，如果你通过Mongodb其他的查询方法无法处理你的查询或者查询难度很高，那么你可以试试聚合。</p>
<p>这里我们只讲解一下常用的聚合管道操作符，其他的可以自行到<a href="https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/#db.collection.aggregate">官方文档</a>进行查询。</p>
<h2 id="语法">语法<a hidden class="anchor" aria-hidden="true" href="#语法">#</a></h2>
<p>官方文档的聚合语法是这样的：</p>
<pre tabindex="0"><code>db.collection.aggregate（pipeline，options); 
</code></pre><p>聚合：计算集合或视图中数据的聚合值，并且聚合接受一个数组，数组的每一个成员都是对象，对象里面子键都代表一个管道操作，按照顺序的从第一个管道操作到最后一个，每次操作完的文档返回给下一个管道操作。</p>
<ul>
<li>
<p>pipeline： 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算，在版本2.6中更改：该方法仍然可以将流水线阶段接受为单独的参数，而不是数组中的元素; 但是，如果不指定pipeline为数组，则不能指定 options参数。</p>
</li>
<li>
<p>options:可选的。aggregate()传递给aggregate命令的附加选项。版本2.6中的新功能，仅当您指定pipeline为数组时可用。</p>
</li>
</ul>
<p>大概我们可以把聚合理解为对文档进行一系列的操作从而达到我们需要的查询文档，聚合提供了很多管道操作符，这些管道操作符就像一根一根的管道一些，而我们通过聚合操作的文档就像管道里面的水，这根管道流下来的水继续流到下一根管道，直到没有了管道，水就流出来了。 我将在下面讲解几个常用的管道操作符，你也可以单独使用其中任意的管道操作符，分别为：</p>
<ul>
<li>
<p><code>match(过滤)</code>: 过滤文档流，只允许匹配的文档未修改地传递到下一个流水线阶段。$match 使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零个文档（不匹配）。</p>
</li>
<li>
<p><code>$project(映射)</code>：重新整理流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。</p>
</li>
<li>
<p><code>$group(分组)</code>：通过一些指定的<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#pipe._S_group">累加器</a>将组文档输出到下一阶段，为每个不同的分组输出文档。</p>
</li>
<li>
<p><code>$unwind(拆分)</code>：从输入文档中解构一个数组字段，以输出每个元素的文档。每个输出文档用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组可以为零。</p>
</li>
<li>
<p><code>$sort(排序)</code>：按指定的排序键重新排序文档流。</p>
</li>
<li>
<p><code>$limit(限制)</code>：将前n个文档传递到管道，n是一个数字。</p>
</li>
<li>
<p><code>$skip(跳过)</code>：将前n个文档丢弃，后面的部分传递到管道。</p>
</li>
</ul>
<p>上面的顺序一般是我们常用的顺序，首先我们筛选一部分文档，然后从筛选中整理一份更加便于我们操作的文档，然后在对整理好的文档通过一些表达式来分组整理，然后通过排序、限制、跳过，得到我们最终的结果。 在管道操作符中如果需要指定文档中的某个键的时候，需要在键名前面加上<code>$</code>符号，比如文档中的<code>name</code>键，在管道操作中要指定它就得这样写<code>$name</code>。 并且我们所有的操作的文档都不是操作储存在硬盘中的数据，我们操作的文档都是储存在内存当中，所以不影响原始数据。</p>
<h2 id="管道操作符">管道操作符<a hidden class="anchor" aria-hidden="true" href="#管道操作符">#</a></h2>
<h3 id="match">$match<a hidden class="anchor" aria-hidden="true" href="#match">#</a></h3>
<p><code>$match</code>应尽量放在聚合的最前面，因为<code>$match</code>使用的是Mongodb的标准查询，所以可以使用索引来提高我们的效率，其次是可以过滤掉不需要的文档，让后续的操作更加效率。 既然是标准的查询我们就可以使用标准查询里面所有<a href="http://xsscript.com/2017/08/04/mongodb-find/">操作符</a>。 下面来大概演示一下<code>$match</code>的操作方法： 实例的文档结构如下:</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 
</code></pre><p>查询<code>author</code>键的值为<code>dave</code>的文档：</p>
<pre tabindex="0"><code>db.blog.aggregate([
  {
    $match: {
      author: &#39;dave&#39;
    }
  }
]); 
</code></pre><p>返回的文档为：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 } 
</code></pre><h3 id="project">$project<a hidden class="anchor" aria-hidden="true" href="#project">#</a></h3>
<p>映射管道操作就如最开始介绍的，整理文档便于我们后面更好的操作，它可以重新命名键，还可以去除不需要的键。 实例的文档结构如下:</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 
</code></pre><p>重新命名<code>author</code>为<code>name</code>，这里需要注意的是重新命名键需要给文档中原始的键名前面加上一个<code>$</code>符号，并只输出<code>name</code>和<code>score</code>： 代码：</p>
<pre tabindex="0"><code>db.blog.aggregate([
    {
        $project: {
            name: &#39;$author&#39;,
            score: 1,

        }
    }
]); 
</code></pre><p>返回的文档内容（Mongodb中所有的文档是默认返回<code>_id</code>，除非显示的声明它不需要返回）：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;score&#34; : 80, &#34;name&#34; : &#34;dave&#34; }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;score&#34; : 85, &#34;name&#34; : &#34;dave&#34; }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;score&#34; : 60, &#34;name&#34; : &#34;ahn&#34; }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;score&#34; : 55, &#34;name&#34; : &#34;li&#34; }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;score&#34; : 60, &#34;name&#34; : &#34;annT&#34; }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;score&#34; : 94, &#34;name&#34; : &#34;li&#34; }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;score&#34; : 95, &#34;name&#34; : &#34;ty&#34; } 
</code></pre><p><code>$project</code>管道操作符同样支持Mongodb规定的<a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#aggregation-expressions">表达式</a>，大家有兴趣可以去看看。 通过表达式我们能更好的操作文档，比如下面，我想给下面的文档中<code>author</code>键为<code>dave</code>的文档中的<code>score</code>加上<code>10</code>分，那么需要用到表达式中的<code>$add</code>操作符，可以像下面这样来操作： 实例的文档结构如下:</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 
</code></pre><p>执行的代码：</p>
<pre tabindex="0"><code>db.blog.aggregate([
    {
        $match: {
            author: &#39;dave&#39;
        }
    },
    {
        $project: {
            score: {
                $add: [&#39;$score&#39;, 10]
            },
            author: 1,
            _id: 0
        }
    }

]); 
</code></pre><p>返回的文档内容：</p>
<pre tabindex="0"><code>{ &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 90 }
{ &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 95 } 
</code></pre><h3 id="group">$group<a hidden class="anchor" aria-hidden="true" href="#group">#</a></h3>
<p>分组的作用是将文档中键的值，分成不同的组，然后通过<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#pipe._S_group">累加器</a>操作，然后输出文档，在进行<code>$group</code>管道操作中，<code>_id</code>键是必须存在的。 比如下面我需要将文档中<code>author</code>键的值相同的文档作一个统计： 实例的文档结构如下:</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 
</code></pre><p>执行的代码：</p>
<pre tabindex="0"><code>db.blog.aggregate([
  {
    $group: {
      _id: &#39;$author&#39;,
      total: {
        $sum: 1
      }
    }
  }
]); 
</code></pre><p>返回的文档内容：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : &#34;ty&#34;, &#34;total&#34; : 1 }
{ &#34;_id&#34; : &#34;annT&#34;, &#34;total&#34; : 1 }
{ &#34;_id&#34; : &#34;li&#34;, &#34;total&#34; : 2 }
{ &#34;_id&#34; : &#34;ahn&#34;, &#34;total&#34; : 1 }
{ &#34;_id&#34; : &#34;dave&#34;, &#34;total&#34; : 2 } 
</code></pre><h3 id="unwind">$unwind<a hidden class="anchor" aria-hidden="true" href="#unwind">#</a></h3>
<p><code>$unwind</code>管道操作符可以将数组中的每个成员拆分为一个单独的文档，并输出给下一个管道操作。 比如下面的文档中<code>a</code>键包含了3个数组，使用<code>$unwind</code>管道操作符将成员拆分为单独的文档并输出。 实例的文档结构如下:</p>
<pre tabindex="0"><code>{
    a: [
        {
            b: 1
        },
        {
            b: 2
        },
        {
            b: 3
        }
    ]
} 
</code></pre><p>执行的代码：</p>
<pre tabindex="0"><code>db.blog.aggregate([
    {
        $unwind: &#39;$a&#39;
    }
]); 
</code></pre><p>返回的文档内容：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;598c5807841dccce335a0e98&#34;), &#34;a&#34; : { &#34;b&#34; : 1 } }
{ &#34;_id&#34; : ObjectId(&#34;598c5807841dccce335a0e98&#34;), &#34;a&#34; : { &#34;b&#34; : 2 } }
{ &#34;_id&#34; : ObjectId(&#34;598c5807841dccce335a0e98&#34;), &#34;a&#34; : { &#34;b&#34; : 3 } } 
</code></pre><h3 id="sort">$sort<a hidden class="anchor" aria-hidden="true" href="#sort">#</a></h3>
<p>排序是将上一个管道操作符输入进来的文档进行排序，它指定排序的键然后值为升序<code>1</code>和降序<code>-1</code>。 比如需要对下面的文档中的<code>score</code>键的值进行降序排序： 实例的文档结构如下:</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 
</code></pre><p>执行的代码：</p>
<pre tabindex="0"><code>db.blog.aggregate([
    {
        $sort: {
            score: -1
        }
    }
]); 
</code></pre><p>返回的文档：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 } 
</code></pre><h3 id="limit">$limit<a hidden class="anchor" aria-hidden="true" href="#limit">#</a></h3>
<p><code>$limint</code>管道操作符接受一个数字，将前n个文档输出。 比如下面输出下面文档的前3个文档：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 
</code></pre><p>执行的代码：</p>
<pre tabindex="0"><code>db.blog.aggregate([
    {
        $limit: 3
    }
]); 
</code></pre><p>返回的文档内容：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 } 
</code></pre><h3 id="skip">$skip<a hidden class="anchor" aria-hidden="true" href="#skip">#</a></h3>
<p><code>$limint</code>管道操作符接受一个数字，将前n个文档后的文档输出到下一个管道。 比如下面输出下面文档的后2个文档：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 }
{ &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 
</code></pre><p>执行的代码：</p>
<pre tabindex="0"><code>db.blog.aggregate([
    {
        $skip: 5
    }
]); 
</code></pre><p>返回的文档内容：</p>
<pre tabindex="0"><code>{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 }
{ &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 
</code></pre><h3 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h3>
<p>Mongodb不允许单一聚合操作符占用超过20%的内存，如果超过了就会直接抛出错误，并且尽可能的让<code>$match</code>管道操作符在前面，因为它可以使用索引，然后通过<code>$project</code>、<code>$group</code>尽可能的过滤掉不需要的数据。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://wuyizhou.com/tags/%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%BF%90%E7%BB%B4/">服务和运维</a></li>
    </ul>
  </footer><script src="https://giscus.app/client.js"
        data-repo="wyizhou/YizhouWebsite"
        data-repo-id="R_kgDOK59ReQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOK59Rec4CcNSZ"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://wuyizhou.com">Yizhou</a></span>
    <span>
        <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
    </span>
    <span>
        Build: 2024-01-21 12:28:56
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
