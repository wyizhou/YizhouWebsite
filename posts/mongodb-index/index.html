<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Mongodb索引 | Yizhou&#39;s Website</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="参考 🔗MongoDB权威指南(第2版) Mongodb Docs 前言 🔗建立索引对于任何需要提高查询速度的数据库来说都非常重要，那么索引究竟是一个什么？首先来看看下">
<meta name="generator" content="Hugo 0.121.1">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  





    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          "HTML-CSS": { scale: 85 },
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true
          }
        });
    </script>
    
    <script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>





  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	<a href="/posts">归档</a>
	<a href="/tags">标签</a>
	<a href="/about">关于</a>

	

	
	  <a class="button" href="https://wuyizhou.com/index.xml">订阅</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">Mongodb索引</h1>

    <div class="tip">
        <time datetime="2017-08-08 12:28:45 &#43;0000 UTC">2017年08月08日</time>
        <span class="split">
          ·
        </span>
        <span>
          3708字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          8分钟
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#参考">参考</a></li>
        <li><a href="#前言">前言</a></li>
        <li><a href="#效率">效率</a></li>
        <li><a href="#建立索引">建立索引</a></li>
        <li><a href="#索引选项">索引选项</a></li>
        <li><a href="#使用索引">使用索引</a></li>
        <li><a href="#复合索引">复合索引</a></li>
        <li><a href="#对象索引">对象索引</a></li>
        <li><a href="#数组索引">数组索引</a></li>
        <li><a href="#获取索引">获取索引</a></li>
        <li><a href="#删除索引">删除索引</a></li>
        <li><a href="#注意事项">注意事项</a></li>
      </ul>
    </li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <h3 id="参考">参考 <a href="#%e5%8f%82%e8%80%83" class="anchor">🔗</a></h3><p><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00HLX035Q/ref=sr_1_1?ie=UTF8&amp;qid=1501597098&amp;sr=8-1&amp;keywords=mongodb" target="_blank" rel="noopener">MongoDB权威指南(第2版)</a></p>
<p><a href="https://docs.mongodb.com/manual/" target="_blank" rel="noopener">Mongodb Docs</a></p>
<h3 id="前言">前言 <a href="#%e5%89%8d%e8%a8%80" class="anchor">🔗</a></h3><p>建立索引对于任何需要提高查询速度的数据库来说都非常重要，那么索引究竟是一个什么？首先来看看下面是<a href="https://www.amazon.cn/dp/B01KGYHBEM/ref=cngwdyfloorv2_recs_0?pf_rd_p=05f2b7d6-37ec-49bf-8fcf-5d2fec23a061&amp;pf_rd_s=desktop-2&amp;pf_rd_t=36701&amp;pf_rd_i=desktop&amp;pf_rd_m=A1AJ19PSB66TGU&amp;pf_rd_r=16P2J6RAT3GC8PN1T4BJ&amp;pf_rd_r=16P2J6RAT3GC8PN1T4BJ&amp;pf_rd_p=05f2b7d6-37ec-49bf-8fcf-5d2fec23a061" target="_blank" rel="noopener">《区块链:技术驱动金融》</a>这本书的前两章的目录。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>第1章密码学及加密货币概述----------1
</span></span><span style="display:flex;"><span>1.1密码学哈希函数----------4
</span></span><span style="display:flex;"><span>1.2哈希指针及数据结构----------14
</span></span><span style="display:flex;"><span>1.3数字签名----------19
</span></span><span style="display:flex;"><span>1.4公钥即身份----------24
</span></span><span style="display:flex;"><span>1.5两种简单的加密货币----------26
</span></span><span style="display:flex;"><span>第2章比特币如何做到去中心化----------35
</span></span><span style="display:flex;"><span>2.1中心化与去中心化----------37
</span></span><span style="display:flex;"><span>2.2分布式共识----------39
</span></span><span style="display:flex;"><span>2.3使用区块链达成没有身份的共识----------44
</span></span><span style="display:flex;"><span>2.4奖励机制与工作量证明----------51
</span></span><span style="display:flex;"><span>2.5总结----------59 
</span></span></code></pre></div><p>通过目录，我们能很快很清楚的知道这本书写了什么，而我们也能很快从中查找到我们感兴趣的内容在哪一页，如果没有目录，我们将会一篇一篇的去翻阅我们想了解的内容，而索引可以比作数据库的目录。</p>
<h3 id="效率">效率 <a href="#%e6%95%88%e7%8e%87" class="anchor">🔗</a></h3><p><code>explain()</code>是官方提供的一个用于返回当前查询过程信息的一个方法，通过这个命令，我们可以知道查询的过程，以便于我们进行优化，<code>explain()</code>支持这些操作的过程查询：</p>
<ol>
<li>aggregate()</li>
<li>count()</li>
<li>distinct()</li>
<li>find()</li>
<li>group()</li>
<li>remove()</li>
<li>update()</li>
</ol>
<p><code>explain()</code>方法接受三种可选字符串作为参数和两种布尔值，官方是这样来介绍的：</p>
<blockquote>
<p>可选的。指定说明输出的详细程度模式。该模式会影响explain()返回信息的数量和行为。可能的模式有：&ldquo;queryPlanner&rdquo;， &ldquo;executionStats&rdquo;，和&quot;allPlansExecution&quot;。 默认模式是&quot;queryPlanner&quot;。 为了向后兼容早期版本 cursor.explain()，MongoDB解释true为 &ldquo;allPlansExecution&quot;和false &ldquo;queryPlanner&rdquo;。 aggregate()忽略verbosity参数并在queryPlanner模式下执行。</p>
</blockquote>
<p>首先我们插入<code>100000</code>条数据，可以通过下面代码来循环插入：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">var</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> <span style="color:#666">100000</span>; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>  db<span style="color:#666">.</span>test<span style="color:#666">.</span>insert({
</span></span><span style="display:flex;"><span>    id: i,
</span></span><span style="display:flex;"><span>    username: <span style="color:#b44">&#39;user&#39;</span> <span style="color:#666">+</span> i
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>然后我们通过<code>explain()</code>方法看看查询含有<code>username:user108</code>键值的文档过程：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.find({username: &#39;user108&#39;}).explain(true); 
</span></span></code></pre></div><p>返回的结果大概为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    &#34;queryPlanner&#34; : {
</span></span><span style="display:flex;"><span>        &#34;plannerVersion&#34; : 1,
</span></span><span style="display:flex;"><span>        &#34;namespace&#34; : &#34;blog.test&#34;,
</span></span><span style="display:flex;"><span>        &#34;indexFilterSet&#34; : false,
</span></span><span style="display:flex;"><span>        &#34;parsedQuery&#34; : {
</span></span><span style="display:flex;"><span>            &#34;username&#34; : {
</span></span><span style="display:flex;"><span>                &#34;$eq&#34; : &#34;user4&#34;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        &#34;winningPlan&#34; : {
</span></span><span style="display:flex;"><span>            &#34;stage&#34; : &#34;COLLSCAN&#34;,
</span></span><span style="display:flex;"><span>            &#34;filter&#34; : {
</span></span><span style="display:flex;"><span>                &#34;username&#34; : {
</span></span><span style="display:flex;"><span>                    &#34;$eq&#34; : &#34;user4&#34;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            &#34;direction&#34; : &#34;forward&#34;
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        &#34;rejectedPlans&#34; : [ ]
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    &#34;executionStats&#34; : {
</span></span><span style="display:flex;"><span>        &#34;executionSuccess&#34; : true,
</span></span><span style="display:flex;"><span>        &#34;nReturned&#34; : 1,
</span></span><span style="display:flex;"><span>        &#34;executionTimeMillis&#34; : 48,
</span></span><span style="display:flex;"><span>        &#34;totalKeysExamined&#34; : 0,
</span></span><span style="display:flex;"><span>        &#34;totalDocsExamined&#34; : 100000,
</span></span><span style="display:flex;"><span>        &#34;executionStages&#34; : {
</span></span><span style="display:flex;"><span>            &#34;stage&#34; : &#34;COLLSCAN&#34;,
</span></span><span style="display:flex;"><span>            &#34;filter&#34; : {
</span></span><span style="display:flex;"><span>                &#34;username&#34; : {
</span></span><span style="display:flex;"><span>                    &#34;$eq&#34; : &#34;user4&#34;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            &#34;nReturned&#34; : 1,
</span></span><span style="display:flex;"><span>            &#34;executionTimeMillisEstimate&#34; : 37,
</span></span><span style="display:flex;"><span>            &#34;works&#34; : 100002,
</span></span><span style="display:flex;"><span>            &#34;advanced&#34; : 1,
</span></span><span style="display:flex;"><span>            &#34;needTime&#34; : 100000,
</span></span><span style="display:flex;"><span>            &#34;needYield&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;saveState&#34; : 782,
</span></span><span style="display:flex;"><span>            &#34;restoreState&#34; : 782,
</span></span><span style="display:flex;"><span>            &#34;isEOF&#34; : 1,
</span></span><span style="display:flex;"><span>            &#34;invalidates&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;direction&#34; : &#34;forward&#34;,
</span></span><span style="display:flex;"><span>            &#34;docsExamined&#34; : 100000
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        &#34;allPlansExecution&#34; : [ ]
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    &#34;serverInfo&#34; : {
</span></span><span style="display:flex;"><span>        &#34;host&#34; : &#34;YizhoudeMacBook-Pro.local&#34;,
</span></span><span style="display:flex;"><span>        &#34;port&#34; : 27017,
</span></span><span style="display:flex;"><span>        &#34;version&#34; : &#34;3.4.6&#34;,
</span></span><span style="display:flex;"><span>        &#34;gitVersion&#34; : &#34;c55eb86ef46ee7aede3b1e2a5d184a7df4bfb5b5&#34;
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    &#34;ok&#34; : 1
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>在上面返回的过程中，我们只需要关注<code>executionStats</code>对象里面的值中的：</p>
<ul>
<li>totalDocsExamined: 文档扫描总数</li>
<li>executionTimeMillis: 执行时间(毫秒)</li>
<li>nReturned: 返回的文档数量</li>
</ul>
<p>一般通过这三个值就可以判断文档执行需不需要优化，比如上面返回的信息中表示这次查询文档扫描总数<code>100000</code>，执行时间<code>48</code>毫秒，返回的文档数量为<code>1</code>。</p>
<p>通过上面的返回信息其实我们可以看出，<code>find()</code>方法其实是扫描了整个集合来查询我们需要的，即使找到了我们需要的文档，但还会继续往下查询，因为<code>find()</code>方法是查询所有符合条件的文档，这里其实是浪费了服务器的资源。</p>
<p>我们已知<code>username</code>是唯一值，那么我们可以<code>findOne</code>,或者通过<code>limit(1)</code>来限制返回的数量，限制了返回的数量后，Mongodb内部查询是查询到符合的第一条文档就停止，比如我们要查询<code>user5</code>，那么查找的文档总数将是查询到第一条符合的文档数止到第一条文档的总和，这样看上去是没有问题了，但是一旦我们查询的是<code>user99995</code>，那么扫描的文档数量将是<code>99995</code>，这样的方式属于治标不治本。</p>
<h3 id="建立索引">建立索引 <a href="#%e5%bb%ba%e7%ab%8b%e7%b4%a2%e5%bc%95" class="anchor">🔗</a></h3><p>Mongodb建立索引是通过<code>createIndex()</code>方法建立，参数为一个对象，包含了需要建立索引的键：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.createIndex({username: 1}); 
</span></span></code></pre></div><p>建立的索引其实相当于保存在Mongodb内部的一个单独的文档，这个文档存放了所有<code>username</code>的值和对应储存的物理位置，大概结构为(下面数据是比喻，并不代表真实性)：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>username Index
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[&#39;user1&#39;, 0x00000001],
</span></span><span style="display:flex;"><span>[&#39;user2&#39;, 0x00000002],
</span></span><span style="display:flex;"><span>[&#39;user3&#39;, 0x00000003],
</span></span><span style="display:flex;"><span>[&#39;user4&#39;, 0x00000004],
</span></span><span style="display:flex;"><span>[&#39;user5&#39;, 0x00000005],
</span></span><span style="display:flex;"><span>........
</span></span><span style="display:flex;"><span>[&#39;user100000&#39;, 0x00100000] 
</span></span></code></pre></div><h3 id="索引选项">索引选项 <a href="#%e7%b4%a2%e5%bc%95%e9%80%89%e9%a1%b9" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.collection.createIndex(key，options); 
</span></span></code></pre></div><p>我们可以通过多个选项对索引的文档进行限制，其中很有用的一个就是<code>unique</code>，使用方法如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.createIndex({username: 1}，{unique: 1}); 
</span></span></code></pre></div><p>通过上面的设置<code>username</code>键的值在整个集合中必须是唯一的，如果你试图插入两个<code>username</code>键值相等的文档，那么将会报错，比如下面这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.createIndex({username: 1}，{unique: 1});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.insert({username: &#39;user200&#39;});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.insert({username: &#39;user200&#39;});
</span></span><span style="display:flex;"><span>----Error!! 
</span></span></code></pre></div><p>它同样适用于复合索引，在对复合索引使用唯一值选项后，如果你试图插入两个及以上索引键的值都一样的两个文档，那么将报错，如果是两个文档的其中一个值不一样同样可以插入，比如下面代码所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.createIndex({username: 1, age: 1}，{unique: 1});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.insert({username: &#39;user200&#39;, age:18});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.insert({username: &#39;user200&#39;, age:20}); 
</span></span></code></pre></div><p>以上两个方式都是可以正常插入的，因为插入的这两个文档中的<code>age</code>不一样，但是如果像下面这样就会报错了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.createIndex({username: 1, age: 1}，{unique: 1});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.insert({username: &#39;user200&#39;, age:18});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.insert({username: &#39;user200&#39;, age:18});
</span></span><span style="display:flex;"><span>----Error!! 
</span></span></code></pre></div><p>当然除了唯一值选项的设置之外，还有很多选项的设置，如果大家有兴趣可以到<a href="https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/" target="_blank" rel="noopener">官方文档</a>查看。</p>
<h3 id="使用索引">使用索引 <a href="#%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95" class="anchor">🔗</a></h3><p>建立了索引后，我们不需要特别的方式去查询，我们可以像普通的查询方式一样的去查询：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.find({username: &#39;user9999&#39;}); 
</span></span></code></pre></div><p>在查询的时候Mongodb会自动的查找我们是否为<code>username</code>键建立索引，如果有则扫描<code>username</code>的索引文档，找到相应的值后，然后在根据相应的物理地址去扫描对应的文档，如果没有则扫描<code>test</code>集合的所有文档。</p>
<p>建立了索引后，我们来看看查找<code>username: 'user9999'</code>键值对的文档需要的时间以及查询上的效率：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.find({username: &#39;user9999&#39;}).explain(true); 
</span></span></code></pre></div><p>返回的过程信息(只拿出<code>executionStats</code>属性)：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>&#34;executionStats&#34; : {
</span></span><span style="display:flex;"><span>        &#34;executionSuccess&#34; : true,
</span></span><span style="display:flex;"><span>        &#34;nReturned&#34; : 1,
</span></span><span style="display:flex;"><span>        &#34;executionTimeMillis&#34; : 0,
</span></span><span style="display:flex;"><span>        &#34;totalKeysExamined&#34; : 1,
</span></span><span style="display:flex;"><span>        &#34;totalDocsExamined&#34; : 1,
</span></span><span style="display:flex;"><span>        &#34;executionStages&#34; : {
</span></span><span style="display:flex;"><span>            &#34;stage&#34; : &#34;FETCH&#34;,
</span></span><span style="display:flex;"><span>            &#34;nReturned&#34; : 1,
</span></span><span style="display:flex;"><span>            &#34;executionTimeMillisEstimate&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;works&#34; : 2,
</span></span><span style="display:flex;"><span>            &#34;advanced&#34; : 1,
</span></span><span style="display:flex;"><span>            &#34;needTime&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;needYield&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;saveState&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;restoreState&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;isEOF&#34; : 1,
</span></span><span style="display:flex;"><span>            &#34;invalidates&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;docsExamined&#34; : 1,
</span></span><span style="display:flex;"><span>            &#34;alreadyHasObj&#34; : 0,
</span></span><span style="display:flex;"><span>            &#34;inputStage&#34; : {
</span></span><span style="display:flex;"><span>                &#34;stage&#34; : &#34;IXSCAN&#34;,
</span></span><span style="display:flex;"><span>                &#34;nReturned&#34; : 1,
</span></span><span style="display:flex;"><span>                &#34;executionTimeMillisEstimate&#34; : 0,
</span></span><span style="display:flex;"><span>                &#34;works&#34; : 2,
</span></span><span style="display:flex;"><span>                &#34;advanced&#34; : 1,
</span></span><span style="display:flex;"><span>                &#34;needTime&#34; : 0,
</span></span><span style="display:flex;"><span>                &#34;needYield&#34; : 0,
</span></span><span style="display:flex;"><span>                &#34;saveState&#34; : 0,
</span></span><span style="display:flex;"><span>                &#34;restoreState&#34; : 0,
</span></span><span style="display:flex;"><span>                &#34;isEOF&#34; : 1,
</span></span><span style="display:flex;"><span>                &#34;invalidates&#34; : 0,
</span></span><span style="display:flex;"><span>                &#34;keyPattern&#34; : {
</span></span><span style="display:flex;"><span>                    &#34;username&#34; : 1
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>                &#34;indexName&#34; : &#34;username_1&#34;,
</span></span><span style="display:flex;"><span>                &#34;isMultiKey&#34; : false,
</span></span><span style="display:flex;"><span>                &#34;multiKeyPaths&#34; : {
</span></span><span style="display:flex;"><span>                    &#34;username&#34; : [ ]
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>                &#34;isUnique&#34; : false,
</span></span><span style="display:flex;"><span>                &#34;isSparse&#34; : false,
</span></span><span style="display:flex;"><span>                &#34;isPartial&#34; : false,
</span></span><span style="display:flex;"><span>                &#34;indexVersion&#34; : 2,
</span></span><span style="display:flex;"><span>                &#34;direction&#34; : &#34;forward&#34;,
</span></span><span style="display:flex;"><span>                &#34;indexBounds&#34; : {
</span></span><span style="display:flex;"><span>                    &#34;username&#34; : [
</span></span><span style="display:flex;"><span>                        &#34;[&#34;user9999&#34;, &#34;user9999&#34;]&#34;
</span></span><span style="display:flex;"><span>                    ]
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>                &#34;keysExamined&#34; : 1,
</span></span><span style="display:flex;"><span>                &#34;seeks&#34; : 1,
</span></span><span style="display:flex;"><span>                &#34;dupsTested&#34; : 0,
</span></span><span style="display:flex;"><span>                &#34;dupsDropped&#34; : 0,
</span></span><span style="display:flex;"><span>                &#34;seenInvalidated&#34; : 0
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        &#34;allPlansExecution&#34; : [ ]
</span></span><span style="display:flex;"><span>    } 
</span></span></code></pre></div><p>通过上面的返回信息中，我们可以看到</p>
<ul>
<li>totalDocsExamined: 1 //扫描的文档数量为1</li>
<li>executionTimeMillis: 0 //执行的时间小于0毫秒</li>
<li>nReturned: 1 //返回的文档数为1</li>
</ul>
<h3 id="复合索引">复合索引 <a href="#%e5%a4%8d%e5%90%88%e7%b4%a2%e5%bc%95" class="anchor">🔗</a></h3><p>符合索引指的是一个索引文档中存在两个值及以上的值，比如下面这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.createIndex({username: 1, id: 1}); 
</span></span></code></pre></div><p>通过上面的语句可以创建符合索引，当我们每次查询这两个键的时候，都会从索引文档中查询，如果你经常会以两个键值对查询文档，那么符合索引非常适合你。</p>
<p>复合索引的第一个值可以单独查询，但是第二个值无法单独查询，什么意思呢，你可以理解成一个索引文档以第一个索引键命名，这样就很清楚了，当我们单独查询<code>username</code>的时候会找到这个索引文档,但是当我们单独查询<code>id</code>的时候无法找到这个索引文档。</p>
<p>那么根据上面的理论可以得出，只要第一个值匹配到索引文档，那么在复合索引中不管你跟的是复合索引中添加的哪个值都可以进行索引，比如下面的代码都可以进行复合索引：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.createIndex({username: 1, id: 1, age: 1, adreess: 1});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.find({username: &#39;user400&#39;});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.find({username: &#39;user400&#39;, age: 18});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db.test.find({username: &#39;user400&#39;, adreess: &#39;xxxx&#39;}); 
</span></span></code></pre></div><h3 id="对象索引">对象索引 <a href="#%e5%af%b9%e8%b1%a1%e7%b4%a2%e5%bc%95" class="anchor">🔗</a></h3><p>Mongodb可以支持对象索引，比如下面这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">var</span> a <span style="color:#666">=</span> {
</span></span><span style="display:flex;"><span>    b: <span style="color:#666">1</span>,
</span></span><span style="display:flex;"><span>    c: <span style="color:#666">2</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db<span style="color:#666">.</span>test<span style="color:#666">.</span>createIndex({a: <span style="color:#666">1</span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="">或者对某个子键索引</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db<span style="color:#666">.</span>test<span style="color:#666">.</span>createIndex({a<span style="color:#666">.</span>b: <span style="color:#666">1</span>}); 
</span></span></code></pre></div><p>需要注意的是上面两种方法的索引效果截然不同，第一个建立索引是建立一个对象索引,对象中的所有值都会提高查询效率。而第二个建立的索引是建立一个子键索引，只对子键提高查询效率。</p>
<h3 id="数组索引">数组索引 <a href="#%e6%95%b0%e7%bb%84%e7%b4%a2%e5%bc%95" class="anchor">🔗</a></h3><p>Mongodb支持对数组索引，比如像下面这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">var</span> a <span style="color:#666">=</span> [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        b: <span style="color:#666">1</span>,
</span></span><span style="display:flex;"><span>        c: <span style="color:#666">2</span>
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        b: <span style="color:#666">3</span>,
</span></span><span style="display:flex;"><span>        c: <span style="color:#666">4</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db<span style="color:#666">.</span>test<span style="color:#666">.</span>createIndex({a: <span style="color:#666">1</span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="">或者对某个子键索引</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>db<span style="color:#666">.</span>test<span style="color:#666">.</span>createIndex({a<span style="color:#666">.</span>b: <span style="color:#666">1</span>}); 
</span></span></code></pre></div><p>上面两种方式也是不同的，第一种是建立一个数组索引，并且Mongodb会对数组的每一个成员建立索引，这于对象是不一样的。而第二种是建立一个数组子成员的子键索引。</p>
<p>Mongodb只允许复合索引中出现一个数组，如果出现了一个以上的数组将是非法的，应当尽可能的不去使用整个数组索引。</p>
<h3 id="获取索引">获取索引 <a href="#%e8%8e%b7%e5%8f%96%e7%b4%a2%e5%bc%95" class="anchor">🔗</a></h3><p>我们可以通过<code>getIndexes()</code>方法来获取当前集合所建立的所有索引信息，默认会返回一个<code>_id</code>索引，这个索引是Mongodb自动建立的。</p>
<p><code>getIndexes()</code>使用方法：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.getIndexes(); 
</span></span></code></pre></div><p>返回的大概信息:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>[
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        &#34;v&#34; : 2,
</span></span><span style="display:flex;"><span>        &#34;key&#34; : {
</span></span><span style="display:flex;"><span>            &#34;_id&#34; : 1
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        &#34;name&#34; : &#34;_id_&#34;,
</span></span><span style="display:flex;"><span>        &#34;ns&#34; : &#34;blog.test&#34;
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        &#34;v&#34; : 2,
</span></span><span style="display:flex;"><span>        &#34;key&#34; : {
</span></span><span style="display:flex;"><span>            &#34;username&#34; : 1
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        &#34;name&#34; : &#34;username_1&#34;,
</span></span><span style="display:flex;"><span>        &#34;ns&#34; : &#34;blog.test&#34;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>] 
</span></span></code></pre></div><p>返回的信息当中，各个键值表示的是：</p>
<ul>
<li>v：表示索引版本</li>
<li>key: 表示索引的键，值为表示正序倒序 1 或者 -1</li>
<li>name: 索引的标识符</li>
<li>ns: 作用于的集合</li>
</ul>
<h3 id="删除索引">删除索引 <a href="#%e5%88%a0%e9%99%a4%e7%b4%a2%e5%bc%95" class="anchor">🔗</a></h3><p>Mongodb提供了<code>dropIndex()</code>来删除索引，它接受一个字符串参数，这个参数是索引的<code>name</code>值。删除索引可以根据<code>getIndexes()</code>方法查询到的<code>name</code>的值来删除，比如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>db.test.dropIndex(&#39;username_1&#39;); 
</span></span></code></pre></div><h3 id="注意事项">注意事项 <a href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" class="anchor">🔗</a></h3><p>索引建立后，每次添加、修改、更新、删除数据，Mongodb都会更新索引文档，这也带来了一个问题，就是每当我们操作数据的时候，会比以前慢一点，因为操作数据的同时，Mongodb还会自动更新索引文档，为了不影响效率，一个集合最多只能存在64个索引</p>

    </div>

    
        <div class="tags">
            
                <a href="https://wuyizhou.com/tags/%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%BF%90%E7%BB%B4">服务和运维</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/wyizhou" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://stackoverflow.com/users/11949960" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>stackoverflow</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-488.000000, -1163.000000)">
            <g id="stackoverflow" transform="translate(488.000000, 1163.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M42.0860128,53.5922927 L22.9745951,53.6011499 L22.9729497,49.5538824 L42.0835447,49.5440929 L42.0860128,53.5922927 L42.0860128,53.5922927 Z M55,30.6708298 L51.7306912,12 L47.7087256,12.6920259 L50.9775643,31.3628557 L55,30.6708298 L55,30.6708298 Z M42.5455518,44.3547147 L23.5156994,42.616026 L23.1410164,46.6470941 L42.1712214,48.3841513 L42.5455518,44.3547147 L42.5455518,44.3547147 Z M43.8009984,39.0731519 L25.3459811,34.1539179 L24.285633,38.0621508 L42.7419431,42.9819676 L43.8009984,39.0731519 L43.8009984,39.0731519 Z M46.2103463,34.4436411 L29.7494464,24.8164635 L27.6748215,28.3015328 L44.1365441,37.9292931 L46.2103463,34.4436411 L46.2103463,34.4436411 Z M50.2466504,31.6088756 L46.8745036,33.8883189 L36.106599,18.2318456 L39.4792159,15.9517031 L50.2466504,31.6088756 Z M45.3315807,40.2784283 L48.5799693,40.2784283 L48.5799693,60 L17,60 L17,40.2784283 L20.2648427,40.2784283 L20.2648427,56.8243495 L45.3315807,56.8243495 L45.3315807,40.2784283 Z" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://twitter.com/5yizhou" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"
	 xml:space="preserve">
<g>
	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123
		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126
		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225
		C438.532,59.576,430.49,40.204,414.41,24.123z M335.471,168.735c0.191,1.713,0.288,4.278,0.288,7.71
		c0,15.989-2.334,32.025-6.995,48.104c-4.661,16.087-11.8,31.504-21.416,46.254c-9.606,14.749-21.074,27.791-34.396,39.115
		c-13.325,11.32-29.311,20.365-47.968,27.117c-18.648,6.762-38.637,10.143-59.953,10.143c-33.116,0-63.76-8.952-91.931-26.836
		c4.568,0.568,9.329,0.855,14.275,0.855c27.6,0,52.439-8.565,74.519-25.7c-12.941-0.185-24.506-4.179-34.688-11.991
		c-10.185-7.803-17.273-17.699-21.271-29.691c4.947,0.76,8.658,1.137,11.132,1.137c4.187,0,9.042-0.76,14.56-2.279
		c-13.894-2.669-25.598-9.562-35.115-20.697c-9.519-11.136-14.277-23.84-14.277-38.114v-0.571
		c10.085,4.755,19.602,7.229,28.549,7.422c-17.321-11.613-25.981-28.265-25.981-49.963c0-10.66,2.758-20.747,8.278-30.264
		c15.035,18.464,33.311,33.213,54.816,44.252c21.507,11.038,44.54,17.227,69.092,18.558c-0.95-3.616-1.427-8.186-1.427-13.704
		c0-16.562,5.853-30.692,17.56-42.399c11.703-11.706,25.837-17.561,42.394-17.561c17.515,0,32.079,6.283,43.688,18.846
		c13.134-2.474,25.892-7.33,38.26-14.56c-4.757,14.652-13.613,25.788-26.55,33.402c12.368-1.716,23.88-4.95,34.537-9.708
		C357.458,149.793,347.462,160.166,335.471,168.735z"/>
</g>
</svg>

    </a>


</div>

    

    <div class="copyright">
    
        © Copyright 2023 Yizhou
    
    </div>

    
</footer>



  </body>
</html>
