<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Yizhou</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Yizhou">
<meta name="author" content="">
<link rel="canonical" href="https://wuyizhou.com/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a8f329a89028c2356cb4f3650b14732202f51894615d7b3cfa1c3da20473eba1.css" integrity="sha256-qPMpqJAowjVstPNlCxRzIgL1GJRhXXs8&#43;hw9ogRz66E=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://wuyizhou.com/images/favicon.ico">

<link rel="apple-touch-icon" href="https://wuyizhou.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://wuyizhou.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://wuyizhou.com/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" /><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://wuyizhou.com/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://wuyizhou.com/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wuyizhou.com" accesskey="h" title="Yizhou (Alt + H)">Yizhou</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wuyizhou.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">家庭NAS搭建
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 最近因为装了家庭影院买了盒子，再加上之前自己也想购买一个NAS，选过来选过去挑选了群晖NAS，但是无奈价格太贵，除了统一性、稳定性和群晖自身开发的系统之外没有任何的性价比可言，四硬盘位的NAS卖的更是离谱。
家里有一台淘汰掉的主机，然后再加上自己有几块闲置的硬盘，便想出了自己搭建NAS服务器，因为每个IT男家中总会有那么一台或几台淘汰下来的机器和硬盘，即使你要组装一台新的机器，性价比也非常高。
再加上自行组建NAS可玩性、灵活度较高，所以就敲定了这个方案。
在3年前自己玩弄树莓派写了一篇文章，如今照着做了一遍感觉很多命令变化挺大的，所以也是重写一篇关于nas搭建的文章的动力。
在配置的时候本来我想搭建一个下载服务器，找到mldonkey搭建，但是无奈配置了半天也没有搞定所以也就放弃了。最后我的解决方案是通过其他电脑下载然后拷贝到nas中。
环境 系统我采用了Ubuntu 16.04 Server，因为在稳定性和节省系统资源比desktop版更胜一筹。如果你是想通过无线网络搭建NAS，那么第一次你需要使用网线连接安装Wi-Fi相关的包，如果没有网线或者你只需要无线网络，那么你可以使用desktop版本，因为desktop版自带了无线网卡的驱动。
方案 搭建samba服务器，用于储存一些非私人资料，比如软件安装包、ISO镜像文件等，把samba共享给电视盒子，可以直接观看硬盘里面的电影。 搭建Time Machine，因为本人常用的是MacBook笔记本，所以搭建Time Machine就显得非常必要了 搭建seafile私有云服务，并提供给外网端口，用于外部访问。 为什么要搭建seafile，虽然Time Machine可以备份我的资料，但是无法让我在外面没有带电脑的时候取得资料，并且搭建seafile也算是一个双备份，因为上面的三个服务都是单独的一块硬盘，即使Time Machine或者seafile其中一个硬盘损坏，也不会造成数据丢失。
准备工作 首先你可以查看你的硬盘情况，你可以通过lsblk命令查看，并通过fdisk命令进行分区。
在三块硬盘分区好了后，我们开始格式化分区。我的环境中sda1用于samba，sdb1用于seafile，sdc1用于time machine，那么需要分别格式为不同的格式。
因为time machine需要hfsplus格式，所以在格式化之前我们需要安装关于hfsplus的包。
&gt; apt install hfsplus hfsutils hfsprogs 然后我们开始格式化三个分区。
&gt; mkfs.ntfs -v /dev/sda1 &amp;&amp; mkfs.ext4 -v /dev/sdb1 &amp;&amp; mkfs.hfsplus -h /dev/sdc1 挂载三个分区
&gt; mkdir /var/samba &amp;&amp; mkdir /var/seafile &amp;&amp; mkdir /var/timemachine &gt; mount -t ntfs /dev/sda1 /var/samba &amp;&amp; mount -t ext4 /dev/sdb1 /var/seafile &amp;&amp; mount -t hfsplus /dev/sdc1 /var/timemachine 然后通过lsblk命令检测三个分区是否挂载成功。...</p>
  </div>
  <footer class="entry-footer"><span title='2017-09-29 08:46:10 +0000 UTC'>September 29, 2017</span></footer>
  <a class="entry-link" aria-label="post link to 家庭NAS搭建" href="https://wuyizhou.com/posts/homenas/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">LAMP环境搭建
    </h2>
  </header>
  <div class="entry-content">
    <p>环境 系统版本：Centos 7.3 64位
服务器：阿里云香港
当前用户：root
目标：搭建wordpress执行环境
准备工作 如果你是在一个新的环境中搭建lamp环境，那么我建议你先更新升级系统，这样能保证系统为最新版本以及系统的安全性。
&gt; yum -y update &gt; yum -y upgrade 安装Apache 首先安装Apache
&gt; yum -y install httpd 启动Apache
&gt; systemctl start httpd 设置Apache为开机启动
&gt; systemctl enable httpd 此时Apache搭建完成，系统的/var/www/html就是网站的根目录。访问服务器的外网ip或者域名就可以看见Apache已经搭建成功。
安装PHP 安装PHP
&gt; yum -y install php 安装一些常用的PHP模块
&gt; yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel 重启Apache使php生效
&gt; systemctl restart httpd 我们可以通过在网站根目录建立一个phpinfo函数来查看php是否能解析。
&gt; echo &#34;&lt;?php phpinfo() ?&gt;&#34; &gt;&gt; /var/www/html/test....</p>
  </div>
  <footer class="entry-footer"><span title='2017-09-24 06:43:23 +0000 UTC'>September 24, 2017</span></footer>
  <a class="entry-link" aria-label="post link to LAMP环境搭建" href="https://wuyizhou.com/posts/lamp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb 身份验证
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 不管数据库是在多安全的环境或者本地环境，给数据库建立一个安全的环境是很有必要的。
Mongodb提供了一系列的安全功能，这里介绍一种很常用的身份验证方式。
开启验证 默认情况下，只要在启动数据库的时候没有加上--auth选项，就是没有身份验证功能的，所有客户端都可以进行所有权限的操作。
如果加上过后，我们就可以通过安全的身份验证连接数据库。如果要在数据库中进行身份验证，可以通过db.auth(username, password)，如果验证成功则返回1，反之。
建立用户 建立用户我们可以通过db.createUser()方法来建立用户，比如下面这样：
db.createUser({user: &#39;username&#39;, pwd: &#39;password&#39;, roles: [ {role: &#39;read&#39;, db: &#39;test&#39;} ]}); db.createUser方法的接受一个对象，里面的user代表用户名，pwd代表密码，而roles是一个数组可以接受多个对象，每个对象可以对应作用于的数据库，其中的role字段代表对作用的数据库的权限，官方规定了一些列的内置角色，可以通过文档查询。
删除用户 删除用户需要具有权限的用户进行操作，通过db.dropUser()方法进行，接受一个字符串，这个字符串就是用户名:
db.dropUser(&#39;user1&#39;); 获取用户 可以通过db.getUser()方法来获取用户信息，同样它接受一个字符串，字符串为用户名:
db.getUser(&#39;user1&#39;); 参考 MongoDB权威指南(第2版)
Mongodb Docs</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-26 10:08:26 +0000 UTC'>August 26, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb 身份验证" href="https://wuyizhou.com/posts/mongodb-auth/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb 备份及恢复
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 无论在什么情况下都应该进行数据备份，才能避免灾难性的数据损坏，下面将介绍两种备份方式，两种备份方式使用的场景也不一样，可以根据自身的使用情况进行选择
复制文件备份 在复制数据库文件之前，我们可以通过db.fsynclock()方法让数据库禁止一切写入，并把所有在缓存中的信息全部同步到磁盘中，让所有的写操作进入队列，在没有取消锁之前，Mongodb不会对任何写操作进行处理。
&gt; db.fsyncLock(); 首先给数据库上锁，以免出现我们在备份的过程中同时还有数据写入 $ cp -R /data/blog/* /data/Backup/blog //复制数据库所有的文件到备份目录 &gt; db.fsyncUnlock(); 解锁数据库，解锁后数据库将处理队列中的写操作 mongodump mongodump可以给正在运行的实例进行热备份，只需要通过指定端口，地址，如果在本机上面运行，只需要指定端口就可以进行热备份了。
$ mongodump --port 27017 运行过后，mongodump会在当前目录建立一个dump文件夹，里面包含了我们备份的数据库数据。
恢复 上面第一种方式很好恢复，把备份的数据文件复制回来就可以了，而经过mongodump备份的文件需要使用mongodb提供的另一个工具mongorestore。
mongorestore通过给正在运行的实例进行恢复数据，下面是它的用法：
mongorestore --port 27017 ./dump/ 参考 MongoDB权威指南(第2版)
Mongodb Docs</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-26 09:42:07 +0000 UTC'>August 26, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb 备份及恢复" href="https://wuyizhou.com/posts/mongodb-backup/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb 数据修复
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 很多时候我们看见数据目录下有一个mongodb.lock文件，这个文件在开启了日志系统后不会出现，在没有开启日志系统的情况下非常重要，并且有时发现重新启动数据库的时候无法启动了，然后删除mongodb.lock又可以启动了，但是尽量不要这样做。
当Mongodb启动的时候会建立一个mongodb.lock文件，而正常退出的时候就会删除这个文件，但是遇见非正常退出，这个文件就滞留了，Mongodb就会得知上一次是非正常退出，所以第一时间不是删除这个文件启动，而是尝试着修复数据，再进行启动。
mongod –repair mongod内置了一个修复数据的选项，这个工具相比与下面介绍的另一种工具来说这种在修复的速度上要稍微快一下，我们只需指定修复的数据库路径，然后加上选项就可以进行修复了。
$ mongod --dbpath /data/blog --repair mongodump –repair 相比上一种介绍的修复工具，mongodump的修复功能更加接近底层，数据恢复可能更好，但是需要在已经执行的实例上面进行修复，并且效率上面会比上一种要稍慢。
$ mongodump --dbpath /data/blog --repair 参考 MongoDB权威指南(第2版)
Mongodb Docs</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-26 09:17:22 +0000 UTC'>August 26, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb 数据修复" href="https://wuyizhou.com/posts/mongodb-data-repair/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb 监测
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 为什么要进行监控状态，因为在实际的情况中可能会发生一下无法预计的情况，比如阻塞的问题，阻塞的原因会有很多种情况造成，如果当我们查询文档的时候发生了阻塞，那么就会影响到后面的操作，甚至无法对后面的操作进行响应。
我们可以通过监控很快速的找到到底是哪里出了问题，这样有助于我们快速定位所在的问题，从而得到解决。
Mongodb官方提供了三种用语分析Mongodb的方式：
Mongodb自带的监控工具：用于提供数据库活动的实时报告 数据库命令：以更真实的情况返回数据库状态的统计信息 第三方平台托管监控 Mongodb自带监控工具 mongostat mongostat是官方随同mongodb下载包中一同下载的，你可以找到安装目录或者解压目录进行使用。
我们可以通过mongostat --help()进行查询可用选项，也可以通过官方文档进行查询。
Mongostat默认所返回的信息都是基于秒为单位，比如返回的insert指的是每秒插入数据库的对象数，而如果我们限制了返回时间，那么这个返回的结果是基于限制时间的平均值。
-O 和 -o 这两个选项功能非常实用，按照正常的情况，Mongostat输出的报告会有很多我们不需要的列，所以我们可以通过-o来实现，这个选项设置后只会包含我们选择想要列，并且这个选项可以重新命名列的名字，除此之外-o和-O还可以添加一些服务器状态到报表中，可以参考ServerStatus。
默认的mongostat输出的内容大概如下，并且每秒钟都会返回一个状态：
insert query update delete getmore command flushes mapped vsize res faults qrw arw net_in net_out conn time *0 *0 *0 *0 0 2|0 0 0B 2.39G 14.0M 0 0|0 0|0 286b 13.8k 1 Aug 24 17:34:17.615 *0 *0 *0 *0 0 1|0 0 0B 2.39G 14.0M 0 0|0 0|0 285b 13.7k 1 Aug 24 17:34:18....</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-25 13:14:20 +0000 UTC'>August 25, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb 监测" href="https://wuyizhou.com/posts/mongodb-monitoring/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb 分片
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 分片是指将数据拆分，并分散放在多个服务器中组成一个集群，这可以将N台服务器的性能集中到一起来处理数据，这将很大程度的提高数据处理的速度。
在Mongodb的分片中必须具备三个角色：
路由服务器：用于处理和响应请求，并把各个分片服务器查询到的结果处理合并然后返回。 配置服务器(configServer)：存储集群、数据的描述信息。 分片服务器：用于储存拆分的数据服务器。 而这三个角色都是普通的数据库，只是扮演的角色不一样。
它们的请求、响应流程就如下图中表示一样：
因为所有的应用程序都是通过路由进行请求，所以对于应用程序来说，它没有什么不同就如请求一个普通数据服务器一样：
搭建配置服务器 首先我们需要搭建配置服务器，配置服务器如同分片的大脑，保存着集群和数据的描述信息。
因为Mongodb3.4版本后需要配置服务器必须配置为副本集，所以需要给配置服务器配置副本集，如果你还清楚如何搭建副本集，你可以试着看看我的上一篇文章《Mongodb 副本集》。
首先建立三个空的数据库目录，用于搭建配置服务器的副本集，并分别启动它们，在启动的时候需要加上我们副本集的名称和--configsvr来表示这是一个配置服务器，并分别指定不同的端口。
$ mkdir config0 config1 config2 $ mongod --dbpath config0 --replSet conServer --configsvr --port 27020 $ mongod --dbpath config1 --replSet conServer --configsvr --port 27021 $ mongod --dbpath config2 --replSet conServer --configsvr --port 27020 然后通过mongo随意进入一个副本集成员，并为配置服务器的副本集进行配置：
$ mongo --port 27020 --host localhost &gt; var conf = { _id: &#39;conServer&#39;, version: 1, members: [ { _id: 0, host: &#39;localhost:27020&#39; }, { _id: 1, host: &#39;localhost:27021&#39; }, { _id: 2, host: &#39;localhost:27022&#39; } ] }; &gt; rs....</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-23 12:03:05 +0000 UTC'>August 23, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb 分片" href="https://wuyizhou.com/posts/mongodb-shares/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb 副本集
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 Mongodb官方提供了一个复制功能，它提供冗余的功能，它可以将数据保存在不同服务器上，并保持多个服务器的数据一致性。
当主要提供数据的服务器出现了问题不能访问等问题，副本集中的其他服务器会自动替代主要提供数据的服务器进行提供数据功能。
副本集中有三个角色：
主节点：所有副节点的数据均来自于主节点，并且只能对主节点进行读写操作。 副节点：数据来自于主节点，可以进行读取操作，但是不能进行写操作。 仲裁者：不含数据也不与客户端交流，只在选举主节点的时候进行投票。 选举机制 Mongodb最多支持50个副本集成员以及最多7个选举成员，启动副本集后将开始第一次选举，在选举过程中，所有副本集成员都只能读取，直到选举出主节点后主节点才能进行读写，但是在这个期间副本成员可以提供查询服务。
而主节点要保持主节点的位置需要每两秒发送一个ping请求，如果10秒内没有得到响应则标记为不可访问，当一半以上的副本集成员不可访问，那么主节点将降级为副节点。
其中设置成员的priority值可以优先成员主节点，这个值介于0-1000之间，默认为1，如果这个值为0，那么它的votes值也为0，只要votes为0的成员不能投选举票，但是可以投否决票。但是我们也可以手动设置成员priority值为大于1的成员是否有投票权利。
在进行选举的时候，其他成员会作以下几点判断来进行投票参与选举的成员是否能作为主节点，选举步骤：
自己是否能与主节点通讯。 参与选举的成员是否比其他参与选举的成员数据最新。 如果参与选举的成员数据相等则尝试使用具有最高priority的值的成员。 仲裁者 仲裁者的出现是为了避免只有两个成员的副本集，两个成员的副本集投票可能无法满足一半以上的投票情况。
仲裁者不负责数据和客户端交流，只有参与选举的功能，需要注意的是仲裁者一旦设置过后就再也无法变为非仲裁者了。
部署副本集 首先部署一个副本集很简单，下面的代码是部署了一个本地含有三个成员的副本集。
建立三个成员的副本集，首先你得建立三个数据库的存放目录：
mkdir -p ./replDb/s0 ./replDb/s1 ./replDb/s2 然后我们启动三个副本集成员，其中replSet参数后面跟的是副本集的名称，将需要有关联的成员的副本集名称要一致。
mongod --dbpath ./replDb/s0 --port 27017 --replSet s0 mongod --dbpath ./replDb/s0 --port 27018 --replSet s0 mongod --dbpath ./replDb/s0 --port 27019 --replSet s0 创建仲裁者也同样非常简单，建立一个空的数据目录，然后和其他副本集成员一样设置同样的副本集名称启动，最后通过rs.add方法的第二个参数设置为true：
mongod --dbpath ./replDb/s5 --port 27020 --replSet s0 mongod --port 27017 --host localhost &gt; rs.add(&#39;localhost:27020&#39;, true); 然后通过Mongo Shell进入到端口为27017的成员中，并配置副本集。
mongod --port 27017 --host localhost 进入到Mongo Shell后通过rs....</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-21 12:22:01 +0000 UTC'>August 21, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb 副本集" href="https://wuyizhou.com/posts/mongodb-replica/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb MapReduce
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 在上一节中说到了appregate聚合功能，聚合功能已经非常强大了，但是如果你还是无法通过聚合解决问题的话，那么你可能需要使用MapReduce了。
MapReduce提供了Javascript的解释器，所以非常的强大，并且MapReduce可以在多台服务器之间并行的执行，将一个大问题拆分为多个小问题然后分发执行并返回，但是这样的代价就是牺牲了速度，所以才产品发布环境中尽量不要使用MapReduce，因为会很慢很慢。
MapReduce分为两个部分，一个为map一个为reduce，它们两个都是一个纯Js函数，map分别对作用的集合里的每一个文档传入自身函数进行调用返回了一个不同键值对组成的一个列表，就像下面这样：
[ a: [1,3,4], b: [5,3,4] ] 而reduce就是对map执行完后的一个列表进行统计，最后返回。Reduce非常像appregate中的group分组。
如果上面的文字你还是听着有点模糊不清，那么下面这张图可以很好的帮助你理解MapReduce,然后看完文章你一定要在执行环境下实验，才能更好的理解强大的MapReduce，因为MapReduce不止存在于Mongodb中，它是由Google解决分布式计算提出的一种概念，Mongodb只是对这个概念的实现，所以MapReduce会出现在任何的一种数据库中。
图片原地址：壮壮熊
官方语法 官方文档中MapReduce的语法如下：
db.collection.mapReduce( &lt;map&gt;, &lt;reduce&gt;, { out: &lt;collection&gt;, query: &lt;document&gt;, sort: &lt;document&gt;, limit: &lt;number&gt;, finalize: &lt;function&gt;, scope: &lt;document&gt;, jsMode: &lt;boolean&gt;, verbose: &lt;boolean&gt;, bypassDocumentValidation: &lt;boolean&gt; } ); 除了上面所说的map和reduce函数之外，Mongodb还增加了一个选项，在这里选项里面我们可以快速的筛选一部分文档，给MapReduce，这么做的愿意是尽可能的让MapReduce执行更快，比如上面的query可以过滤一些不符合的文档、sort排序、limit限制返回的文档数量等，如果你需要筛选文档、排序、限制等操作，尽量在选项中进行操作，因为如果你让1000文档每个文档遍历给Js函数快还是让Mongodb内部查询1000个文档快？当然是后者。
Map map函数的作用是对集合中的每个文档进行调用，map函数是一个纯Js函数，它接受一个this对象，这个this对象代表的就是每个文档，我们可以通过this.xxx来调用文档里面的键值，并在内部调用一个名为emit的函数用于生成列表传给reduce函数，emit函数接受两个参数key和value，然后会将相同键名的合成一个键，并把值储存在一个数组当中，通常可以将这个过程称为“洗牌”。
function map(){ emit(this.num, this.str); } 通常返回的文档大概为：
[ 5: [&#39;a&#39;, &#39;b&#39;], 6: [&#39;b&#39;, &#39;d&#39;] ] Reduce reduce函数通过map函数里面的洗牌，接受一个key和values，返回的所有文档中只会存在一个唯一的key，如果相同key的值则储存在数组中，在这一步我们可以将key键名相同的值进行操作然后返回一个对象，最后得到结果，这一步一般称为简化。
function reduce(key, values){ return {values: values} } 实例 mapReduce函数返回的是一个集合的引用，我们可以通过.运算符直接运行Mongodb提供的一些集合操作方法。除此之外我们还可以通过选项中的out设置一个临时的集合，我们可以通过db.xxx来访问这个临时的集合。
下面的例子是通过MapReduce找到含有num为5的文档，并返回所有含有num为5的文档中str键的值。
通过下面的代码我们插入100个文档
for(var i = 0; i &lt; 100; i&#43;&#43;){ db....</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-20 15:17:26 +0000 UTC'>August 20, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb MapReduce" href="https://wuyizhou.com/posts/mongodb-mapreduce/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb 聚合
    </h2>
  </header>
  <div class="entry-content">
    <p>参考 MongoDB权威指南(第2版)
Mongodb Docs
前言 Mongodb提供了一个强大的处理框架，可以对集合中的文档进行各种组合、过滤、输出，如果你通过Mongodb其他的查询方法无法处理你的查询或者查询难度很高，那么你可以试试聚合。
这里我们只讲解一下常用的聚合管道操作符，其他的可以自行到官方文档进行查询。
语法 官方文档的聚合语法是这样的：
db.collection.aggregate（pipeline，options); 聚合：计算集合或视图中数据的聚合值，并且聚合接受一个数组，数组的每一个成员都是对象，对象里面子键都代表一个管道操作，按照顺序的从第一个管道操作到最后一个，每次操作完的文档返回给下一个管道操作。
pipeline： 一系列数据聚合操作或阶段。有关详细信息，请参阅 聚合管道运算，在版本2.6中更改：该方法仍然可以将流水线阶段接受为单独的参数，而不是数组中的元素; 但是，如果不指定pipeline为数组，则不能指定 options参数。
options:可选的。aggregate()传递给aggregate命令的附加选项。版本2.6中的新功能，仅当您指定pipeline为数组时可用。
大概我们可以把聚合理解为对文档进行一系列的操作从而达到我们需要的查询文档，聚合提供了很多管道操作符，这些管道操作符就像一根一根的管道一些，而我们通过聚合操作的文档就像管道里面的水，这根管道流下来的水继续流到下一根管道，直到没有了管道，水就流出来了。 我将在下面讲解几个常用的管道操作符，你也可以单独使用其中任意的管道操作符，分别为：
match(过滤): 过滤文档流，只允许匹配的文档未修改地传递到下一个流水线阶段。$match 使用标准的MongoDB查询。对于每个输入文档，输出一个文档（匹配）或零个文档（不匹配）。
$project(映射)：重新整理流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。
$group(分组)：通过一些指定的累加器将组文档输出到下一阶段，为每个不同的分组输出文档。
$unwind(拆分)：从输入文档中解构一个数组字段，以输出每个元素的文档。每个输出文档用元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组可以为零。
$sort(排序)：按指定的排序键重新排序文档流。
$limit(限制)：将前n个文档传递到管道，n是一个数字。
$skip(跳过)：将前n个文档丢弃，后面的部分传递到管道。
上面的顺序一般是我们常用的顺序，首先我们筛选一部分文档，然后从筛选中整理一份更加便于我们操作的文档，然后在对整理好的文档通过一些表达式来分组整理，然后通过排序、限制、跳过，得到我们最终的结果。 在管道操作符中如果需要指定文档中的某个键的时候，需要在键名前面加上$符号，比如文档中的name键，在管道操作中要指定它就得这样写$name。 并且我们所有的操作的文档都不是操作储存在硬盘中的数据，我们操作的文档都是储存在内存当中，所以不影响原始数据。
管道操作符 $match $match应尽量放在聚合的最前面，因为$match使用的是Mongodb的标准查询，所以可以使用索引来提高我们的效率，其次是可以过滤掉不需要的文档，让后续的操作更加效率。 既然是标准的查询我们就可以使用标准查询里面所有操作符。 下面来大概演示一下$match的操作方法： 实例的文档结构如下:
{ &#34;_id&#34; : ObjectId(&#34;512bc95fe835e68f199c8686&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 80, &#34;views&#34; : 100 } { &#34;_id&#34; : ObjectId(&#34;512bc962e835e68f199c8687&#34;), &#34;author&#34; : &#34;dave&#34;, &#34;score&#34; : 85, &#34;views&#34; : 521 } { &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b257&#34;), &#34;author&#34; : &#34;ahn&#34;, &#34;score&#34; : 60, &#34;views&#34; : 1000 } { &#34;_id&#34; : ObjectId(&#34;55f5a192d4bede9ac365b258&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 55, &#34;views&#34; : 5000 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b259&#34;), &#34;author&#34; : &#34;annT&#34;, &#34;score&#34; : 60, &#34;views&#34; : 50 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25a&#34;), &#34;author&#34; : &#34;li&#34;, &#34;score&#34; : 94, &#34;views&#34; : 999 } { &#34;_id&#34; : ObjectId(&#34;55f5a1d3d4bede9ac365b25b&#34;), &#34;author&#34; : &#34;ty&#34;, &#34;score&#34; : 95, &#34;views&#34; : 1000 } 查询author键的值为dave的文档：...</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-10 14:18:52 +0000 UTC'>August 10, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb 聚合" href="https://wuyizhou.com/posts/mongodb-aggregate/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://wuyizhou.com/posts/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://wuyizhou.com/posts/page/5/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://wuyizhou.com">Yizhou</a></span>
    <span>
        <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
    </span>
    <span>
        Build: 2024-02-09 17:06:12
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
