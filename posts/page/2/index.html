<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Yizhou</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Yizhou">
<meta name="author" content="">
<link rel="canonical" href="/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css" integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as="style">
<link rel="icon" href="favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<link rel="mask-icon" href="safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>
<meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="" accesskey="h" title="Yizhou (Alt + H)">Yizhou</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">人工智能基础名词理解
    </h2>
  </header>
  <div class="entry-content">
    <p>人工智能 人工智能是一个比较广泛的概念，这个概念实际上指的是让机器像人一样思考，其最早由计算机科学之父阿兰图灵在1950年的一篇《计算机器与智能》论文中写出“如果电脑能在5分钟能回答由人类测试者提出的一系列的问题，且超过30%回答让测试者误认为人类所答，则电脑通过测试”，这段话也直接启蒙式的开启了人工智能领域的研究。 而“人工智能”一词，第一次出现在1956年，达特茅斯大学召开的学术会议室，由人工智能之父约翰·麦卡锡首次提出。 通常人工智能被分为弱人工智能和强人工智能，前者可以让机器有一定程度的学习、理解和推理能力，后者则是由自适应能力，比如解决一些之前没有遇见过的问题，我们常在电影里看见的机器人就是一种强人工智能。
机器学习 机器学习为人工智能的一个研究分支，也可以理解为弱人工智能的一种实现，而机器学习做的事情是让机器取模拟和实现人类的学习行为，以获得新的技能和知识。 人工智能领域的先驱Arthur Samuel在1959年给出的机器学习定义为“不直接编程，却能赋予计算机提供能力的方法”，而美国工程院院士Tom Mitchell则给出了一个更明确的含义，指出“机器学习是通过某项人物的经验数据提高了在该人物上的能力”。 机器学习最基本的是利用给出的算法来解析数据，从中学习到一定规则(模式)得到经验，并利用学习到的经验对类似的问题作出预测和判断。 而如今机器学习已在多个领域得到了很好的应用，大致上可以将机器学习的分为几个研究方向：
模式识别 自然语言处理 数据挖掘 计算机视觉 语言识别 统计学习 算法 前面提到机器学习需要给出算法来解析（学习）数据，以获得经验，而这个算法则包括我们常说的“神经网络”也是机器学习算法的一种，常见的算法有如下：
回归算法 神经网络算法 SVM向量机 聚类算法 降维算法 推荐算法 决策树 朴素贝叶斯 其他算法 而根据这些算法可以分为监督学习、无监督学习、半监督学习、强化学习，其中监督学习在日语中被称为“有老师的学习”，本质上是让机器学习带有“标准答案”的数据，然后再让机器学习做题，根据做题的结果对比标准答案，根据误差进行调整，经过多次反复，让机器的误差越来越小。 像上面这样在带有标签（答案）的数据上学习的过程被称为“训练”，而训练用到的数据被称为“训练集”，但也被叫做“数据集”，因为该数据集是被拿来训练的，所以被称为训练集，同样训练集在自然语言处理中被称为“语料库”。在训练集里面每一个数据被称为“样本”，在训练过程中反复针对误差作出的调整则被称为“调参”。 而训练出来的结果则为称为“模型”，模型其实也是算法，但为了区分，所以将机器学习的结果称为模型。模型可以用来针对训练集相似类型的问题去得到一个结论（值），这个过程则被称为&#34;预测&#34; 无监督学习在日语中被称为“没有老师的学习”，这就意味着数据不含标准答案，机器可以发现数据与数据之间的关联，但无法发现数据与答案之间的关联，常见的无监督学习算法有聚类、降维等算法。 半监督学习是利用多个模型对同一个实例进行预测，如果这些结果多数一致，则可以将这个实例和结果放在一起作为新的训练集，由于半监督学习可以利用标注数据来丰富未标注数据，所以目前正是热门的研究。 之所以半监督学习这样热门是因为带有“标准答案”的数据集几乎都是由人工整理和标注，需要大量的人力、成本、时间，也被叫为“黄金数据（Gold Data）”，所以半监督学习则可以用少量的标注数据集来得到更多的标注数据集来减少其人工、成本、时间。 强化学习针对的是需要一系列彼此关联决策的问题，比如自动驾驶、电子竞技等，这类问题往往需要一边预测，一边跟着环境的反馈规划下一次决策。
特征工程 特征工程一般情况下分为“特征提取”和“特征模板”，特征提取指的是将我们要处理的实例转换为计算机能处理的数值类型的特征值，比如判断名字“沈雁冰”性别为例，特征提取则大概表示如下：
特征序号 特征条件 特征值 1 是否含“雁” 1 2 是否含“冰” 1 而对于大量的数据进行手动的特征提取是不太现实的，而需要定义一套特征模板来进行提取，比如一大堆的姓名数据，表示为name，那么可以定义name[1]&#43;name[2]这样的特征模板，然后通过这个模板在相同类的样本中遍历组合则这一类的数据基本上各种情况的特征基本上覆盖完了。
深度学习 深度学习本质就是为神经网络算法，在2006年人工智能专家Geoffrey Hinton等人研究出一个名为“深度信念网络”，率先使用了“深度”一词，他们在这里面引入了一个叫“Greedy layer wise pre-training”策略，而其他研究者发现这个策略对于训练深层的神经网络很有效果，所以深层神经网络也叫深度学习。
参考文章 什么是机器学习？ 人工智能、机器学习、深度学习、神经网络概念说明 神经网络啥时候改名叫“深度学习”了？ 深度学习和人工智能之间是什么样的关系？ 《自然语言处理入门》 </p>
  </div>
  <footer class="entry-footer"><span title='2021-06-26 06:48:33 +0000 UTC'>June 26, 2021</span></footer>
  <a class="entry-link" aria-label="post link to 人工智能基础名词理解" href="/posts/inteliigence-terms/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">(二)漫话中文分词：Trie、KMP、AC自动机
    </h2>
  </header>
  <div class="entry-content">
    <p>Trie树 在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[‘中国人’, ‘中东人’]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词retrieval，发音和try相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如&#34;中国人&#34;、“中东人&#34;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以&#34;中&#34;开头，所以可以使用同一个父辈节点。
除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如中国人，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。
Trie树的查找方式则是通过层层查询，而不是直接遍历词典，比如&#34;中国人”，首先会查找第一层中是否有&#34;中&#34;这个字符，如果没有查询到则返回查询失败，如果有则继续查找&#34;中&#34;字符对应的下一层是否有&#34;国&#34;，如果没有则返回查询识别，如果有则继续查找&#34;国&#34;下一层是否有&#34;人&#34;，此时找到存在&#34;人&#34;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：
查询词 添加词 除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回&#34;False&#34;表示为未查询到或设置失败，而返回&#34;True&#34;则表示查询到或设置成功，每个节点为一个字符，而字典当中的__value表示是否为结束节点（即一个词的尾字符），如果是则为True，不是则为False，整体可以采用函数或者类来定义。 实现代码：
class Trie(): #定义一个Trie类型 def __init__(self): #为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构 self._children = {} def _add_word(self, word): # 定义一个添加词的实例方法 child = self._children # 首先会将_children的对象赋值给child for i,char in enumerate(word): # 然后从头遍历添加词的每一个字符 if char not in child: # 查看当前字符是否存在Trie树上 child[char] = {&#39;__value&#39;: False} # 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符 if i == (len(word) - 1): # 判断是否为结尾字符 child[char][&#39;__value&#39;] = True # 如果是则将特殊key：__value设为True，表明为结尾字符 child = child[char] # 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下 return True # 添加完成返回True def _get_word(self, word): # 查找词 child = self....</p>
  </div>
  <footer class="entry-footer"><span title='2020-11-18 08:51:13 +0000 UTC'>November 18, 2020</span></footer>
  <a class="entry-link" aria-label="post link to (二)漫话中文分词：Trie、KMP、AC自动机" href="/posts/chinesecutwords-2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">(一)漫话中文分词：最大匹配,双向最大,最小词数
    </h2>
  </header>
  <div class="entry-content">
    <p>中文分词是指将文本拆分为单词的过程，而结果集合连接起来是等于原始的文本，而中文分词一直作为NLP领域的比较重要的领域，而大多数的文本挖掘都是以分词为基础，但中文不同于英文，英文每个单词是用空格分隔，整体语义上相对于中文难度低很多。 而业务上一直有中文分词的需求，但是之前因为在忙于另外一个项目，所以一直没有研究。 近期稍空闲开始研究了相关的中文分词算法，发现中文分词总体算比较成熟，但是其中对于未登录词或者某个特定专业领域文本大部分算法分词的结果不尽人意，需要结合多种算法或者人工词典才能达到稍微好一点的效果。 中文分词的方式一共有两种，分别为：
词典分词：如正向最大匹配算法、反向最大匹配算法、双向最大匹配算法、最少词数法等 字标注分词：如HMM（隐马尔可夫）模型等 而这几种方式很难说出谁好谁坏，比如词典分词的方式速度非常快，但对于未登录词的识别又不太好，而HMM和Pkuseg都能识别部分未登录词，但是运行速度又降下来了，这对于在实际应用场景当中是非常致命的问题，所以最大的优解就是集各家所长，比如结巴分词就使用了词典分词算法识别能识别的词，而不能识别的则继续使用了HMM模型来处理。
词典分词 基于词典的分词算法实际上就是对于类似字典的数据结构进行查询，对于未在词典内的词识别较弱和交集型歧义理解能力也较弱，比如“结婚的和尚未结婚的”，理想的情况是&#34;结婚/的/和/尚未/结婚/的&#34;，而实际中则会被分词为&#34;结婚/的/和尚/未/结婚/的&#34;。 但好在词典分词的速度则非常快，词典分词目前已有非常成熟高效的解决方案，并且有非常多的工具来帮你实现相关的高效数据结构和查询方式，比如Trie树和AC自动机，但在这里为了方便理解和记录，只采用了尽可能简单的方式来记录其几种算法的实现和原理。
正向最大匹配算法（Forward Maximum Matching） 正向最大匹配算法类似于人的阅读习惯，即从左到右进行识别，而其中的&#34;最大&#34;是基于词典中最长字符的长度作为最大的匹配宽度，然后每次根据这个宽度对文本进行切分并取出来查询词典。如果当前取出来的词能在词典当中查询当则返回，并下一次切分的开始位置为该词的位置&#43;1。而如果当前取出的部分没有在词典中查找到，则将该部分去掉最后一个字符后再进行查找，一直重复直到匹配到了词典中的词。如果整个部分只剩余一个字符，并没有匹配到词典中的词，则将最后剩余的这个字符输出，然后根据这个字符的位置&#43;1开始再次进行切分和查询。 比如，有一段文本&#34;中文分词算法&#34;，字典中只包含了一个词&#34;分词&#34;，这个时候最大的匹配宽度也为2，所以整段文本按照2个字符进行切分。第一次得到&#34;中文&#34;文本，查找词典并无该词，则在该部分上去掉最后的字符，得到&#34;中&#34;，再次查询词典并无该词，此时查找结束，所以不需要再进行匹配，则这个切分记为[“中”]。 继续进行第二次切分，得到的文本为&#34;文分&#34;，进行查询词典，第一次查询&#34;文分&#34;在字典中不存在，去掉最后一个字符，继续以剩余部分’文’查询第二次，未查询到，那么返回最后这个字符&#34;文&#34;，加上次的结果记作[“中”,“文”] 继续第三次切分，得到文本&#34;分词&#34;，进行查询词典，查询到该词在字典当中，所以直接记录在之前的结果当中，记作[“中”, “文”, “分词”]。 继续第四次切分，得到文本&#34;算法&#34;，进行查询字典，第一次查询&#34;算法&#34;在字典中不存在，去掉最后一个字符，继续以剩余部分’算’查询第二次，未查询到，那么返回最后这个字符&#34;算&#34;，加上次的结果记作[“中”, “文”, “分词”, “算”] 继续第五次切分，因为最后只剩余一个字符，所以这个时候可以不进行匹配即返回，所以最终的结果为[“中”, “文”, “分词”, “算”, “法”] 整体分词的过程本质对每个分块进行查找，并依次去掉最后字符查询，而网上还有一部分是没有使用最大宽度切分，即会对每个字符到文本结束的位置都会依次遍历，这样的方式实际上会浪费较多的资源，因为即使从头到尾依次遍历匹配，但最长词的长度是固定的，所以真正开始匹配还是从最长词的长度开始，而其余的遍历都是浪费了资源。 正向最大匹配算法具体的实现代码：
sentence = &#39;中文分词算法&#39; # 输入的句子 cutList = [&#39;分词&#39;] # 分词词典 start = 0 #设置切分起始位置 maxWidth = len(max(cutList, key=len)) # 得到字典当中最大的切分宽度 cut_result = [] # 设置一个空的分词结果 while (start &lt;= len(sentence)): #开始循环，如果start大于等于句子长度则停止分词 end = start &#43; maxWidth # 计算每次切分的停止位置 word = sentence[start: end] # 开始切分，文本为变量start和end的区间内字符 while ( word ) : # python对于空字符串会转换为False if ( word in cutList ) : # 查看第一次切分后是否能在词典中匹配，如果匹配则放入最终的分词结果列表cut_result,并跳出循环 cut_result....</p>
  </div>
  <footer class="entry-footer"><span title='2020-11-08 10:36:34 +0000 UTC'>November 8, 2020</span></footer>
  <a class="entry-link" aria-label="post link to (一)漫话中文分词：最大匹配,双向最大,最小词数" href="/posts/chinesecutwords-1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">理解条件概率
    </h2>
  </header>
  <div class="entry-content">
    <p>样本空间（Ω） 样本空间通常指实验或随机所有可能的集合，我们常在说一个概率的时候，实际上是默认忽略掉了样本空间，比如说事件A的概率，实际上指样本空间中，事件A的数量与样本空间的占比。
比如丢硬币，硬币只有正面和反面，那么硬币的样本空间则为 ${正面，反面}$，这个时候常说的正面的概率为二分之一，实际指的是正面事件的数量与样本空间的占比，也就是1/2。 再比如说丢骰子，一个骰子有6种可能，分别对应1-6不同的数值，那么丢骰子的样本空间则为${1，2，3，4，5，6}$，这个时候丢到5个事件概率则为数字5在样本空间出现的次数与样本空间总数的占比。
独立事件 独立事件是指不受过去已发生的事件而影响的事件，典型的例子就是抛硬币，不管你抛多少次硬币始终正面或反面的概率为0.5，而该硬币的样本空间如下：
独立事件的概率计算公式为如下：
$$ 事件发生的概率(P) = 事件在样本空间中的数量 / 样本空间的事件总数 $$
比如用抛硬币的例子，计算正面的概率则为：
而除了单个独立事件，有些时候也会求多个独立事件的概率，而多个独立事件的概率则是每个独立事件发生的概率的积。 比如掷3次骰子都为6的概率是多少？需要注意因为掷骰子是一个独立事件，即每次掷的骰子样本空间都一样，并且没有因为第一次掷骰子的结果会影响到下一次。 骰子的样本空间为下，从中能够得到单次掷骰子为6的概率为1/6：
而这个时候只需要将三次掷骰子的概率相乘就得到了三次都为6的概率：
相关事件 相关事件和独立事件是相对的，相关事件的发生概率会受到过去已发生事件的影响，每个事件都和上一个事件有关联，这些事件便是相关的。 比如一个布袋中有5个球，其中包含2个蓝球，三个红球，布袋(样本空间)则为：
这个时候如果随机拿一颗蓝球的概率是多少？概率为2/5。 但是此时求第二次拿到蓝球的概率是多少？这个时候就会有两种情况发生：
第一次拿到红球，这个时候整个样本空间少了一个红球，所以第二次拿到蓝球的概率为2/4 第二次拿到蓝球，这个时候整个样本空间少了一个篮球，所以第二次拿到蓝球的概率为1/4 用图表示则为：
所以此时，如果算第一次拿到红球后，第二次拿到蓝球的概率则为：
如果算第一次拿到蓝球后，第二次拿到红球的概率则为：
条件概率 条件概率是研究相关事件的，指的是当B事件发生后，A事件发生的概率，用&#34;｜&#34;来表示&#34;以下发生的条件下&#34;，表示为公式：
比如上面的例子，第二个蓝球的概率是多少，这个问题就是条件概率，因为第二次抽中蓝球的概率是基于第一次拿了一颗球过后发生的事件。 这个时候可以将第一次抽中红球记作事件A，第二次抽蓝球为事件B，因为第二次抽球是在事件A发生的情况下而发生的，所以记作 $P(B|A)$ ，表示在A发生后，B发生的概率。 而这个概率可以根据下图来得到，即2/4：
这里的条件概率本质是二级概率，该情况可以用图来表达，第一次抽球的样本空间为整个样本空间：
当第一次抽球(A事件)发生后，B事件的样本空间则是基于A事件发生后的样本空间，即下图中A圆圈内的样本空间：
联合概率 联合概率指两个事件共同发生的概率，比如A和B事件共同发生的概率表示为：
联合概率的计算分为两种情况，一种为独立事件，比如前面掷骰子，计算公式则为多个独立事件事件的积，表示为：
另一种则为相关事件，比如上面的抽球的例子，则可以通过反推来计算，表示为：
这里这样计算是因为P(B|A)只得到了B在A发生后的概率，也就是在发生后的样本空间上计算的，所以P(B|A)表示的只有下图这么一部分发生的概率：
而在这个时候乘以P(A)的概率，则就能表示如下这整个部分：
全概率 导致一个事件发生的原因有很多种，那么该事件发生的概率就是每种原因引起该事件发生的概率总和，这句话能够很好的解释全概率。 而全概率公式就可以计算出一个事件的全部概率，公式为：
而根据联合概率的计算方法，可以写成下面这样：
还是拿红蓝球的例子来说，如果需要计算P(B)，这个时候可以利用全概率公式，则将能引起事件B发生的每个概率相加，即可得到P(B)。 在红篮球例子当中，引起事件B的原因有两种，分别为：先拿到红球，然后抽中蓝球的概率和先拿到蓝球抽中蓝球的概率。 根据图中第一种先拿到了红球引起B事件的发生的概率为 $(3/5) * (2/4) = 0.3$
根据图中第二种先拿到了蓝球引起B事件的发生的概率为 $(2/5) * (1/4) = 0.1 $
这个时候得到了所有能引起B事件发生的原因的概率，所以：
$$ P(B) = 0.3 &#43; 0....</p>
  </div>
  <footer class="entry-footer"><span title='2020-11-03 09:03:53 +0000 UTC'>November 3, 2020</span></footer>
  <a class="entry-link" aria-label="post link to 理解条件概率" href="/posts/learning-conditional-probability/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">理解连续数据和离散数据
    </h2>
  </header>
  <div class="entry-content">
    <p>统计学中，将一种类型的数据总称为变量，而变量的数据称为观测，而变量的具体取值为观测值，比如下面的数据中，age和name都是变量，而18和’大红’都具体的取值被称为观测值。
age,name 18,’大红’ 21,’小花’ 同理，在统计学中，离散数据也被称为离散变量，连续数据也被称为连续变量，而如何区分两种变量的区别？ 连续变量可以理解为取值范围在理论上是连续不断的，而离散变量则可以理解为取值范围是间断不连续的，他们之间的区别并无数量之分，都是无穷个。 比如家庭数量人口只有1、2、3、4个人口，不可能为1.2、1.8、2.4这样来表示人口，所以家庭人口是离散变量。 而年龄取值上通常为了方便而说是18岁、17岁、30岁，但是如果按照实际取值，则可以取为18.32、17.55、30.67岁，17.55岁则表示年龄为17岁6个月18天，而且出生的时间还可以精确到小时、分、秒等单位，所以年龄为连续变量。
参考资料 关于连续和离散的理解 定量和定性变量、连续和离散变量，到底怎么分？ 图解概率笔记：葉丙成概率公开课 </p>
  </div>
  <footer class="entry-footer"><span title='2020-10-27 07:35:35 +0000 UTC'>October 27, 2020</span></footer>
  <a class="entry-link" aria-label="post link to 理解连续数据和离散数据" href="/posts/continuous-data-and-discrete-data/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python数据集合
    </h2>
  </header>
  <div class="entry-content">
    <p>列表 列表是有序可变的数据集合，并且一对[]来表示这是一个列表，元素之间逗号分隔，每个数据之间有逗号分隔，列表基本上可以包含很多数据类型，下面就是一个典型的列表：
list = [1,2.2,&#39;ok&#39;,bool] 在上面的列表中存储了数据(整型、浮点型、字符串、布尔值)，包含我们下面看见的几种集合类型都是可以当作列表的子元素的。
当然也可以从列表中取出数据，因为列表是有序的，所以我们可以通过索引从0开始进行取数据,你需要注意的是所有可以用索引进行得到值的都是从0开始，比如下面的代码取出了列表第一个和第三个数据。
list = [1,2.2,&#39;ok&#39;,bool] list[0] # 1 list[2] # &#39;ok&#39; 除了0开始的整数，还可以用负数，比如-1表示倒数第一个值，-2表示倒数第二个值，以此类推。
list = [1,2.2,&#39;ok&#39;,bool] list[-1] # bool list[-2] # &#39;ok&#39; 列表切片 除此之外，列表还支持切片的功能，就相当于一块肉，我们通过菜刀把这块肉切成一片一片的，方便我们炒菜（方便处理）。切片同样和索引一样存在列表变量名后的[]里面，大概语法如下：
list[起始位置:截至位置(但不包括本位置的值):步数] 下面的代码我获取了从第一个到第四个的值（但不包括第四个值）：
list = [1,2.2,&#39;ok&#39;,bool] list[0:3] # 1,2.2,&#39;ok&#39; 也可以设置步数，作用就是比如我们设置2，就会每隔两个值就返回一个值：
list = [1,2.2,&#39;ok&#39;,bool] list[0:4:1] #[1, &#39;ok&#39;] 当然同样可以设置负数，可以自行测试！
列表查询 列表查询可以用于判断一个值是否在列表当中，通过in和not in来进行，其中in表示一个值是否包含在列表当中，如果包含则返回True，反之返回False，而not in则是对in的结果进行取反，比如下面的代码则表示了判断值2.2是不是存在于列表当中以及对in结果进行取反。
list = [1,2.2,&#39;ok&#39;,bool] print(2.2 in list) #返回 True print(2.2 not in list) #返回False 元组 元组是有序不可变的数据集合，并且用一对()来进行表示，元素之间逗号分隔，当你定义好元组那一刻，元组里面的所有数据就不能够进行修改了，你只能读取里面的数据而无法修改和添加数据，比如下面，我定义了一组元组后，我通过修改第一个元素产生错误：
tple = (1,2,3,4) tple[0] # 1 tple[0] = &#39;m&#39; &#34;&#34;&#34; Traceback (most recent call last): File &#34;&lt;ipython-input-21-cae8ab2b1ade&gt;&#34;, line 1, in &lt;module&gt; tple[0] = m TypeError: &#39;tuple&#39; object does not support item assignment 在上面这一行就会明显提醒你tuple对象不支持修改。 &#34;&#34;&#34; 集合 集合是可变无序的数据集合，并且用一对{}表示，元素之间逗号分隔，还需要特别注意的是集合是一个包含唯一元素的可变无序集合数据类型,集合的一个用途是快速删除列表中的重复项 ，集合是无序的，既然是无序那么就没有办法进行索引，我们只能通过两个方法进行添加和删除数据并返回，添加通过add()方法，删除是pop()方法，添加是随机插入到集合当中的任何位置，而删除是从集合当中随机取出一个值删除并返回。比如下面的操作：...</p>
  </div>
  <footer class="entry-footer"><span title='2018-06-25 13:21:31 +0000 UTC'>June 25, 2018</span></footer>
  <a class="entry-link" aria-label="post link to Python数据集合" href="/posts/python-list/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python数据类型与操作符
    </h2>
  </header>
  <div class="entry-content">
    <p>算术运算符 &#43; 加 - 减 * 乘 / 除 % 取余（相除后的余数） ** 取幂（注意 ^ 并不执行该运算，你可能在其他语言中见过这种情形） // 相除后向下取整到最接近的整数 整数、浮点数 数字值可以用到两种 python 数据类型：
int - 表示整数值 float - 表示小数或浮点数值 你可以通过以下语法创建具有某个数据类型的值：
x = int(4.7) # x is now an integer 4 y = float(4) # y is now a float of 4.0 你可以使用函数 type 检查数据类型：
&gt;&gt;&gt; print(type(x)) int &gt;&gt;&gt; print(type(y)) float 布尔型运算符、比较运算符和逻辑运算符 布尔数据类型存储的是值 True 或 False，通常分别表示为 1 或 0。
通常有 6 个比较运算符会获得布尔值：
比较运算符 符号使用情况...</p>
  </div>
  <footer class="entry-footer"><span title='2018-06-25 09:26:05 +0000 UTC'>June 25, 2018</span></footer>
  <a class="entry-link" aria-label="post link to Python数据类型与操作符" href="/posts/python-datatype/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Apache2-https安装教程
    </h2>
  </header>
  <div class="entry-content">
    <p>环境 CentOS Linux release 7.5.1804 Apache/2.4.6 (CentOS) root用户 前言 首先我们需要建立vhost文件，在目前的环境中安装的Apache会自动把目录为/etc/httpd/conf.d下的所有*.conf文件引入到配置文件/etc/httpd/conf/httpd.conf中加载，所以我们只需要在/etc/httpd/conf.d目录下配置我们的虚拟主机文件。
免费的证书我们可以通过证书授权机构Let’s Encrypt 获取，并且我们可以通过Certbot（由Let’s Encrypt推出的获取证书的客户端 ）进行生成证书，Certbot提供了几种方式进行生产，我们选择最简单的方式certbot-auto来进行自动配置
0x0001 通过编辑器编辑vhost文件
vim /etc/httpd/conf.d/vhost.conf 添加以下的内容，括号及括号内的内容自行去掉
&lt;VirtualHost *:80&gt; ServerAdmin XXX@xxx.cn(邮箱) directoryIndex index.html index.php index.htm ServerName XXXX.com(域名) DocumentRoot /www/web(网站目录) &lt;Directory &#34;/www/web(网站目录)&#34;&gt; Options -Indexes AllowOverride All Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; 添加完内容后进行保存，并且我们用下面的命令来检查配置文件的语法是否有错误
httpd -t 如果测试是没有问题的，此时我们就可以重启服务器让配置文件生效
systemctl restart httpd 0x0002 这一步我们进行配置https，我们这里使用的是文章最开始提到的自动安装脚本，其他的安装方式以及如果文章离你查看的时间比较久远，建议你参照Certbot官方进行配置。
首先下载Certbot到当前目录下，并让Certbot具有执行权限
wget https://dl.eff.org/certbot-auto chmod a&#43;x certbot-auto 执行当前目录下的certbot-auto，然后跟着提示操作就可以执行了
certbot-auto --apache 0X0003 我们可以通过renew进行查看证书的有效期，还可以通过renew --dry-run命令来更新证书，如果你需要自动更新可以参照官网或者其他脚本程序来进行实现也是没有任何问题的
certbot-auto renew 查看证书有效期 certbot-auto renew --dry-run 更新证书有效期 </p>
  </div>
  <footer class="entry-footer"><span title='2018-06-25 03:46:41 +0000 UTC'>June 25, 2018</span></footer>
  <a class="entry-link" aria-label="post link to Apache2-https安装教程" href="/posts/apache2-https/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python生成器
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是生成器(generator)？ 在Python中提供了一种名为generator的对象，他是通过next函数去中断执行并且generator对象具有Iterable对象，也就是说可以用于for循环，generator最大的作用是按需生成值，这个是什么意思呢？当我们需要一组元素很多的列表的时候会占用很大的内存，比如你需要生成一组从0-100000的列表，那么这个列表的长度将有10万，这是多么大的列表？如果比这个数值更大呢？那么很大一部分内存都将用来保存这个列表。
list(range(100000)) 类似于上面这样的情况，我们可以用generator对象来按需生成数值来供我们处理，你可以把generator对象理解为一种状态机，里面保存着每次执行后的状态而并不是一次性的生成所有的值，我们就相当于导演，generator对象就像一个演员，我们叫他cut的时候，他就会停止，这样的好处就是一次性只返回一个或少量的值，不会一次性大量生成所有的值而导致内存的紧缺。
生成器(generator)函数 生成器函数和普通函数很相似，为什么？因为你看见一个函数内部只要出现yield标识符，那么这个函数肯定就是generator对象函数，比如下面的代码：
#普通函数 def ad(a,b): return a &#43; b #generator函数 def ad(a,b): yield a &#43; b return None 但是他们的执行过程却不一样，普通函数调用过后就马上执行内部的代码并返回，而generator对象函数却是保存了内部的状态，等待你需要的时候再去执行，而执行我们通过next函数去调用并且在内部执行的时候遇见了下一个yield标识符就会停止执行并返回yield标识符后面的值。
#普通函数 def ad(a,b): return a &#43; b #generator函数 def ad(a,b): yield a &#43; b return None #普通函数执行 ad(1,5) #6 b = ad(1,5) #此时保存了状态 next(b) #6 通过next函数调用generator函数执行 生成器(generator)表达式 生成器表达式和列表表达式很像，但是有一点不同的是列表表达式由[]组成，而生成器表达式由()组成，就像下面的代码一样：
l = [x * x for x in range(5)] #列表表达式 g = (x * x for x in range(5)) #生成器表达式 generator对象是需要通过next函数调用执行，并且返回的值是按循环生成的每个元素，我们每次用next执行我们的generator对象后，generator对象会保存执行后的状态，直到没有元素或者遇见return语句后抛出一个StopIteration错误来表示已经执行完毕，下面的代码是通过手动执行generator对象和通过for自动执行。...</p>
  </div>
  <footer class="entry-footer"><span title='2018-06-04 08:29:36 +0000 UTC'>June 4, 2018</span></footer>
  <a class="entry-link" aria-label="post link to Python生成器" href="/posts/python-generator/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Python 列表生成表达式
    </h2>
  </header>
  <div class="entry-content">
    <p>如何生成列表？ 先试想一下，如果你需要生成1-50的数值列表，如果没有列表生成式你将会这样来做：
x = [] i = 1 while i &lt;= 50: x.append(i) i &#43;= 1 还有一种方法就是通过range函数生成整数数列，然后通过list函数生成一个列表返回，大概操作如下：
list(range(0,50)) 当然range函数提供了第三个参数，用于设置步数，你可以理解为间隔数，比如我只需要返回0-50中的偶尔，那么我用range生成的数列需要每隔两个数生成一个：
list(range(0,50,2)) 列表生成表达式 列表生成式是Python内置的’列表’生成器，那列表生成表达式有什么用？首先我们尝试解决上面的第一个问题：
[x for x in range(0,50)] 那如果要生成0-50每个数的乘积怎么做？可以像下面的代码一样来做：
[x * x for x in range(0,50)] 那如果要生成0-50的数列，但是在其中40数值不需要生成，就可以在表达式中使用判断：
[x for x in range(0,50) if x != 40] 这种使用方法也是最常用的，其他的多层循环不去说明，因为多层循环在表达式中使用，结构化并不清晰，容易造成歧义。
现在我们大概看出来了列表生成表达式的使用方法，整理一下可以大概理解为：
[x for x in range(0,50) if x != 50] [生成的值 可迭代对象 条件语句] 可迭代对象 什么是可迭代对象？你可以直接理解为可用于for循环的对象都可以叫为可迭代对象，那我们怎么知道哪些对象是可以迭代的？我们可以通过isinstance检查目前的集合类型的数据是否具有collections模块中Iterable对象，如果有那么就可以进行迭代：
from collections import Iterable isinstance([], Iterable) # True isinstance({}, Iterable) #True isinstance(100, Iterable) #false 从上面看字典也是可以进行迭代的，下面的代码就是列表表达式对字典进行处理生成列表，并将首字母更改为大写，并且下面是在列表生成表达式中产生了两个变量。...</p>
  </div>
  <footer class="entry-footer"><span title='2018-06-04 02:45:42 +0000 UTC'>June 4, 2018</span></footer>
  <a class="entry-link" aria-label="post link to Python 列表生成表达式" href="/posts/python-list-render/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="/posts/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="/posts/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="">Yizhou</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
