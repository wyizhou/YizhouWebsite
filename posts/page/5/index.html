<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Yizhou</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Yizhou">
<meta name="author" content="">
<link rel="canonical" href="https://wuyizhou.com/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a8f329a89028c2356cb4f3650b14732202f51894615d7b3cfa1c3da20473eba1.css" integrity="sha256-qPMpqJAowjVstPNlCxRzIgL1GJRhXXs8&#43;hw9ogRz66E=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://wuyizhou.com/images/favicon.ico">

<link rel="apple-touch-icon" href="https://wuyizhou.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://wuyizhou.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://wuyizhou.com/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" /><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://wuyizhou.com/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://wuyizhou.com/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wuyizhou.com" accesskey="h" title="Yizhou (Alt + H)">Yizhou</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wuyizhou.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb GridFS
    </h2>
  </header>
  <div class="entry-content">
    <p>参考 MongoDB权威指南(第2版)
Mongodb Docs
前言 Mongodb提供了一个轻量级的文件系统来专门处理超过16MB的文件，这个文件系统叫GridFS，它的使用非常简单，几乎所有的Mongodb驱动程序都提供了GridFS API。GridFS将集合放在一个共享的储存区域，GridFS使用两个集合来存储我们存放的数据：
fs.files：这个集合当中的每一个文档都表示一个文件的信息 fs.chunks：这个集合中存放实际的数据内容 GridFS存储的文件无法进行修改，如果要进行修改只能删除修改的文档，然后再将修改完的文档重新保存。
下面讲一下如何使用Mongodb提供的mongodfiles客户端来操作GridFS数据：
mongofiles &lt;options&gt; &lt;commands&gt; &lt;filename&gt; mongofiles命令的组成部分是：
options:您可以使用一个或多个这些选项来控制其行为mongofiles。 commands:使用这些命令之一来确定动作mongofiles。 filename:本地文件系统上的一个文件的名称，也可以是一个GridFS对象。 mongodfiles默认链接到本地127.0.0.1:27017的数据库上面，如果需要指定数据库和地址需要像下面这样来，然后后面根着需要执行的命令。
mongofiles --host 127.0.0.1 -p 27017 需要执行的命令 常用的命令有四个：
list：列出数据库GridFS中的文件 put：将文件系统中的文件上传到GridFS get：用于将GridFS中的文件下载到文件系统中 search：用于搜索GridFS系统中的文件 delete：用于删除GridFS系统中的文件 比如我将一个含有文本xsscript的txt文件上传到GridFS中：
$ echo &#34;xsscript&#34; &gt; t.txt $ ./mongofiles put t.txt connected to: localhost added file: t.txt 搜索文件：
$ ./mongofiles list 2017-08-09T16:18:06.985&#43;0800 connected to: localhost t.txt 9 $ ./mongofiles search t 2017-08-09T16:21:42.994&#43;0800 connected to: localhost t.txt 9 下载文件到当前文件系统中：
$ ....</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-09 08:27:12 +0000 UTC'>August 9, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb GridFS" href="https://wuyizhou.com/posts/mongodb-gridfs/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb特殊索引和集合
    </h2>
  </header>
  <div class="entry-content">
    <p>参考 MongoDB权威指南(第2版)
Mongodb Docs
特殊集合 封顶集合 封顶集合和普通集合不一样，普通集合的大小是可以随着数据的增加而增加的，封顶集合是在创建的时候就已经设置了集合的大小。
封顶集合的大小已经满了后，当再次插入数据的时候，它会把最老的数据丢掉，然后写入新数据，封顶集合不难看出很适合当log型数据库。
创建封顶集合 创建封顶集合我们需要显式的创建集合，因为需要在显式创建的方法中设置一些选项，同时我们需要在选项中设置两个选项capped和size。
db.createCollection(&#39;test&#39;, { capped: true, size: 10485760 }) 上面的代码中capped设置为true代表创建的文档是一个封顶文档，而设置了capped为true后，必须指定size选项，size选项是指定的固定集合的大小，单位为字节(Byte)。
除此这两个设置外，还可以指定max选项，设置它过后，可以控制总体文档的数量，如果超过设置的数量，就把最老的数据丢掉，写入新数据。
db.createCollection(&#39;test&#39;, { capped: true, size: 10485760, max: 5000 }) 上面的代码设置了三个选项，其中一个表示创建封顶集合，一个是封顶集合的大小，还有一个是封顶集合的最大文档数量。集合的大小和集合的文档数量，只要其中一个条件满足都会从最老的数据位置开始覆盖写入。
需要注意的是封顶集合一旦创建就不能在改变，只有通过删除此集合然后在新建。
封顶集合的自然排序是由旧到新的，如果我们需要由新到旧的顺序查询我们的文档，我们可以通过下面的代码来执行：
db.test.find({}).sort({$natural: -1}); 文档验证集合 我们在创建集合的时候可以通过设置一个或多个键的值验证机制，这样当写入数据的时候，Mongodb会进行验证，如果通过则写入，如果没有通过则抛出错误，设置验证文档通过validator选项，它接受一个对象，在里面可以使用元操作符$。
比如下面的代码我设置了一个文档必须设置一个name值，并且值必须为String类型：
db.createCollection(&#39;blog&#39;, { validator: { name: { $type: &#39;string&#39; } } }); 然后我们试着插入一个带name的文档但值为数值和插入一个带name的文档值为字符串类型。
&gt; db.blog.insert({name: 123, age: 18}) WriteResult({ &#34;nInserted&#34; : 0, &#34;writeError&#34; : { &#34;code&#34; : 121, &#34;errmsg&#34; : &#34;Document failed validation&#34; } }) 从上面的返回中可以看到错误消息提示的是文档验证失败，而我们试着插入一个合法的数据看看返回的是什么：...</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-09 07:43:18 +0000 UTC'>August 9, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb特殊索引和集合" href="https://wuyizhou.com/posts/mongodb-special-collection-index/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb索引
    </h2>
  </header>
  <div class="entry-content">
    <p>参考 MongoDB权威指南(第2版)
Mongodb Docs
前言 建立索引对于任何需要提高查询速度的数据库来说都非常重要，那么索引究竟是一个什么？首先来看看下面是《区块链:技术驱动金融》这本书的前两章的目录。
第1章密码学及加密货币概述----------1 1.1密码学哈希函数----------4 1.2哈希指针及数据结构----------14 1.3数字签名----------19 1.4公钥即身份----------24 1.5两种简单的加密货币----------26 第2章比特币如何做到去中心化----------35 2.1中心化与去中心化----------37 2.2分布式共识----------39 2.3使用区块链达成没有身份的共识----------44 2.4奖励机制与工作量证明----------51 2.5总结----------59 通过目录，我们能很快很清楚的知道这本书写了什么，而我们也能很快从中查找到我们感兴趣的内容在哪一页，如果没有目录，我们将会一篇一篇的去翻阅我们想了解的内容，而索引可以比作数据库的目录。
效率 explain()是官方提供的一个用于返回当前查询过程信息的一个方法，通过这个命令，我们可以知道查询的过程，以便于我们进行优化，explain()支持这些操作的过程查询：
aggregate() count() distinct() find() group() remove() update() explain()方法接受三种可选字符串作为参数和两种布尔值，官方是这样来介绍的：
可选的。指定说明输出的详细程度模式。该模式会影响explain()返回信息的数量和行为。可能的模式有：“queryPlanner”， “executionStats”，和&#34;allPlansExecution&#34;。 默认模式是&#34;queryPlanner&#34;。 为了向后兼容早期版本 cursor.explain()，MongoDB解释true为 “allPlansExecution&#34;和false “queryPlanner”。 aggregate()忽略verbosity参数并在queryPlanner模式下执行。
首先我们插入100000条数据，可以通过下面代码来循环插入：
for(var i = 0; i &lt; 100000; i&#43;&#43;) { db.test.insert({ id: i, username: &#39;user&#39; &#43; i }); } 然后我们通过explain()方法看看查询含有username:user108键值的文档过程：
db.test.find({username: &#39;user108&#39;}).explain(true); 返回的结果大概为：
{ &#34;queryPlanner&#34; : { &#34;plannerVersion&#34; : 1, &#34;namespace&#34; : &#34;blog.test&#34;, &#34;indexFilterSet&#34; : false, &#34;parsedQuery&#34; : { &#34;username&#34; : { &#34;$eq&#34; : &#34;user4&#34; } }, &#34;winningPlan&#34; : { &#34;stage&#34; : &#34;COLLSCAN&#34;, &#34;filter&#34; : { &#34;username&#34; : { &#34;$eq&#34; : &#34;user4&#34; } }, &#34;direction&#34; : &#34;forward&#34; }, &#34;rejectedPlans&#34; : [ ] }, &#34;executionStats&#34; : { &#34;executionSuccess&#34; : true, &#34;nReturned&#34; : 1, &#34;executionTimeMillis&#34; : 48, &#34;totalKeysExamined&#34; : 0, &#34;totalDocsExamined&#34; : 100000, &#34;executionStages&#34; : { &#34;stage&#34; : &#34;COLLSCAN&#34;, &#34;filter&#34; : { &#34;username&#34; : { &#34;$eq&#34; : &#34;user4&#34; } }, &#34;nReturned&#34; : 1, &#34;executionTimeMillisEstimate&#34; : 37, &#34;works&#34; : 100002, &#34;advanced&#34; : 1, &#34;needTime&#34; : 100000, &#34;needYield&#34; : 0, &#34;saveState&#34; : 782, &#34;restoreState&#34; : 782, &#34;isEOF&#34; : 1, &#34;invalidates&#34; : 0, &#34;direction&#34; : &#34;forward&#34;, &#34;docsExamined&#34; : 100000 }, &#34;allPlansExecution&#34; : [ ] }, &#34;serverInfo&#34; : { &#34;host&#34; : &#34;YizhoudeMacBook-Pro....</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-08 12:28:45 +0000 UTC'>August 8, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb索引" href="https://wuyizhou.com/posts/mongodb-index/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb查询
    </h2>
  </header>
  <div class="entry-content">
    <p>参考 MongoDB权威指南(第2版)
Mongodb Documentation
前言 在Mongodb中查询的方法常用的有两个find和findOne，前者返回所有匹配的文档，而后者返回匹配的第一个文档，它的用法很简单。第一个是它的查询条件，第二个是指定返回文档中字段的过滤器，这个的作用也就是说你想显示哪些字段或者你想不显示哪些字段。并且该方法返回的是一个Cursor对象。
需要注意的是，find方法查询的时候会查询数组的成员是否符合查询条件，如果查询条件符合，将会把整个数组返回。
db.collection.find(query, projection) 比如下面通过find语句，查询blog集合中作者为xsscript的文档，并且只返回作者和文章内容。
db.blog.find({author: &#39;xsscript&#39;}, {author: 1, content: 1}); 在过滤器中，你如果没有显示的声明不返回_id键，默认都会返回，除非显示的声明_id: 0。还有比如在过滤器中设置了auther: 1，那么只会返回_id和auther两个键值，如果你只需要过滤一些不希望显示的值，那么就在过滤器中设置你需要不显示的键并把值设为0，这样文档中所有的值除了你设置不返回的都会返回。
如果你需要查询多个值匹配的文档，你可以像下面代码所示，把你需要的条件都写在第一个参数对象中，这样的查询其实是AND查询，下面的代码查询了集合中所有文档中作者是xsscript,时间为20170701，并且只返回作者、时间、内容，其中_id不显示。
db.blog.find({author: &#39;xsscript&#39;, time: 20170701},{ author: 1, content: 1, time: 1, _id: 0 }) 条件查询 一个键可以存在多个条件
比较操作符 $lt、$lte、gt、gte这四个比较查询符分别表示&lt;、&lt;=、&gt;、&gt;=，可以将其比较查询符组合起来查询，这个代码对于范围查询的筛选非常有用。比如我需要查询年龄大于17岁到25岁之间的文档，代码如下面所示：
db.test.find({ age: { $gt: 18, $lte: 25 } }); 包含查询操作符 $in操作符是多个条件针对一个键的值进行匹配，比如我需要查询年龄在18、20、25、30的文档，就可以使用$in操作符：
db.test.find({ age: { $in: [18, 20, 25, 30] } }); $or操作符是多个条件匹配多个键值，它非常有用，就有点类似于JS中的||符号，比如我需要查询一个文档中含有age: 18或者含有name: joe的文档，就可以使用$or操作符，比如下面的代码
db.test.find({ $or: [ {age: 18}, {name: &#39;joe&#39;} ] }) 对应$in和$or操作符的还有一个反义的即$nin和$nor操作符，后两个操作符的意思是返回不包含查询条件匹配到的所有文档，但是注意，如果在使用后者的两个操作符进行查询的话，会存在一个问题需要注意，比如下面...</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-04 08:07:53 +0000 UTC'>August 4, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb查询" href="https://wuyizhou.com/posts/mongodb-find/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb更新修改器
    </h2>
  </header>
  <div class="entry-content">
    <p>参考 MongoDB权威指南(第2版)
前言 在Mongodb中我们使用的是update方法去更新我们需要更新的文档，比如下面的一个文档结构：
{ a: 1, b: 2, c: 3 } 我们想通过update方法来更新里面的键值对a: 1为a: 2，或者是只对文档里面的一个键的值进行更改，按照代码所示我们会像下面这样来写代码：
db.test.update({ a: 1 },{ a: 2 }); 但是真的如我们所示吗？其实结果并不是我们想要的，上面的代码执行后，其实文档更新后的结果为：
{ a: 2 } 上面的执行代码覆盖了我们整个文档，当然这不是我们想要的结果。如果想要达到我们理想的结果，我们需要使用Mongodb提供的更新修改器(Update Modifier)。
一个键只能存在一个更新修改器
$inc修改器 $inc修改器主要是增对指定键的值进行增加值，$inc修改器是能操作数值类型值，这个修改器非常有用。比如下面，通过$inc修改器来计数访问统计。
文档：
{ title: &#39;analytics&#39;, analyticsCount: 1 } 代码：
db.blog.update({ title: &#39;analytics&#39; },{ $inc: { analyticsCount: 1 //这里代表的是给analyticsCount键的值增加1 } }); 执行代码后文档为：
{ title: &#39;analytics&#39;, analyticsCount: 2 } $set修改器 和 $unset修改器 $set修改器的作用是重写一个键的值，注意这里是重写这个键的值，并不是增加。如果没有这个键则添加并设置值，比如给下面的文档添加一个page键并设置值为’index’。
文档
{ title: &#39;analytics&#39;, analyticsCount: 1 } 代码...</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-03 07:45:26 +0000 UTC'>August 3, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb更新修改器" href="https://wuyizhou.com/posts/mongodb-update-modifier/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb Shell
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 在前一章文章中提到了Mongodb提供了一个Javascript运行环境，这个运行环境我们通过mongo或者mongo.exe打开，这是一个独立的Mongodb客户端，打开它后会自动连接上本地端口为27017的数据库。
如果你需要远程连接到其他数据库或者通过另外端口进行连接，可以通过--host xxxx来设置远程数据库的地址和通过--port来改变默认连接端口。
运行mongod 打开mongo后会默认连接到test数据库，就像下图：
在这个环境中我们可以使用Javascript的语法、原生方法、还可以编写函数来处理数据库，除此之外，这个Shell环境中还提供了Mongodb的一些操作语法，比如db,show dbs,show collections,insert等。下图显示了在Shell环境中运行Javascript代码以及一些常用的原生方法。
需要注意Shell会检查Javascript代码是否完整，如果没有写完可以在下一行继续写，但是如果在写代码的过程中发现出现了问题需要取消，按三次回车键就可以取消当前语句执行。比如下图中我定义了一个变量c，但是没有赋值，我连续按三次回车键取消当前语句执行，当我再次使用变量c的时候提示c is not defined。
简单的语句 在使用Shell环境的时候会用到几个简单的语句，其他的语句后面会慢慢的讲解。
db: db是一个全局变量，记录着当前所在的数据库名 show dbs: 列出当前连接的所有数据库名 use xxx: use语句后面跟一个数据库名称，可以改变当前所在的数据库 show collections: 显示当前数据库中所有的集合
这里需要注意的是db变量是一个对象，里面包含这个数据库的信息，当我们直接输入db的时候，实际上返回的是db._name这个属性的值，而这个属性是保存着当前数据库名，下图是返回一个db变量的遍历信息：
在Javascript中我们可以通过以下方式来获取对象的属性：
var a = { b: 2 } a.b; 那既然Shell是Mongodb提供的一个Javascript Shell，那么我们同样可以用这样的方式来访问集合，比如像下面这样
db.test 基本操作 上面一个章节说了可以通过.符号来访问对象的属性，那么通过这样的方式访问集合，而返回的同样是一个对象，这个对象本身包含了一些当前集合的信息，我们可以通过Obejct.getOwnPropertyNames(db.test)来遍历自身的属性名:
db对象和返回的集合对象继承了很多Mongodb提供的方法，我们可以通过db.help()和db.test.help()方法来查看可以使用的一些数据库操作方法。
insert方法 Mongodb给集合返回的对象提供了insert方法，以便给当前集合插入数据，insert接受一个对象作为参数。
db.test.insert({ a:1, b:2 }); find方法 Mongodb给集合返回的对象提供了find方法，以便对于当前集合进行搜索文档，find接受一个对象作为参数，这个对象包含你要查询的条件。
db.test.find({a:1}); //查询所有文档含有键值为a:1的文档，并返回符合的所有文档 db.test.find({a.b:1}); //查询所有文档含有子健b的a键并且值等于1，并返回符合的所有文档 db.test.findOne({a:1}); //查询所有文档含有键值为a:1的文档，并返回符合的第一个文档 update方法 Mongodb给集合返回的对象提供了update方法，用于更新(修改)符合查询条件的文档，update接受两个参数，第一个是查询需要更新文档的条件，第二个参数是需要更新的内容。
db.test.update({a: 1}, {a: 2}); //查询所有文档中键值为a:1的文档，并修改为为a:2 remove方法 Mongodb给集合返回的对象提供了remove方法，用于删除符合查询条件的文档。接受一个参数，这个参数为一个参数条件
db.test.remove({a:1}); //查询所有文档中含有键值为a:1的文档，并删除 执行脚本 前言 Mongodb执行外部JS文件首先会查找JS文件，如果没有指定一个绝对路径的JS文件，那么它会查找shell的执行目录。...</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-02 11:48:04 +0000 UTC'>August 2, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb Shell" href="https://wuyizhou.com/posts/mongodb-shell/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mongodb基础知识
    </h2>
  </header>
  <div class="entry-content">
    <p>参考 MongoDB权威指南(第2版)
前言 Mongodb是一种面向文档的数据库，并非关系型数据库(如Mysql等)，Mongodb的出现也让前端后端更加的统一，因为它的数据结构非常类似于Javascript中的对象。比如说下面，在Javascript中代表对象，在Mongodb中代表的就是一个文档。
{ a: 1, b: 2 } 如果我们全栈都是使用的Javascript(Javascript&#43;Nodejs&#43;Mongodb)那么将更加提高我们的便利以及统一性。
如果你之前使用的是Mysql等关系型数据库，那么可能需要对Mongodb数据库的观念要有所改变，在Mongodb中没有行和列，取而代之的是文档。在Mongodb中也没有表的存在，取而代之的是集合。
每一个文档都有一个_id用于表示这个文档的唯一性，并且Mongodb提供了一个Javascript Shell，我们可以通过Javascript语法来管理操作等方式来控制数据库，这也为我们的全栈更大一步的增加了统一性。
数据库(Database) 在一个数据库中是可以存在多个集合，
集合(Collection) 相当关系型数据库中的表。
文档(Document) 在Javascript中，一个对象的值可以是一个对象、数组、基本值、函数等。当然这也可以用在文档上。比如下面的一个结构，是一个完全合法的文档结构
{ a: { b: 1 c: [1,2,3] }, d: 1 } Mongodb区分类型，也通用区分大小写，比如下面是两个不同的文档
{&#39;a&#39;: 1} {&#39;A&#39;: 1} 命名规则 集合 集合使用名称来进行识别，但是集合名应该避免下列的情况：
不能是空字符串 不能包含(空字符)，因为在Mongodb中表示为集合名结束 不能以system开头，因为这是系统保留的前缀，比如system.users这个集合保存着数据库的用户信息，而system.namespaces集合保存着数据库中所有集合的信息。 避免使用$，因为系统生成的集合当中很多包含有$字符串，所以你应当避免。 数据库 数据库使用名称来进行识别，但是集合名应该避免下列的情况：
不能是空字符串 不能使用特殊符号 ,/,.,*等符号，尽量使用由字母和数字组成的字符串。 数据库名区分大小写 数据库名最多为64字节 有三个系统的数据库，如admin,local,config。应避免这三个名称当作你的数据库名 启动Mongodb 你可以通过Mongodb官方网站来下载Mongodb，如果你是windows，可能会安装得到一个安装包，安装完成后你就可以直接在CMD命令行通过mongod来启动Mongodb。如果是*inux系统，下载了Mongodb后得到解压包解压后直接运行当前目录的mongod就可以启动Mongodb。
这里需要注意的是需要通过参数--dbpath来指定Mongodb数据库的位置，如果没有指定，那么Mongodb会默认目录/data/db，windows为c:/data/db。
默认情况下Mongodb会以27017端口为默认端口，并且给当前端口提供了一个http服务器，你用浏览器打开，它会提示你下图的信息。
如果你需要通过http端口来获取一些Mongodb的状态信息，那么你需要增加一个参数--httpinterface来打开http接口，这个http一般会比监听的数据库端口大1000。比如27017是数据库默认监听借口，那么http服务的端口为28017。你用浏览器打开这个页面，就会出现如下图
如果你需要一些命令操作，比如列举一些信息，那么你还需要增加--rest参数。
文完</p>
  </div>
  <footer class="entry-footer"><span title='2017-08-01 15:36:33 +0000 UTC'>August 1, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mongodb基础知识" href="https://wuyizhou.com/posts/mongodb/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Mac软件推荐-Mounty
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 在Mac上面访问NTFS格式的移动设备或者分区很简单，但是如果你要对NTFS进行写操作，就得使用其他的方式，比如打开Mac自身支持NTFS的读写 、购买付费软件NTFS For Mac 、Paragon NTFS等，还或者通过免费软件，比如下面要介绍的一款Mounty。
通过终端工具等系统命令操作很麻烦，特别是对不懂命令行的人来说更加头疼。如果是付费软件那么你就得支持一笔费用，此费用还不小，每当Macos或者付费软件版本大更新的时候就会进行一次更新，那这次更新当然不是免费的，你还得付费这次的升级费用。
我找了很多个免费的NTFS读写工具，终于找到了一款非常满意的NTFS读写工具并且支持中文，但是存在一些小问题，可能不该叫它工具，该叫App。如果你觉得好用，我非常赞同你支持开发者捐赠费用，通过下图所标记的地方进行捐赠
使用 Mounty是一个完全免费的App，通过Mounty的官方网站下载，你可以在右侧的Get: Click to install栏目找到下载方式。
下面后是一个DMG文件，双击打开它，你就会看到它只是一个App，把它拖移到Applications下面
然后在你的Launchpad找到它并打开它，打开过后它没有单独的一个App界面，它会在你上方的工具栏中显示一个小图标，图标中有一个字母M，就如下图一样
如果你需要让Mounty每次启动，那么你需要点击图片弹出了一个菜单，你只需要点击开机时自启动，比如下图
打开Mounty后你就不需要做什么操作了，你只需要把你要读写的NTFS格式的设备插上你的电脑，它会自动监测。当我们插入U盘过后，它会提示你如下图中所示
如果你不需要写操作，只需要点击不用了,谢谢，如果你需要读写操作，点击是的，当然！就可以进行读写操作了。
BUG 在新的MacOS 10.12.5系统中会存在一些BUG
当我们要进行读写操作的时候，在MacOS自带的Finder资源管理器中，无法找到我们的移动设备，只能通过点击图标，有一个在Finder中显示，才能进行管理文件。并且卸载移动设备也只能通过点击图片卸载，如果只是读操作，那么在Finder中能找到此移动设备。
当我们插入U盘的时候能够识别移动设备的标识符，但是当我们选择读写操作的时候，那么在图标上无法显示移动设备标识符，就像下图一样，所以当我们插入多个移动设备的时候我们可能得挨个点击在Finder中显示来辨别哪个移动设备。目前已经有认给官方反应了，很快官方也会作出更新。
文完</p>
  </div>
  <footer class="entry-footer"><span title='2017-07-18 13:32:33 +0000 UTC'>July 18, 2017</span></footer>
  <a class="entry-link" aria-label="post link to Mac软件推荐-Mounty" href="https://wuyizhou.com/posts/mounty-software/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">ES6-Class类
    </h2>
  </header>
  <div class="entry-content">
    <p>书籍参考：《ECMAScript 6入门》 作者：阮一峰
文档参考：MDN
概念 ES6提供了Class语句用于更的理解语义以及更接近传统的编程语言的写法。Class可以当作ES5构造函数的一个语法糖。
传统的构造函数以及继承方法如下面这样来写的：
function Getname() { this.name = &#39;wyz&#39;; this.age = &#39;29&#39;; } // 如果我们需要定义一个给所有基于Getname构造函数使用的方法 // 那么我们必须通过prototype对象上定义 Getname.prototype.getName = function(){ return (`Name: ${this.name}, Age: ${this.age}`); } let gname = new Getname(); gname.getName(); //&#34;Name: wyz, Age: 29&#34; 通过上面的方法来创建一个“类”，对比其他语言是差距很大的，而且很难理解，ES6提供了一个新的语句Class来创建类。
class Getname{ constructor(){ this.name = &#39;wyz&#39;; this.age = &#39;29&#39;; } getName(){ return (`Name: ${this.name}, Age: ${this.age}`); } } let gname = new Getname(); gname.getName(); //&#34;Name: wyz, Age: 29&#34; 通过ES6的Class语句更能清晰的表达出类，这与传统的语言声明类很相似。在class中，constructor方法是一个构造函数，类似于我们构造函数中编写给实例初始化的一些属性方法，而在constructor之外定义的方法都是定义在原型上面的公用方法，这就很能理解为什么Class是构造函数的语法糖了。...</p>
  </div>
  <footer class="entry-footer"><span title='2017-07-18 07:46:51 +0000 UTC'>July 18, 2017</span></footer>
  <a class="entry-link" aria-label="post link to ES6-Class类" href="https://wuyizhou.com/posts/es6-class/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">ES7-async函数
    </h2>
  </header>
  <div class="entry-content">
    <p>参考文档：MDN
概念 ES7提供了一个异步解决方案async函数容易，它的作用非常简单，几个异步操作并且这几个是有依赖的，如果按照我们往常的使用方法有几种，下面是一个读取文件的例子，需要读取文件1-3.txt，首先看看callback的写法：
readFile(&#39;1.txt&#39;, (err, data) =&gt; { if(err) {return err} let data1 = data; readFile(&#39;2.txt&#39;, (err, data) =&gt; { if(err) {return err } let data2 = data; readFile(&#39;3.txt&#39;, (err, data) =&gt; { if(err) {return err} let data3 = data; return dataAll = data1.toString() &#43; data2.toString() &#43; data3.toString(); }); }); }); 从上面的代码看出来，这样的回调函数很难辨别，也很难理解，而且多个回调函数嵌套，编写代码的人员也过后回头看也会感觉到头疼，这就是我们常说的&#34;callback hell&#34;。下面还有一种Promise的写法：
var files1 = new Promise((resolve, reject) =&gt; { readFile(&#39;1.txt&#39;, (err, data) =&gt; { if(err) {return err} resolve(data); }); }); var files2 = new Promise((resolve, reject) =&gt; { readFile(&#39;2....</p>
  </div>
  <footer class="entry-footer"><span title='2017-07-17 09:53:10 +0000 UTC'>July 17, 2017</span></footer>
  <a class="entry-link" aria-label="post link to ES7-async函数" href="https://wuyizhou.com/posts/es7-async/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://wuyizhou.com/posts/page/4/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://wuyizhou.com/posts/page/6/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://wuyizhou.com">Yizhou</a></span>
    <span>
        <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
    </span>
    <span>
        Build: 2024-01-21 12:30:42
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
