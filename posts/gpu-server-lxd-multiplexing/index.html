<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>GPU服务器的多人环境搭建 | Yizhou</title>
<meta name="keywords" content="服务和运维">
<meta name="description" content="环境 CPU: Intel(R) Xeon(R) Gold 6154* 2
Momery: 128G GPU: 3080TI * 2
Disk: 16T HD &amp; 512 SSD
System: Ubuntu 22.04 Server
前言 因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。 在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于LXC容器，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。
准备 16T的机械盘，分为两个分区（分区可以使用fdisk），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的/data目录，后期映射到每个容器的/data目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置/data，即使容器出现了问题，也不会影响到数据的丢失问题。 显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入nvidia-smi，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。 使用apt安装zfsutils-linux，前者用于安装LXD的储存池驱动，LXD支持多种储存池，这用于储存LXD、LXC相关的数据。 使用apt安装bridge-utils，该工具是用于管理和创建网桥设备所需要的工具和程序。 初始化LXD 通过命令执行sudo lxd init，就会得到如下的问题：
LXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可 new storage pool：需要创建一个存储池，输入yes Name of storage pool：给存储池命名，默认为default，回车即可 storage backend：存储后端，默认使用zfs，回车即可 Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes use an existing block device：使用现有的块设备（硬盘），输入yes Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1 MAAS server：MAAS是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可 new local network bridge：是否创建一个新的桥接网络，输入yes new bridge be called：命名新的网桥名称，默认即可 IPv4：IPv4相关配置，默认为auto，回车即可 IPv6：IPv6相关配置，默认为auto，回车即可 would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可 would you like stale cached images to be updated automatically：默认yes，回车即可 YAML printed：是否打印出lxd init的配置信息，默认为no，回车即可 创建容器模板 创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的国内镜像用于提升下载镜像的速度。 添加清华大学镜像源：">
<meta name="author" content="">
<link rel="canonical" href="https://wuyizhou.com/posts/gpu-server-lxd-multiplexing/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://wuyizhou.com/images/favicon.ico">

<link rel="apple-touch-icon" href="https://wuyizhou.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://wuyizhou.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://wuyizhou.com/posts/gpu-server-lxd-multiplexing/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" /><meta property="og:title" content="GPU服务器的多人环境搭建" />
<meta property="og:description" content="环境 CPU: Intel(R) Xeon(R) Gold 6154* 2
Momery: 128G GPU: 3080TI * 2
Disk: 16T HD &amp; 512 SSD
System: Ubuntu 22.04 Server
前言 因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。 在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于LXC容器，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。
准备 16T的机械盘，分为两个分区（分区可以使用fdisk），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的/data目录，后期映射到每个容器的/data目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置/data，即使容器出现了问题，也不会影响到数据的丢失问题。 显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入nvidia-smi，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。 使用apt安装zfsutils-linux，前者用于安装LXD的储存池驱动，LXD支持多种储存池，这用于储存LXD、LXC相关的数据。 使用apt安装bridge-utils，该工具是用于管理和创建网桥设备所需要的工具和程序。 初始化LXD 通过命令执行sudo lxd init，就会得到如下的问题：
LXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可 new storage pool：需要创建一个存储池，输入yes Name of storage pool：给存储池命名，默认为default，回车即可 storage backend：存储后端，默认使用zfs，回车即可 Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes use an existing block device：使用现有的块设备（硬盘），输入yes Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1 MAAS server：MAAS是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可 new local network bridge：是否创建一个新的桥接网络，输入yes new bridge be called：命名新的网桥名称，默认即可 IPv4：IPv4相关配置，默认为auto，回车即可 IPv6：IPv6相关配置，默认为auto，回车即可 would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可 would you like stale cached images to be updated automatically：默认yes，回车即可 YAML printed：是否打印出lxd init的配置信息，默认为no，回车即可 创建容器模板 创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的国内镜像用于提升下载镜像的速度。 添加清华大学镜像源：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wuyizhou.com/posts/gpu-server-lxd-multiplexing/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-21T04:52:07+00:00" />
<meta property="article:modified_time" content="2022-10-21T04:52:07+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GPU服务器的多人环境搭建"/>
<meta name="twitter:description" content="环境 CPU: Intel(R) Xeon(R) Gold 6154* 2
Momery: 128G GPU: 3080TI * 2
Disk: 16T HD &amp; 512 SSD
System: Ubuntu 22.04 Server
前言 因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。 在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于LXC容器，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。
准备 16T的机械盘，分为两个分区（分区可以使用fdisk），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的/data目录，后期映射到每个容器的/data目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置/data，即使容器出现了问题，也不会影响到数据的丢失问题。 显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入nvidia-smi，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。 使用apt安装zfsutils-linux，前者用于安装LXD的储存池驱动，LXD支持多种储存池，这用于储存LXD、LXC相关的数据。 使用apt安装bridge-utils，该工具是用于管理和创建网桥设备所需要的工具和程序。 初始化LXD 通过命令执行sudo lxd init，就会得到如下的问题：
LXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可 new storage pool：需要创建一个存储池，输入yes Name of storage pool：给存储池命名，默认为default，回车即可 storage backend：存储后端，默认使用zfs，回车即可 Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes use an existing block device：使用现有的块设备（硬盘），输入yes Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1 MAAS server：MAAS是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可 new local network bridge：是否创建一个新的桥接网络，输入yes new bridge be called：命名新的网桥名称，默认即可 IPv4：IPv4相关配置，默认为auto，回车即可 IPv6：IPv6相关配置，默认为auto，回车即可 would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可 would you like stale cached images to be updated automatically：默认yes，回车即可 YAML printed：是否打印出lxd init的配置信息，默认为no，回车即可 创建容器模板 创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的国内镜像用于提升下载镜像的速度。 添加清华大学镜像源："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "New Posts",
      "item": "https://wuyizhou.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "GPU服务器的多人环境搭建",
      "item": "https://wuyizhou.com/posts/gpu-server-lxd-multiplexing/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GPU服务器的多人环境搭建",
  "name": "GPU服务器的多人环境搭建",
  "description": "环境 CPU: Intel(R) Xeon(R) Gold 6154* 2\nMomery: 128G GPU: 3080TI * 2\nDisk: 16T HD \u0026amp; 512 SSD\nSystem: Ubuntu 22.04 Server\n前言 因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。 在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于LXC容器，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。\n准备 16T的机械盘，分为两个分区（分区可以使用fdisk），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的/data目录，后期映射到每个容器的/data目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置/data，即使容器出现了问题，也不会影响到数据的丢失问题。 显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入nvidia-smi，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。 使用apt安装zfsutils-linux，前者用于安装LXD的储存池驱动，LXD支持多种储存池，这用于储存LXD、LXC相关的数据。 使用apt安装bridge-utils，该工具是用于管理和创建网桥设备所需要的工具和程序。 初始化LXD 通过命令执行sudo lxd init，就会得到如下的问题：\nLXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可 new storage pool：需要创建一个存储池，输入yes Name of storage pool：给存储池命名，默认为default，回车即可 storage backend：存储后端，默认使用zfs，回车即可 Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes use an existing block device：使用现有的块设备（硬盘），输入yes Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1 MAAS server：MAAS是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可 new local network bridge：是否创建一个新的桥接网络，输入yes new bridge be called：命名新的网桥名称，默认即可 IPv4：IPv4相关配置，默认为auto，回车即可 IPv6：IPv6相关配置，默认为auto，回车即可 would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可 would you like stale cached images to be updated automatically：默认yes，回车即可 YAML printed：是否打印出lxd init的配置信息，默认为no，回车即可 创建容器模板 创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的国内镜像用于提升下载镜像的速度。 添加清华大学镜像源：",
  "keywords": [
    "服务和运维"
  ],
  "articleBody": "环境 CPU: Intel(R) Xeon(R) Gold 6154* 2\nMomery: 128G GPU: 3080TI * 2\nDisk: 16T HD \u0026 512 SSD\nSystem: Ubuntu 22.04 Server\n前言 因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。 在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于LXC容器，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。\n准备 16T的机械盘，分为两个分区（分区可以使用fdisk），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的/data目录，后期映射到每个容器的/data目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置/data，即使容器出现了问题，也不会影响到数据的丢失问题。 显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入nvidia-smi，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。 使用apt安装zfsutils-linux，前者用于安装LXD的储存池驱动，LXD支持多种储存池，这用于储存LXD、LXC相关的数据。 使用apt安装bridge-utils，该工具是用于管理和创建网桥设备所需要的工具和程序。 初始化LXD 通过命令执行sudo lxd init，就会得到如下的问题：\nLXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可 new storage pool：需要创建一个存储池，输入yes Name of storage pool：给存储池命名，默认为default，回车即可 storage backend：存储后端，默认使用zfs，回车即可 Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes use an existing block device：使用现有的块设备（硬盘），输入yes Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1 MAAS server：MAAS是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可 new local network bridge：是否创建一个新的桥接网络，输入yes new bridge be called：命名新的网桥名称，默认即可 IPv4：IPv4相关配置，默认为auto，回车即可 IPv6：IPv6相关配置，默认为auto，回车即可 would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可 would you like stale cached images to be updated automatically：默认yes，回车即可 YAML printed：是否打印出lxd init的配置信息，默认为no，回车即可 创建容器模板 创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的国内镜像用于提升下载镜像的速度。 添加清华大学镜像源：\nsudo lxc remote add tuna-images https://mirrors.tuna.tsinghua.edu.cn/lxc-images/ --protocol=simplestreams --public 通过查找镜像列表，找到对应镜像的ID：\nsudo lxc image list tuna-images: | grep \"ubuntu/18\" 获取到列表后，选择对应的版本，这里我选择了id为2c44d2a68b29的ubuntu/18.04 (7 more)镜像，这是因为该版本标识了类型为容器CONTAINER。 确定好后远程的容器镜像id后，将其下载到本地并启动：\n# origin为源，这里使用上面添加的清华源，FINGERPRINT代表该源下载容器镜像id，ContainerName为创建的容器名称 sudo lxc launch origin: # 我这里直接使用 sudo lxc launch tuna-images:2c44d2a68b29 gpuTemplate 查看是否启动成功容器可以使用sudo lxc list。\n创建公共目录 在准备阶段中宿主机的/data目录已挂载好了15T的分区，需要将其添加到上面创建的容器中：\nsudo lxc config device add disk source= path= #实例： sudo lxc config device add gpuTemplate share_dir disk source=/data path=/data 容器配置 因为将该容器作为基础模板，所以需要配置一些常用的依赖以及切换为国内apt源。 通过以下命令进入到容器内部：\nsudo lxc exec bash 然后修改容器内部的apt源：\nvi /etc/apt/sources.list 然后将国内源写入该文件后，运行apt update更新列表即可。 安装vim、gcc、g++、make、cmake、python、lspci：\napt install vim gcc g++ make cmake python3.10 pciutils 安装Python后，将可执行文件放在/usr/bin/python3.10，所以直接需要将python3.10可执行文件软连接到当前目录为python，这样直接可以使用python命令。\nln -s /usr/bin/python3.10 /usr/bin/python 添加GPU设备到容器中 为容器添加所有GPU:\nsudo lxc config device add gpu gpu 添加指定GPU：\nsudo lxc config device add gpu0 gpu id=0 安装GPU驱动，网上教程中的GPU驱动安装比较麻烦，所以可以在宿主机中安装ubuntu-drivers：\napt install ubuntu-drivers-common 安装完成后使用以下命令，会得到显卡型号、推荐的显卡驱动：\nubuntu-drivers devices #返回 == /sys/devices/pci0000:3a/0000:3a:02.0/0000:3b:00.0 == modalias : pci:v000010DEd00002208sv000010DEsd00001535bc03sc00i00 vendor : NVIDIA Corporation model : GA102 [GeForce RTX 3080 Ti] manual_install: True driver : nvidia-driver-470-server - distro non-free driver : nvidia-driver-470 - distro non-free driver : nvidia-driver-515 - distro non-free driver : nvidia-driver-510 - distro non-free driver : nvidia-driver-510-server - distro non-free driver : nvidia-driver-515-open - distro non-free recommended driver : nvidia-driver-515-server - distro non-free driver : xserver-xorg-video-nouveau - distro free builtin 在这里我选择的是nvidia-driver-515-server版，然后进行到容器内部后，使用apt install nvidia-driver-515-server进行安装，安装完成后，你在容器内部使用nvidia-smi即可看见相关信息表示安装成功。 关于如果要特定的cuda版本则需要根据具体情况选择对应的显卡驱动。\n配置容器的远程登陆 安装ssh：\napt install openssh-server 安装完成后可以通过以下命令查看是否启动：\nsystemctl status sshd 配置完成后，可以找一台内网的机器通过ssh-keygen -t rsa生成非对称加密的密钥，然后将公钥的内容复制到容器内部/root/.ssh/authorized_keys文件中，保存退出，最后重启ssh服务：\nsystemctl restart sshd 配置完成后，回到宿主机中，设置端口映射，目的在于当宿主机接到的目标端口的请求的时候，将数据传输到指定端口的容器内部中，在这里配置的是sshd远程连接，所以容器接收的端口为22，宿主机的监听端口则是设置为6001，当宿主机的6001端口接到数据就转发给容器内部的22端口。 设置命令可以通过下面的代码设置：\nsudo lxc config device add proxy listen=tcp:: connect=tcp:: bind=host #这里我的设置为： sudo lxc config device add GPUTemplate testssh proxy listen=tcp:192.168.1.102:6001 connect=tcp:10.180.194.93:22 bind=host 如果后期要删除该条测试端口映射，则使用以下的命令：\n# 查看配置项目 sudo lxc config device list # 找到需要删除的端口别称，然后删除 sudo lxc config device remove 制作容器实例 制作容器实例实际上就是基于现有运行的实例进行复制一份，然后再做一点基础的修改就可以让他人使用。 复制容器：\nsudo lxc copy 复制后，需要手动启动\nsudo lxc start 复制完成后，可以按照上述的步骤设置使用者的ssh key和端口映射即可。\n参考文章 https://shenxiaohai.me/2018/12/03/gpu-server-lab/ https://linuxcontainers.org/lxd/introduction/ https://zh.wikipedia.org/wiki/LXC https://linuxcontainers.org/lxd/docs/master/explanation/storage/ https://linuxcontainers.org/lxd/docs/master/explanation/networks/ https://blog.csdn.net/zhw864680355/article/details/90411288 https://developer.nvidia.com/cuda-toolkit-archive https://www.cnblogs.com/booturbo/p/13960935.html https://pytorch.org/get-started/locally/ https://www.jianshu.com/p/978bc51029fa https://command-not-found.com/ubuntu-drivers https://www.myfreax.com/how-to-nvidia-drivers-on-ubuntu-20-04/ https://blog.csdn.net/Guzarish/article/details/118626384 https://blog.csdn.net/dou3516/article/details/120823932 https://developer.aliyun.com/article/971986 ",
  "wordCount" : "380",
  "inLanguage": "en",
  "datePublished": "2022-10-21T04:52:07Z",
  "dateModified": "2022-10-21T04:52:07Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://wuyizhou.com/posts/gpu-server-lxd-multiplexing/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Yizhou",
    "logo": {
      "@type": "ImageObject",
      "url": "https://wuyizhou.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wuyizhou.com/" accesskey="h" title="Yizhou (Alt + H)">Yizhou</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wuyizhou.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      GPU服务器的多人环境搭建
    </h1>
    <div class="post-meta"><span title='2022-10-21 04:52:07 +0000 UTC'>2022-10-21</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%8e%af%e5%a2%83" aria-label="环境">环境</a></li>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#%e5%87%86%e5%a4%87" aria-label="准备">准备</a></li>
                <li>
                    <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96lxd" aria-label="初始化LXD">初始化LXD</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%ae%b9%e5%99%a8%e6%a8%a1%e6%9d%bf" aria-label="创建容器模板">创建容器模板</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%85%ac%e5%85%b1%e7%9b%ae%e5%bd%95" aria-label="创建公共目录">创建公共目录</a></li>
                <li>
                    <a href="#%e5%ae%b9%e5%99%a8%e9%85%8d%e7%bd%ae" aria-label="容器配置">容器配置</a></li>
                <li>
                    <a href="#%e6%b7%bb%e5%8a%a0gpu%e8%ae%be%e5%a4%87%e5%88%b0%e5%ae%b9%e5%99%a8%e4%b8%ad" aria-label="添加GPU设备到容器中">添加GPU设备到容器中</a></li>
                <li>
                    <a href="#%e9%85%8d%e7%bd%ae%e5%ae%b9%e5%99%a8%e7%9a%84%e8%bf%9c%e7%a8%8b%e7%99%bb%e9%99%86" aria-label="配置容器的远程登陆">配置容器的远程登陆</a></li>
                <li>
                    <a href="#%e5%88%b6%e4%bd%9c%e5%ae%b9%e5%99%a8%e5%ae%9e%e4%be%8b" aria-label="制作容器实例">制作容器实例</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0" aria-label="参考文章">参考文章</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="环境">环境<a hidden class="anchor" aria-hidden="true" href="#环境">#</a></h2>
<p>CPU: Intel(R) Xeon(R) Gold 6154* 2</p>
<p>Momery: 128G GPU: 3080TI * 2</p>
<p>Disk: 16T HD &amp; 512 SSD</p>
<p>System: Ubuntu 22.04 Server</p>
<h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。 在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于<a href="https://zh.wikipedia.org/wiki/LXC">LXC容器</a>，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。</p>
<h2 id="准备">准备<a hidden class="anchor" aria-hidden="true" href="#准备">#</a></h2>
<ol>
<li>16T的机械盘，分为两个分区（分区可以使用<code>fdisk</code>），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的<code>/data</code>目录，后期映射到每个容器的<code>/data</code>目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置<code>/data</code>，即使容器出现了问题，也不会影响到数据的丢失问题。</li>
<li>显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入<code>nvidia-smi</code>，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。</li>
<li>使用<code>apt</code>安装<code>zfsutils-linux</code>，前者用于安装LXD的储存池驱动，LXD支持<a href="https://linuxcontainers.org/lxd/docs/master/explanation/storage/">多种储存池</a>，这用于储存LXD、LXC相关的数据。</li>
<li>使用<code>apt</code>安装<code>bridge-utils</code>，该工具是用于管理和创建网桥设备所需要的工具和程序。</li>
</ol>
<h2 id="初始化lxd">初始化LXD<a hidden class="anchor" aria-hidden="true" href="#初始化lxd">#</a></h2>
<p>通过命令执行<code>sudo lxd init</code>，就会得到如下的问题：</p>
<ul>
<li>LXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可</li>
<li>new storage pool：需要创建一个存储池，输入yes</li>
<li>Name of storage pool：给存储池命名，默认为default，回车即可</li>
<li>storage backend：存储后端，默认使用zfs，回车即可</li>
<li>Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes</li>
<li>use an existing block device：使用现有的块设备（硬盘），输入yes</li>
<li>Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1</li>
<li>MAAS server：<a href="https://maas.io/">MAAS</a>是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可</li>
<li>new local network bridge：是否创建一个新的桥接网络，输入yes</li>
<li>new bridge be called：命名新的网桥名称，默认即可</li>
<li>IPv4：IPv4相关配置，默认为auto，回车即可</li>
<li>IPv6：IPv6相关配置，默认为auto，回车即可</li>
<li>would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可</li>
<li>would you like stale cached images to be updated automatically：默认yes，回车即可</li>
<li>YAML printed：是否打印出<code>lxd init</code>的配置信息，默认为no，回车即可</li>
</ul>
<h2 id="创建容器模板">创建容器模板<a hidden class="anchor" aria-hidden="true" href="#创建容器模板">#</a></h2>
<p>创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的<a href="https://mirror.tuna.tsinghua.edu.cn/help/lxc-images/">国内镜像</a>用于提升下载镜像的速度。 添加清华大学镜像源：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc remote add tuna-images https://mirrors.tuna.tsinghua.edu.cn/lxc-images/ --protocol<span style="color:#f92672">=</span>simplestreams --public 
</span></span></code></pre></div><p>通过查找镜像列表，找到对应镜像的ID：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc image list tuna-images: | grep <span style="color:#e6db74">&#34;ubuntu/18&#34;</span> 
</span></span></code></pre></div><p>获取到列表后，选择对应的版本，这里我选择了id为<code>2c44d2a68b29</code>的ubuntu/18.04 (7 more)镜像，这是因为该版本标识了类型为容器<code>CONTAINER</code>。 确定好后远程的容器镜像id后，将其下载到本地并启动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># origin为源，这里使用上面添加的清华源，FINGERPRINT代表该源下载容器镜像id，ContainerName为创建的容器名称</span>
</span></span><span style="display:flex;"><span>sudo lxc launch origin:&lt;FINGERPRINT&gt; &lt;ContainerName&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 我这里直接使用</span>
</span></span><span style="display:flex;"><span>sudo lxc launch tuna-images:2c44d2a68b29 gpuTemplate 
</span></span></code></pre></div><p>查看是否启动成功容器可以使用<code>sudo lxc list</code>。</p>
<h2 id="创建公共目录">创建公共目录<a hidden class="anchor" aria-hidden="true" href="#创建公共目录">#</a></h2>
<p>在准备阶段中宿主机的<code>/data</code>目录已挂载好了15T的分区，需要将其添加到上面创建的容器中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc config device add &lt;ContainerName&gt; &lt;ShareName&gt; disk source<span style="color:#f92672">=</span>&lt;host_dir_path&gt; path<span style="color:#f92672">=</span>&lt;Container_dir_path&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#实例：</span>
</span></span><span style="display:flex;"><span>sudo lxc config device add gpuTemplate share_dir disk source<span style="color:#f92672">=</span>/data path<span style="color:#f92672">=</span>/data 
</span></span></code></pre></div><h2 id="容器配置">容器配置<a hidden class="anchor" aria-hidden="true" href="#容器配置">#</a></h2>
<p>因为将该容器作为基础模板，所以需要配置一些常用的依赖以及切换为国内apt源。 通过以下命令进入到容器内部：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc exec &lt;ContainerName&gt; bash 
</span></span></code></pre></div><p>然后修改容器内部的apt源：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vi /etc/apt/sources.list 
</span></span></code></pre></div><p>然后将国内源写入该文件后，运行<code>apt update</code>更新列表即可。 安装<code>vim</code>、<code>gcc</code>、<code>g++</code>、<code>make</code>、<code>cmake</code>、<code>python</code>、<code>lspci</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt install vim gcc g++ make cmake python3.10 pciutils 
</span></span></code></pre></div><p>安装Python后，将可执行文件放在<code>/usr/bin/python3.10</code>，所以直接需要将python3.10可执行文件软连接到当前目录为<code>python</code>，这样直接可以使用<code>python</code>命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ln -s /usr/bin/python3.10 /usr/bin/python 
</span></span></code></pre></div><h2 id="添加gpu设备到容器中">添加GPU设备到容器中<a hidden class="anchor" aria-hidden="true" href="#添加gpu设备到容器中">#</a></h2>
<p>为容器添加所有GPU:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc config device add &lt;ContainerName&gt; gpu gpu 
</span></span></code></pre></div><p>添加指定GPU：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc config device add &lt;ContainerName&gt; gpu0 gpu id<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> 
</span></span></code></pre></div><p>安装GPU驱动，网上教程中的GPU驱动安装比较麻烦，所以可以在宿主机中安装<code>ubuntu-drivers</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt install ubuntu-drivers-common 
</span></span></code></pre></div><p>安装完成后使用以下命令，会得到显卡型号、推荐的显卡驱动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ubuntu-drivers devices
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#返回</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">==</span> /sys/devices/pci0000:3a/0000:3a:02.0/0000:3b:00.0 <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>modalias : pci:v000010DEd00002208sv000010DEsd00001535bc03sc00i00
</span></span><span style="display:flex;"><span>vendor   : NVIDIA Corporation
</span></span><span style="display:flex;"><span>model    : GA102 <span style="color:#f92672">[</span>GeForce RTX <span style="color:#ae81ff">3080</span> Ti<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>manual_install: True
</span></span><span style="display:flex;"><span>driver   : nvidia-driver-470-server - distro non-free
</span></span><span style="display:flex;"><span>driver   : nvidia-driver-470 - distro non-free
</span></span><span style="display:flex;"><span>driver   : nvidia-driver-515 - distro non-free
</span></span><span style="display:flex;"><span>driver   : nvidia-driver-510 - distro non-free
</span></span><span style="display:flex;"><span>driver   : nvidia-driver-510-server - distro non-free
</span></span><span style="display:flex;"><span>driver   : nvidia-driver-515-open - distro non-free recommended
</span></span><span style="display:flex;"><span>driver   : nvidia-driver-515-server - distro non-free
</span></span><span style="display:flex;"><span>driver   : xserver-xorg-video-nouveau - distro free builtin 
</span></span></code></pre></div><p>在这里我选择的是<code>nvidia-driver-515-server</code>版，然后进行到容器内部后，使用<code>apt install nvidia-driver-515-server</code>进行安装，安装完成后，你在容器内部使用<code>nvidia-smi</code>即可看见相关信息表示安装成功。 关于如果要特定的<code>cuda</code>版本则需要根据具体情况选择对应的显卡驱动。</p>
<h2 id="配置容器的远程登陆">配置容器的远程登陆<a hidden class="anchor" aria-hidden="true" href="#配置容器的远程登陆">#</a></h2>
<p>安装ssh：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt install openssh-server 
</span></span></code></pre></div><p>安装完成后可以通过以下命令查看是否启动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl status sshd 
</span></span></code></pre></div><p>配置完成后，可以找一台内网的机器通过<code>ssh-keygen -t rsa</code>生成非对称加密的密钥，然后将公钥的内容复制到容器内部<code>/root/.ssh/authorized_keys</code>文件中，保存退出，最后重启ssh服务：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl restart sshd 
</span></span></code></pre></div><p>配置完成后，回到宿主机中，设置端口映射，目的在于当宿主机接到的目标端口的请求的时候，将数据传输到指定端口的容器内部中，在这里配置的是sshd远程连接，所以容器接收的端口为22，宿主机的监听端口则是设置为6001，当宿主机的6001端口接到数据就转发给容器内部的22端口。 设置命令可以通过下面的代码设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc config device add &lt;ContainerName&gt; &lt;name&gt; proxy listen<span style="color:#f92672">=</span>tcp:&lt;host_ip&gt;:&lt;host_port&gt; connect<span style="color:#f92672">=</span>tcp:&lt;container_ip&gt;:&lt;container_port&gt; bind<span style="color:#f92672">=</span>host
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#这里我的设置为：</span>
</span></span><span style="display:flex;"><span>sudo lxc config device add GPUTemplate testssh proxy listen<span style="color:#f92672">=</span>tcp:192.168.1.102:6001 connect<span style="color:#f92672">=</span>tcp:10.180.194.93:22 bind<span style="color:#f92672">=</span>host 
</span></span></code></pre></div><p>如果后期要删除该条测试端口映射，则使用以下的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 查看配置项目</span>
</span></span><span style="display:flex;"><span>sudo lxc config device list &lt;ContainerName&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 找到需要删除的端口别称，然后删除</span>
</span></span><span style="display:flex;"><span>sudo lxc config device remove &lt;ContainerName&gt; &lt;config_name&gt; 
</span></span></code></pre></div><h2 id="制作容器实例">制作容器实例<a hidden class="anchor" aria-hidden="true" href="#制作容器实例">#</a></h2>
<p>制作容器实例实际上就是基于现有运行的实例进行复制一份，然后再做一点基础的修改就可以让他人使用。 复制容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc copy &lt;ContainerTemplateName&gt; &lt;newContainerName&gt; 
</span></span></code></pre></div><p>复制后，需要手动启动</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lxc start &lt;newContainerName&gt; 
</span></span></code></pre></div><p>复制完成后，可以按照上述的步骤设置使用者的ssh key和端口映射即可。</p>
<h2 id="参考文章">参考文章<a hidden class="anchor" aria-hidden="true" href="#参考文章">#</a></h2>
<ol>
<li><a href="https://shenxiaohai.me/2018/12/03/gpu-server-lab/">https://shenxiaohai.me/2018/12/03/gpu-server-lab/</a></li>
<li><a href="https://linuxcontainers.org/lxd/introduction/">https://linuxcontainers.org/lxd/introduction/</a></li>
<li><a href="https://zh.wikipedia.org/wiki/LXC">https://zh.wikipedia.org/wiki/LXC</a></li>
<li><a href="https://linuxcontainers.org/lxd/docs/master/explanation/storage/">https://linuxcontainers.org/lxd/docs/master/explanation/storage/</a></li>
<li><a href="https://linuxcontainers.org/lxd/docs/master/explanation/networks/">https://linuxcontainers.org/lxd/docs/master/explanation/networks/</a></li>
<li><a href="https://blog.csdn.net/zhw864680355/article/details/90411288">https://blog.csdn.net/zhw864680355/article/details/90411288</a></li>
<li><a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a></li>
<li><a href="https://www.cnblogs.com/booturbo/p/13960935.html">https://www.cnblogs.com/booturbo/p/13960935.html</a></li>
<li><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></li>
<li><a href="https://www.jianshu.com/p/978bc51029fa">https://www.jianshu.com/p/978bc51029fa</a></li>
<li><a href="https://command-not-found.com/ubuntu-drivers">https://command-not-found.com/ubuntu-drivers</a></li>
<li><a href="https://www.myfreax.com/how-to-nvidia-drivers-on-ubuntu-20-04/">https://www.myfreax.com/how-to-nvidia-drivers-on-ubuntu-20-04/</a></li>
<li><a href="https://blog.csdn.net/Guzarish/article/details/118626384">https://blog.csdn.net/Guzarish/article/details/118626384</a></li>
<li><a href="https://blog.csdn.net/dou3516/article/details/120823932">https://blog.csdn.net/dou3516/article/details/120823932</a></li>
<li><a href="https://developer.aliyun.com/article/971986">https://developer.aliyun.com/article/971986</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://wuyizhou.com/tags/%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%BF%90%E7%BB%B4/">服务和运维</a></li>
    </ul>
  </footer><script src="https://giscus.app/client.js"
        data-repo="wyizhou/YizhouWebsite"
        data-repo-id="R_kgDOK59ReQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOK59Rec4CcNSZ"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://wuyizhou.com/">Yizhou</a></span>
    <span>
        <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
    </span>
    <span>
        Build: 2024-03-07 02:11:09
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
