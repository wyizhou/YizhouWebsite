<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>(二)漫话中文分词：Trie、KMP、AC自动机 | Yizhou&#39;s Website</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="Trie树 🔗在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[&lsquo;中国人&rsquo">
<meta name="generator" content="Hugo 0.121.1">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  





    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          "HTML-CSS": { scale: 85 },
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true
          }
        });
    </script>
    
    <script src='https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>





  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	<a href="/posts">归档</a>
	<a href="/tags">标签</a>
	<a href="/about">关于</a>

	

	
	  <a class="button" href="https://example.com/index.xml">订阅</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">(二)漫话中文分词：Trie、KMP、AC自动机</h1>

    <div class="tip">
        <time datetime="2020-11-18 08:51:13 &#43;0000 &#43;0000">2020年11月18日</time>
        <span class="split">
          ·
        </span>
        <span>
          4756字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          10分钟
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#trie树">Trie树</a></li>
    <li><a href="#kmp算法">KMP算法</a></li>
    <li><a href="#ac自动机">AC自动机</a></li>
    <li><a href="#参考文档">参考文档</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <h2 id="trie树">Trie树 <a href="#trie%e6%a0%91" class="anchor">🔗</a></h2><p>在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[&lsquo;中国人&rsquo;, &lsquo;中东人&rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词<code>retrieval</code>，发音和<code>try</code>相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如&quot;中国人&quot;、&ldquo;中东人&quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以&quot;中&quot;开头，所以可以使用同一个父辈节点。</p>
<p><p class="markdown-image">
  <img src="/post/images/2020/11/1605767937-1-0012449.jpg" alt="1605767937-1"  />
</p></p>
<p>除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如<code>中国人</code>，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。</p>
<p><p class="markdown-image">
  <img src="/post/images/2020/11/1605767940-2-0012449.jpg" alt="1605767940-2"  />
</p></p>
<p>Trie树的查找方式则是通过层层查询，而不是直接遍历词典，比如&quot;中国人&rdquo;，首先会查找第一层中是否有&quot;中&quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找&quot;中&quot;字符对应的下一层是否有&quot;国&quot;，如果没有则返回查询识别，如果有则继续查找&quot;国&quot;下一层是否有&quot;人&quot;，此时找到存在&quot;人&quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：</p>
<ol>
<li>查询词</li>
<li>添加词</li>
</ol>
<p>除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回&quot;False&quot;表示为未查询到或设置失败，而返回&quot;True&quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的<code>__value</code>表示是否为结束节点（即一个词的尾字符），如果是则为<code>True</code>，不是则为<code>False</code>，整体可以采用函数或者类来定义。 实现代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Trie</span>():  <span style="color:#080;font-style:italic">#定义一个Trie类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> __init__(self):  <span style="color:#080;font-style:italic">#为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#666">.</span>_children <span style="color:#666">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">_add_word</span>(self, word):  <span style="color:#080;font-style:italic"># 定义一个添加词的实例方法</span>
</span></span><span style="display:flex;"><span>        child <span style="color:#666">=</span> self<span style="color:#666">.</span>_children  <span style="color:#080;font-style:italic"># 首先会将_children的对象赋值给child</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> i,char <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#a2f">enumerate</span>(word):  <span style="color:#080;font-style:italic"># 然后从头遍历添加词的每一个字符</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> char <span style="color:#a2f;font-weight:bold">not</span> <span style="color:#a2f;font-weight:bold">in</span> child:  <span style="color:#080;font-style:italic"># 查看当前字符是否存在Trie树上</span>
</span></span><span style="display:flex;"><span>                child[char] <span style="color:#666">=</span> {<span style="color:#b44">&#39;__value&#39;</span>: <span style="color:#a2f;font-weight:bold">False</span>} <span style="color:#080;font-style:italic"># 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> i <span style="color:#666">==</span> (<span style="color:#a2f">len</span>(word) <span style="color:#666">-</span> <span style="color:#666">1</span>):  <span style="color:#080;font-style:italic"># 判断是否为结尾字符</span>
</span></span><span style="display:flex;"><span>                child[char][<span style="color:#b44">&#39;__value&#39;</span>] <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">True</span> <span style="color:#080;font-style:italic"># 如果是则将特殊key：__value设为True，表明为结尾字符</span>
</span></span><span style="display:flex;"><span>            child <span style="color:#666">=</span> child[char]  <span style="color:#080;font-style:italic"># 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">True</span> <span style="color:#080;font-style:italic"># 添加完成返回True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">_get_word</span>(self, word):  <span style="color:#080;font-style:italic"># 查找词</span>
</span></span><span style="display:flex;"><span>        child <span style="color:#666">=</span> self<span style="color:#666">.</span>_children  <span style="color:#080;font-style:italic"># 同样设置一个child变量，用于控制当前的字符对象 </span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> char <span style="color:#a2f;font-weight:bold">in</span> word:  
</span></span><span style="display:flex;"><span>            child <span style="color:#666">=</span> child<span style="color:#666">.</span>get(char)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> child <span style="color:#a2f;font-weight:bold">is</span> <span style="color:#a2f;font-weight:bold">None</span> :  <span style="color:#080;font-style:italic"># 只要其中一个没有查找到，那么说明匹配识别，则返回False</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">False</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> child[<span style="color:#b44">&#39;__value&#39;</span>]  <span style="color:#080;font-style:italic"># 如果没有匹配失败则返回特殊__value的值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">#回True表示词典中存在该词，返回False表示不存在或者传递进来的词不成词 </span>
</span></span></code></pre></div><p>将Trie实现后，就可以在正向或者反向等算法中来进行使用，从而提高运算的效率，但是使用Trie树的时候，可能无法动态的计算其词的长度，所以根据上一篇文章当中修改的最大正向匹配算法的长度计算我手动计算填写。 下面的代码是基于<a href="/posts/2022-04-15-1-chinese-words-cut/">《[一]漫话中文分词：最大匹配,双向最大,最小词数》</a>文章中的最大正向匹配算法，但其中的词典则是使用Trie结构，改动了两处：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>trie <span style="color:#666">=</span> Trie()
</span></span><span style="display:flex;"><span>trie<span style="color:#666">.</span>_add_word(<span style="color:#b44">&#39;分词&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sentence <span style="color:#666">=</span> <span style="color:#b44">&#39;中文分词算法&#39;</span> 
</span></span><span style="display:flex;"><span>start <span style="color:#666">=</span> <span style="color:#666">0</span> 
</span></span><span style="display:flex;"><span>maxWidth <span style="color:#666">=</span> <span style="color:#666">2</span> <span style="color:#080;font-style:italic"># 改动1：手动填写最大长度</span>
</span></span><span style="display:flex;"><span>cut_result <span style="color:#666">=</span> [] 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span> (start <span style="color:#666">&lt;=</span> <span style="color:#a2f">len</span>(sentence)): 
</span></span><span style="display:flex;"><span>    end <span style="color:#666">=</span> start <span style="color:#666">+</span> maxWidth     
</span></span><span style="display:flex;"><span>    word <span style="color:#666">=</span> sentence[start: end] 
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> ( word ) :  
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> ( trie<span style="color:#666">.</span>_get_word(word) ) :  <span style="color:#080;font-style:italic"># 改动2：利用Trie的查询函数，该返回查询到为词则返回True，否则False</span>
</span></span><span style="display:flex;"><span>            cut_result<span style="color:#666">.</span>append(word)
</span></span><span style="display:flex;"><span>            start <span style="color:#666">=</span> start <span style="color:#666">+</span> <span style="color:#a2f">len</span>(word) <span style="color:#666">-</span> <span style="color:#666">1</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">break</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#a2f">len</span>(word[:<span style="color:#666">-</span><span style="color:#666">1</span>]) <span style="color:#666">==</span> <span style="color:#666">0</span>):
</span></span><span style="display:flex;"><span>            cut_result<span style="color:#666">.</span>append(word) 
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>        word <span style="color:#666">=</span> word[:<span style="color:#666">-</span><span style="color:#666">1</span>]  
</span></span><span style="display:flex;"><span>    start <span style="color:#666">=</span> start <span style="color:#666">+</span> <span style="color:#666">1</span>  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f">print</span>(cut_result)
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">#[&#39;中&#39;, &#39;文&#39;, &#39;分词&#39;, &#39;算&#39;, &#39;法&#39;] </span>
</span></span></code></pre></div><h2 id="kmp算法">KMP算法 <a href="#kmp%e7%ae%97%e6%b3%95" class="anchor">🔗</a></h2><p>高效的数据结构有了，然而还可以更近一步，在Trie结构的基础上采用一些高效的查询算法，比如下面的AC自动机，在了解AC自动机之前，可以先了解一下KMP算法，虽然了解AC自动机不需要了解KMP算法就可以理解，但是理解了KMP算法过后，实际上会更容易理解AC自动机。 KMP算法于1977年由James H. Morris](<a href="https://en.wikipedia.org/wiki/James" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/James</a>_H._Morris)、<a href="https://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="noopener">Donald Knuth</a>、<a href="https://en.wikipedia.org/wiki/Vaughan_Pratt" target="_blank" rel="noopener">Vaughan Pratt</a>三位发明者联合发表，其算法名称KMP是由三位发明者首字母命名。 KMP算法其核心主要为利用已匹配字符串中的已知信息来减少无效匹配的次数，从而提升查找的效率。首先可以来看看普通查找方式，找到一个字符串在另外一个字符串中出现的位置该怎么来匹配。 比如搜索词<code>ABABC</code>，需要查找在文本<code>ABABABC</code>中出现的位置，那么按照常规的方式应该首先第一个字符，是否相等：</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672037-1-20220415155505386-0012449.jpg" alt=""  />
</p></p>
<p>如果第一个字符相等，那么继续匹配第二个字符，查看第二个字符是否相等：</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672040-2-20220415155505393-0012449.jpg" alt=""  />
</p></p>
<p>如果第二字符相等再匹配下一个字符是否相等，一直匹配，直到第五个字符出现了问题，不相等：</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672043-3-20220415155505388-0012449.jpg" alt=""  />
</p></p>
<p>此时，将搜索词的位置往后移动一位，即搜索词的第一个字符从文本的第二个字符开始匹配：</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672046-4-20220415155505839-0012449.jpg" alt=""  />
</p></p>
<p>移动过后，第一位不匹配，那么继续将模式串移动一位，将模式串第一个字符对准字符串第三个字符，继续重新匹配，第一次匹配：</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672048-5-20220415155505441-0012449.jpg" alt=""  />
</p> 第一次匹配成功，继续第二位，第三位匹配，一直遍历匹配到搜索词最后一个字符成功，那么整个搜索结束，并返回该搜索词第一次出现的位置为文本的第三位。</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672051-6-20220415155505388-0012449.jpg" alt="6"  />
</p></p>
<p>从上面的例子来看，第二次明显属于无效匹配，如果在大量的文本中搜索词的话，会造成更多这样的无效匹配出现，而KMP算法就是解决这样的问题，用来减少无效的匹配次数，从而来增加匹配的效率。 KMP算法首先需要维护一个特殊的表，名字为<code>部分匹配表</code>或者<code>失配函数</code>，这个表由非负数数值构成，并且搜索词的字符都会对应一个数值，大概为下面这样：</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672053-7-20220415155506493-0012449.png" alt="7"  />
</p></p>
<p>关于这个值是如何计算的先不用管，先看看如何使用这个值来跳过无效的匹配，还是拿刚刚例子，搜索词<code>ABABC</code>，文本<code>ABABABC</code>，首先进行第一次匹配：</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672037-1-20220415155505386-0012449.jpg" alt=""  />
</p></p>
<p>第一次匹配成功，进入第二次匹配：</p>
<p><p class="markdown-image">
  <img src="/post/images/2020/11/1607672040-2-20220415155505393-0012449.jpg" alt=""  />
</p></p>
<p>第二次匹配成功，重复该动作，直到匹配到第五次出现了问题，此时搜索词第五位的<code>C</code>和文本的第五位<code>A</code>不相等，此时KMP算法中的<code>部分匹配表</code>就派上了用场，可以通过该表计算出需要搜索词下一个开始匹配的位置是从什么地方开始，这样就可以跳过无效匹配位的值。其计算公式为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#b8860b">位移值</span> <span style="color:#666">=</span> 成功匹配的数量 - 匹配失败位前一位在部分匹配表中的值 
</span></span></code></pre></div><p>因为匹配失败的位置是在第五位，那么获取<code>部分匹配表</code>中的值应该位前一位的值，通过查询下图得到数值<code>2</code>，然后匹配成功的字符数量为<code>4</code>，最后相减得到<code>2</code>。</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672053-7-20220415155506493-0012449.png" alt="7"  />
</p></p>
<p>从上面得到数值后，就可以将搜索词当前开始的位置加<code>2</code>，因为此时的搜索词开始的位置是文本的第1位，那么加上后得到3，就意味着搜索词的第一位对应着文本的第三位：</p>
<p><p class="markdown-image">
  <img src="/post/images/2020/11/1607672056-8-20220415155505925-0012449.png" alt=""  />
</p></p>
<p>而通过KMP的算法就可以跳过对应普通查找方法的第二次匹配，这在大量的文本搜索当中提升是非常显著的，但是怎么来计算<code>部分匹配表</code>的中的值？ <code>部分匹配表</code>指的是最长相同字符的长度，要计算<code>部分匹配表</code>首先需要知道<code>前缀</code>和<code>后缀</code>的概念，<code>前缀</code>指的是除了字符串第一个字符之外的所有字符串头部集合，而<code>后缀</code>指的是除了字符串最后一个字符之外的所有后部集合。 比如说单词<code>home</code>，其前后缀集合为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>前缀集合为：<span style="color:#666">{</span>h, ho, hom<span style="color:#666">}</span>
</span></span><span style="display:flex;"><span>后缀集合为：<span style="color:#666">{</span>ome, me, e<span style="color:#666">}</span> 
</span></span></code></pre></div><p>而<code>部分匹配表</code>需要对每一位进行计算相应的值，而在搜索词的每一位取的范围字符为前面所有字符，比如<code>ABABC</code>，计算第一位因为前面没有字符，所以取的范围仅为<code>A</code>。到第二位则包含前面所有字符，所以等于<code>AB</code>。第三位则为<code>ABA</code>以此类推 再回到上面例子中，搜索词<code>ABABC</code>，其计算<code>部分匹配表</code>的过程为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>A：前后缀都为空，则值为0
</span></span><span style="display:flex;"><span>AB：前缀为<span style="color:#666">{</span>A<span style="color:#666">}</span>,后缀为<span style="color:#666">{</span>B<span style="color:#666">}</span>,没有相同的字符，部分匹配表中的值为0
</span></span><span style="display:flex;"><span>ABA：前缀为<span style="color:#666">{</span>A, AB<span style="color:#666">}</span>,后缀为<span style="color:#666">{</span>BA, A<span style="color:#666">}</span>，其中有字符A交集，其长度为1，部分匹配表中的值为1
</span></span><span style="display:flex;"><span>ABAB：前缀为<span style="color:#666">{</span>A,AB,ABA<span style="color:#666">}</span>,后缀为<span style="color:#666">{</span>BAB,AB,B<span style="color:#666">}</span>，有相同字符AB，长度为2，部分匹配表中的值为2
</span></span><span style="display:flex;"><span>ABABC：前缀为<span style="color:#666">{</span>A,AB,ABA,ABAB<span style="color:#666">}</span>,后缀为<span style="color:#666">{</span>BABC,ABC,BC,C<span style="color:#666">}</span>，没有相同字符，部分匹配表中的值为0 
</span></span></code></pre></div><h2 id="ac自动机">AC自动机 <a href="#ac%e8%87%aa%e5%8a%a8%e6%9c%ba" class="anchor">🔗</a></h2><p>AC自动机(Aho-Corasick automaton)是一种基于Trie树进行匹配的一种字符串搜索算法，在1975年由Alfred V. Aho和Margaret J.Corasick发明，该算法其实和KMP算法并无太大的关联，KMP算法是1对1（一个搜索词匹配一个文本）进行搜索，而AC自动机则是1对多（多个搜索词匹配一个文本）进行搜索。 AC自动机对比Trie树的优点在于Trie树每次匹配后进行下一个字符查找的时候都需要回到顶点继续再搜索，而AC自动机则是将该文本中的字符串搜索一次性完成。 AC自动机核心是利用一个叫fail指针(失败指针)的东西，fail指针主要的用途是如果当前字符在当前节点的子元素中没有找到，那么就利用fail指针指向另外一个节点继续搜索，直到搜索完成，下图中的红线就是一个fail指针。</p>
<p><p class="markdown-image">
  <img src="/post/images//2020/11/1607672059-9-20220415155506496-0012449.jpg" alt=""  />
</p></p>
<p>比如单词列表为<code>['he', 'hers', 'his', 'she']</code>，待分词文本为<code>hershe</code>，正常Trie匹配为先找到<code>he</code>，然后字符<code>r</code>再从0开始匹配，此时<code>r</code>没有在顶层节点的子节点当中，所以跳过，继续查找，直到找到了<code>she</code>完成。 而AC自动机的算法则为当找到了<code>he</code>单词后，继续在当前节点的子节点当中搜索字符<code>r</code>，如果有继续搜索下一个字符<code>s</code>，然后得到单词信息<code>hers</code>，然后继续搜索字符<code>h</code>，此时搜索位置为下图红色节点位置，但该节点下没有<code>h</code>：</p>
<p><p class="markdown-image">
  <img src="/post/images/2020/11/1607672063-10-20220415155506488-0012449.jpg" alt=""  />
</p></p>
<p>这个时候就查看当前节点（即红色节点）的fail指针(红线)指向的节点下是否有字符<code>h</code>，此时发现有，则通过fail指针继续查找，直到找到了单词<code>she</code>。 AC自动机的理念是比较好理解，而难点在于如何计算fail指针指向谁，计算fail指针可以通过BFS（层次遍历），BFS将Trie每一层进行遍历，遍历的时候将计算所有子节点的fail指针，并将子节点放入到一个先进先出容器当中（队列）便于访问子节点的子节点。 而计算fail指针的时候一定是当前字符不存在于当前节点的子节点当中，所以查找当前节点的子节点的fail指针的时候，可以通过将当前节点的子节点中的所有fail指针都可以获取到所有父节点的fail指针，然后一层一层的找，如果找到后就指向谁，如果没有找到则指向最顶层。 下面是实现的代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">TrieNode</span>(<span style="color:#a2f">object</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> __init__(self) <span style="color:#666">-&gt;</span> <span style="color:#a2f;font-weight:bold">None</span>:
</span></span><span style="display:flex;"><span>        self<span style="color:#666">.</span>_children <span style="color:#666">=</span> {}
</span></span><span style="display:flex;"><span>        self<span style="color:#666">.</span>_fail <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#666">.</span>_exist <span style="color:#666">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">_add_child</span>(self, char, value, overwrite <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">None</span>):
</span></span><span style="display:flex;"><span>        child <span style="color:#666">=</span> self<span style="color:#666">.</span>_children<span style="color:#666">.</span>get(char)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> child <span style="color:#a2f;font-weight:bold">is</span> <span style="color:#a2f;font-weight:bold">None</span>:
</span></span><span style="display:flex;"><span>            child <span style="color:#666">=</span> TrieNode()
</span></span><span style="display:flex;"><span>            self<span style="color:#666">.</span>_children[char] <span style="color:#666">=</span> child
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> overwrite:
</span></span><span style="display:flex;"><span>            child<span style="color:#666">.</span>_exist<span style="color:#666">.</span>append(value)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> child
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Trie</span>(TrieNode):
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> __init__(self) <span style="color:#666">-&gt;</span> <span style="color:#a2f;font-weight:bold">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#a2f">super</span>()<span style="color:#666">.</span>__init__()
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">_find_text</span>(self, text):
</span></span><span style="display:flex;"><span>        state <span style="color:#666">=</span> self
</span></span><span style="display:flex;"><span>        cut_word <span style="color:#666">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> i,t <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#a2f">enumerate</span>(text):
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span> state<span style="color:#666">.</span>_children<span style="color:#666">.</span>get(t) <span style="color:#a2f;font-weight:bold">is</span> <span style="color:#a2f;font-weight:bold">None</span> <span style="color:#a2f;font-weight:bold">and</span> state<span style="color:#666">.</span>_fail:
</span></span><span style="display:flex;"><span>                state <span style="color:#666">=</span> state<span style="color:#666">.</span>_fail
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> state<span style="color:#666">.</span>_children<span style="color:#666">.</span>get(t) <span style="color:#a2f;font-weight:bold">is</span> <span style="color:#a2f;font-weight:bold">None</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">continue</span>
</span></span><span style="display:flex;"><span>            state <span style="color:#666">=</span> state<span style="color:#666">.</span>_children<span style="color:#666">.</span>get(t)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f">len</span>(state<span style="color:#666">.</span>_exist) <span style="color:#666">!=</span> <span style="color:#666">0</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">for</span> x <span style="color:#a2f;font-weight:bold">in</span> state<span style="color:#666">.</span>_exist:
</span></span><span style="display:flex;"><span>                    max_cut <span style="color:#666">=</span> text[i <span style="color:#666">-</span> x <span style="color:#666">+</span> <span style="color:#666">1</span>:i <span style="color:#666">+</span> <span style="color:#666">1</span>]
</span></span><span style="display:flex;"><span>                    cut_word<span style="color:#666">.</span>append(max_cut)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> cut_word
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> __setitem__(self, key, value):
</span></span><span style="display:flex;"><span>        state <span style="color:#666">=</span> self
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> char <span style="color:#a2f;font-weight:bold">in</span> key:
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> char <span style="color:#666">==</span> key[<span style="color:#666">-</span><span style="color:#666">1</span>] :
</span></span><span style="display:flex;"><span>                state <span style="color:#666">=</span> state<span style="color:#666">.</span>_add_child(char, <span style="color:#a2f">len</span>(value), <span style="color:#a2f;font-weight:bold">True</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>            state <span style="color:#666">=</span> state<span style="color:#666">.</span>_add_child(char, <span style="color:#a2f;font-weight:bold">None</span>, <span style="color:#a2f;font-weight:bold">False</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">_init_fail</span>(self):
</span></span><span style="display:flex;"><span>        q <span style="color:#666">=</span> queue<span style="color:#666">.</span>Queue()
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> self<span style="color:#666">.</span>_children:
</span></span><span style="display:flex;"><span>            state <span style="color:#666">=</span> self<span style="color:#666">.</span>_children<span style="color:#666">.</span>get(i)
</span></span><span style="display:flex;"><span>            state<span style="color:#666">.</span>_fail <span style="color:#666">=</span> self
</span></span><span style="display:flex;"><span>            q<span style="color:#666">.</span>put(state)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span> q<span style="color:#666">.</span>empty() <span style="color:#666">==</span> <span style="color:#a2f;font-weight:bold">False</span>:
</span></span><span style="display:flex;"><span>            state <span style="color:#666">=</span> q<span style="color:#666">.</span>get()
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> state<span style="color:#666">.</span>_children:
</span></span><span style="display:flex;"><span>                v <span style="color:#666">=</span> state<span style="color:#666">.</span>_children<span style="color:#666">.</span>get(i)
</span></span><span style="display:flex;"><span>                fafail <span style="color:#666">=</span> state<span style="color:#666">.</span>_fail
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">while</span> fafail <span style="color:#a2f;font-weight:bold">is</span> <span style="color:#a2f;font-weight:bold">not</span> <span style="color:#a2f;font-weight:bold">None</span> <span style="color:#a2f;font-weight:bold">and</span> fafail<span style="color:#666">.</span>_children<span style="color:#666">.</span>get(i) <span style="color:#a2f;font-weight:bold">is</span> <span style="color:#a2f;font-weight:bold">not</span> <span style="color:#a2f;font-weight:bold">None</span>:
</span></span><span style="display:flex;"><span>                    fafail <span style="color:#666">=</span> fafail<span style="color:#666">.</span>_children<span style="color:#666">.</span>get(i)
</span></span><span style="display:flex;"><span>                v<span style="color:#666">.</span>_fail <span style="color:#666">=</span> fafail
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span> v<span style="color:#666">.</span>_fail:
</span></span><span style="display:flex;"><span>                    <span style="color:#a2f;font-weight:bold">if</span> <span style="color:#a2f">len</span>(fafail<span style="color:#666">.</span>_exist) <span style="color:#666">!=</span> <span style="color:#666">0</span>:
</span></span><span style="display:flex;"><span>                        v<span style="color:#666">.</span>_exist<span style="color:#666">.</span>extend(v<span style="color:#666">.</span>_fail<span style="color:#666">.</span>_exist)
</span></span><span style="display:flex;"><span>                q<span style="color:#666">.</span>put(v) 
</span></span></code></pre></div><h2 id="参考文档">参考文档 <a href="#%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3" class="anchor">🔗</a></h2><p><a href="https://www.zhihu.com/question/21923021/answer/1032665486" target="_blank" rel="noopener">如何更好地理解和掌握 KMP 算法?</a> <a href="https://zh.wikipedia.org/wiki/KMP%e7%ae%97%e6%b3%95" target="_blank" rel="noopener">KMP算法-维基百科</a> <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%e2%80%93Morris%e2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></p>

    </div>

    
        <div class="tags">
            
                <a href="https://example.com/tags/%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95">数学与算法</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="your-github-link" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="your-stackoverflow-link" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>stackoverflow</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-488.000000, -1163.000000)">
            <g id="stackoverflow" transform="translate(488.000000, 1163.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M42.0860128,53.5922927 L22.9745951,53.6011499 L22.9729497,49.5538824 L42.0835447,49.5440929 L42.0860128,53.5922927 L42.0860128,53.5922927 Z M55,30.6708298 L51.7306912,12 L47.7087256,12.6920259 L50.9775643,31.3628557 L55,30.6708298 L55,30.6708298 Z M42.5455518,44.3547147 L23.5156994,42.616026 L23.1410164,46.6470941 L42.1712214,48.3841513 L42.5455518,44.3547147 L42.5455518,44.3547147 Z M43.8009984,39.0731519 L25.3459811,34.1539179 L24.285633,38.0621508 L42.7419431,42.9819676 L43.8009984,39.0731519 L43.8009984,39.0731519 Z M46.2103463,34.4436411 L29.7494464,24.8164635 L27.6748215,28.3015328 L44.1365441,37.9292931 L46.2103463,34.4436411 L46.2103463,34.4436411 Z M50.2466504,31.6088756 L46.8745036,33.8883189 L36.106599,18.2318456 L39.4792159,15.9517031 L50.2466504,31.6088756 Z M45.3315807,40.2784283 L48.5799693,40.2784283 L48.5799693,60 L17,60 L17,40.2784283 L20.2648427,40.2784283 L20.2648427,56.8243495 L45.3315807,56.8243495 L45.3315807,40.2784283 Z" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="your-twitter-link" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"
	 xml:space="preserve">
<g>
	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123
		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126
		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225
		C438.532,59.576,430.49,40.204,414.41,24.123z M335.471,168.735c0.191,1.713,0.288,4.278,0.288,7.71
		c0,15.989-2.334,32.025-6.995,48.104c-4.661,16.087-11.8,31.504-21.416,46.254c-9.606,14.749-21.074,27.791-34.396,39.115
		c-13.325,11.32-29.311,20.365-47.968,27.117c-18.648,6.762-38.637,10.143-59.953,10.143c-33.116,0-63.76-8.952-91.931-26.836
		c4.568,0.568,9.329,0.855,14.275,0.855c27.6,0,52.439-8.565,74.519-25.7c-12.941-0.185-24.506-4.179-34.688-11.991
		c-10.185-7.803-17.273-17.699-21.271-29.691c4.947,0.76,8.658,1.137,11.132,1.137c4.187,0,9.042-0.76,14.56-2.279
		c-13.894-2.669-25.598-9.562-35.115-20.697c-9.519-11.136-14.277-23.84-14.277-38.114v-0.571
		c10.085,4.755,19.602,7.229,28.549,7.422c-17.321-11.613-25.981-28.265-25.981-49.963c0-10.66,2.758-20.747,8.278-30.264
		c15.035,18.464,33.311,33.213,54.816,44.252c21.507,11.038,44.54,17.227,69.092,18.558c-0.95-3.616-1.427-8.186-1.427-13.704
		c0-16.562,5.853-30.692,17.56-42.399c11.703-11.706,25.837-17.561,42.394-17.561c17.515,0,32.079,6.283,43.688,18.846
		c13.134-2.474,25.892-7.33,38.26-14.56c-4.757,14.652-13.613,25.788-26.55,33.402c12.368-1.716,23.88-4.95,34.537-9.708
		C357.458,149.793,347.462,160.166,335.471,168.735z"/>
</g>
</svg>

    </a>


</div>

    

    <div class="copyright">
    
        © Copyright 2023 Yizhou
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-mini'>nodejh</a>
      </div>
    
</footer>



  </body>
</html>
