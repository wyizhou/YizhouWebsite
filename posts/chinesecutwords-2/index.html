<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>(二)漫话中文分词：Trie、KMP、AC自动机 | Yizhou</title>
<meta name="keywords" content="数学与算法">
<meta name="description" content="Trie树 在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[&lsquo;中国人&rsquo;, &lsquo;中东人&rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词retrieval，发音和try相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如&quot;中国人&quot;、&ldquo;中东人&quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以&quot;中&quot;开头，所以可以使用同一个父辈节点。
除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如中国人，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。
Trie树的查找方式则是通过层层查询，而不是直接遍历词典，比如&quot;中国人&rdquo;，首先会查找第一层中是否有&quot;中&quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找&quot;中&quot;字符对应的下一层是否有&quot;国&quot;，如果没有则返回查询识别，如果有则继续查找&quot;国&quot;下一层是否有&quot;人&quot;，此时找到存在&quot;人&quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：
查询词 添加词 除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回&quot;False&quot;表示为未查询到或设置失败，而返回&quot;True&quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的__value表示是否为结束节点（即一个词的尾字符），如果是则为True，不是则为False，整体可以采用函数或者类来定义。 实现代码：
class Trie(): #定义一个Trie类型 def __init__(self): #为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构 self._children = {} def _add_word(self, word): # 定义一个添加词的实例方法 child = self._children # 首先会将_children的对象赋值给child for i,char in enumerate(word): # 然后从头遍历添加词的每一个字符 if char not in child: # 查看当前字符是否存在Trie树上 child[char] = {&#39;__value&#39;: False} # 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符 if i == (len(word) - 1): # 判断是否为结尾字符 child[char][&#39;__value&#39;] = True # 如果是则将特殊key：__value设为True，表明为结尾字符 child = child[char] # 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下 return True # 添加完成返回True def _get_word(self, word): # 查找词 child = self.">
<meta name="author" content="">
<link rel="canonical" href="https://wuyizhou.com/posts/chinesecutwords-2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://wuyizhou.com/images/favicon.ico">

<link rel="apple-touch-icon" href="https://wuyizhou.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://wuyizhou.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://wuyizhou.com/posts/chinesecutwords-2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css" /><meta property="og:title" content="(二)漫话中文分词：Trie、KMP、AC自动机" />
<meta property="og:description" content="Trie树 在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[&lsquo;中国人&rsquo;, &lsquo;中东人&rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词retrieval，发音和try相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如&quot;中国人&quot;、&ldquo;中东人&quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以&quot;中&quot;开头，所以可以使用同一个父辈节点。
除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如中国人，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。
Trie树的查找方式则是通过层层查询，而不是直接遍历词典，比如&quot;中国人&rdquo;，首先会查找第一层中是否有&quot;中&quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找&quot;中&quot;字符对应的下一层是否有&quot;国&quot;，如果没有则返回查询识别，如果有则继续查找&quot;国&quot;下一层是否有&quot;人&quot;，此时找到存在&quot;人&quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：
查询词 添加词 除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回&quot;False&quot;表示为未查询到或设置失败，而返回&quot;True&quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的__value表示是否为结束节点（即一个词的尾字符），如果是则为True，不是则为False，整体可以采用函数或者类来定义。 实现代码：
class Trie(): #定义一个Trie类型 def __init__(self): #为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构 self._children = {} def _add_word(self, word): # 定义一个添加词的实例方法 child = self._children # 首先会将_children的对象赋值给child for i,char in enumerate(word): # 然后从头遍历添加词的每一个字符 if char not in child: # 查看当前字符是否存在Trie树上 child[char] = {&#39;__value&#39;: False} # 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符 if i == (len(word) - 1): # 判断是否为结尾字符 child[char][&#39;__value&#39;] = True # 如果是则将特殊key：__value设为True，表明为结尾字符 child = child[char] # 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下 return True # 添加完成返回True def _get_word(self, word): # 查找词 child = self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wuyizhou.com/posts/chinesecutwords-2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-18T08:51:13+00:00" />
<meta property="article:modified_time" content="2020-11-18T08:51:13+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="(二)漫话中文分词：Trie、KMP、AC自动机"/>
<meta name="twitter:description" content="Trie树 在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[&lsquo;中国人&rsquo;, &lsquo;中东人&rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词retrieval，发音和try相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如&quot;中国人&quot;、&ldquo;中东人&quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以&quot;中&quot;开头，所以可以使用同一个父辈节点。
除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如中国人，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。
Trie树的查找方式则是通过层层查询，而不是直接遍历词典，比如&quot;中国人&rdquo;，首先会查找第一层中是否有&quot;中&quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找&quot;中&quot;字符对应的下一层是否有&quot;国&quot;，如果没有则返回查询识别，如果有则继续查找&quot;国&quot;下一层是否有&quot;人&quot;，此时找到存在&quot;人&quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：
查询词 添加词 除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回&quot;False&quot;表示为未查询到或设置失败，而返回&quot;True&quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的__value表示是否为结束节点（即一个词的尾字符），如果是则为True，不是则为False，整体可以采用函数或者类来定义。 实现代码：
class Trie(): #定义一个Trie类型 def __init__(self): #为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构 self._children = {} def _add_word(self, word): # 定义一个添加词的实例方法 child = self._children # 首先会将_children的对象赋值给child for i,char in enumerate(word): # 然后从头遍历添加词的每一个字符 if char not in child: # 查看当前字符是否存在Trie树上 child[char] = {&#39;__value&#39;: False} # 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符 if i == (len(word) - 1): # 判断是否为结尾字符 child[char][&#39;__value&#39;] = True # 如果是则将特殊key：__value设为True，表明为结尾字符 child = child[char] # 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下 return True # 添加完成返回True def _get_word(self, word): # 查找词 child = self."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "New Posts",
      "item": "https://wuyizhou.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "(二)漫话中文分词：Trie、KMP、AC自动机",
      "item": "https://wuyizhou.com/posts/chinesecutwords-2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "(二)漫话中文分词：Trie、KMP、AC自动机",
  "name": "(二)漫话中文分词：Trie、KMP、AC自动机",
  "description": "Trie树 在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[\u0026lsquo;中国人\u0026rsquo;, \u0026lsquo;中东人\u0026rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词retrieval，发音和try相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如\u0026quot;中国人\u0026quot;、\u0026ldquo;中东人\u0026quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以\u0026quot;中\u0026quot;开头，所以可以使用同一个父辈节点。\n除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如中国人，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。\nTrie树的查找方式则是通过层层查询，而不是直接遍历词典，比如\u0026quot;中国人\u0026rdquo;，首先会查找第一层中是否有\u0026quot;中\u0026quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找\u0026quot;中\u0026quot;字符对应的下一层是否有\u0026quot;国\u0026quot;，如果没有则返回查询识别，如果有则继续查找\u0026quot;国\u0026quot;下一层是否有\u0026quot;人\u0026quot;，此时找到存在\u0026quot;人\u0026quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：\n查询词 添加词 除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回\u0026quot;False\u0026quot;表示为未查询到或设置失败，而返回\u0026quot;True\u0026quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的__value表示是否为结束节点（即一个词的尾字符），如果是则为True，不是则为False，整体可以采用函数或者类来定义。 实现代码：\nclass Trie(): #定义一个Trie类型 def __init__(self): #为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构 self._children = {} def _add_word(self, word): # 定义一个添加词的实例方法 child = self._children # 首先会将_children的对象赋值给child for i,char in enumerate(word): # 然后从头遍历添加词的每一个字符 if char not in child: # 查看当前字符是否存在Trie树上 child[char] = {\u0026#39;__value\u0026#39;: False} # 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符 if i == (len(word) - 1): # 判断是否为结尾字符 child[char][\u0026#39;__value\u0026#39;] = True # 如果是则将特殊key：__value设为True，表明为结尾字符 child = child[char] # 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下 return True # 添加完成返回True def _get_word(self, word): # 查找词 child = self.",
  "keywords": [
    "数学与算法"
  ],
  "articleBody": "Trie树 在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[‘中国人’, ‘中东人’]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词retrieval，发音和try相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如\"中国人\"、“中东人\"三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以\"中\"开头，所以可以使用同一个父辈节点。\n除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如中国人，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。\nTrie树的查找方式则是通过层层查询，而不是直接遍历词典，比如\"中国人”，首先会查找第一层中是否有\"中\"这个字符，如果没有查询到则返回查询失败，如果有则继续查找\"中\"字符对应的下一层是否有\"国\"，如果没有则返回查询识别，如果有则继续查找\"国\"下一层是否有\"人\"，此时找到存在\"人\"这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：\n查询词 添加词 除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回\"False\"表示为未查询到或设置失败，而返回\"True\"则表示查询到或设置成功，每个节点为一个字符，而字典当中的__value表示是否为结束节点（即一个词的尾字符），如果是则为True，不是则为False，整体可以采用函数或者类来定义。 实现代码：\nclass Trie(): #定义一个Trie类型 def __init__(self): #为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构 self._children = {} def _add_word(self, word): # 定义一个添加词的实例方法 child = self._children # 首先会将_children的对象赋值给child for i,char in enumerate(word): # 然后从头遍历添加词的每一个字符 if char not in child: # 查看当前字符是否存在Trie树上 child[char] = {'__value': False} # 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符 if i == (len(word) - 1): # 判断是否为结尾字符 child[char]['__value'] = True # 如果是则将特殊key：__value设为True，表明为结尾字符 child = child[char] # 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下 return True # 添加完成返回True def _get_word(self, word): # 查找词 child = self._children # 同样设置一个child变量，用于控制当前的字符对象 for char in word: child = child.get(char) if child is None : # 只要其中一个没有查找到，那么说明匹配识别，则返回False return False return child['__value'] # 如果没有匹配失败则返回特殊__value的值 #回True表示词典中存在该词，返回False表示不存在或者传递进来的词不成词 将Trie实现后，就可以在正向或者反向等算法中来进行使用，从而提高运算的效率，但是使用Trie树的时候，可能无法动态的计算其词的长度，所以根据上一篇文章当中修改的最大正向匹配算法的长度计算我手动计算填写。 下面的代码是基于《[一]漫话中文分词：最大匹配,双向最大,最小词数》文章中的最大正向匹配算法，但其中的词典则是使用Trie结构，改动了两处：\ntrie = Trie() trie._add_word('分词') sentence = '中文分词算法' start = 0 maxWidth = 2 # 改动1：手动填写最大长度 cut_result = [] while (start \u003c= len(sentence)): end = start + maxWidth word = sentence[start: end] while ( word ) : if ( trie._get_word(word) ) : # 改动2：利用Trie的查询函数，该返回查询到为词则返回True，否则False cut_result.append(word) start = start + len(word) - 1 break if (len(word[:-1]) == 0): cut_result.append(word) break word = word[:-1] start = start + 1 print(cut_result) #['中', '文', '分词', '算', '法'] KMP算法 高效的数据结构有了，然而还可以更近一步，在Trie结构的基础上采用一些高效的查询算法，比如下面的AC自动机，在了解AC自动机之前，可以先了解一下KMP算法，虽然了解AC自动机不需要了解KMP算法就可以理解，但是理解了KMP算法过后，实际上会更容易理解AC自动机。 KMP算法于1977年由James H. Morris](https://en.wikipedia.org/wiki/James_H._Morris)、Donald Knuth、Vaughan Pratt三位发明者联合发表，其算法名称KMP是由三位发明者首字母命名。 KMP算法其核心主要为利用已匹配字符串中的已知信息来减少无效匹配的次数，从而提升查找的效率。首先可以来看看普通查找方式，找到一个字符串在另外一个字符串中出现的位置该怎么来匹配。 比如搜索词ABABC，需要查找在文本ABABABC中出现的位置，那么按照常规的方式应该首先第一个字符，是否相等：\n如果第一个字符相等，那么继续匹配第二个字符，查看第二个字符是否相等：\n如果第二字符相等再匹配下一个字符是否相等，一直匹配，直到第五个字符出现了问题，不相等：\n此时，将搜索词的位置往后移动一位，即搜索词的第一个字符从文本的第二个字符开始匹配：\n移动过后，第一位不匹配，那么继续将模式串移动一位，将模式串第一个字符对准字符串第三个字符，继续重新匹配，第一次匹配：\n第一次匹配成功，继续第二位，第三位匹配，一直遍历匹配到搜索词最后一个字符成功，那么整个搜索结束，并返回该搜索词第一次出现的位置为文本的第三位。\n从上面的例子来看，第二次明显属于无效匹配，如果在大量的文本中搜索词的话，会造成更多这样的无效匹配出现，而KMP算法就是解决这样的问题，用来减少无效的匹配次数，从而来增加匹配的效率。 KMP算法首先需要维护一个特殊的表，名字为部分匹配表或者失配函数，这个表由非负数数值构成，并且搜索词的字符都会对应一个数值，大概为下面这样：\n关于这个值是如何计算的先不用管，先看看如何使用这个值来跳过无效的匹配，还是拿刚刚例子，搜索词ABABC，文本ABABABC，首先进行第一次匹配：\n第一次匹配成功，进入第二次匹配：\n第二次匹配成功，重复该动作，直到匹配到第五次出现了问题，此时搜索词第五位的C和文本的第五位A不相等，此时KMP算法中的部分匹配表就派上了用场，可以通过该表计算出需要搜索词下一个开始匹配的位置是从什么地方开始，这样就可以跳过无效匹配位的值。其计算公式为：\n位移值 = 成功匹配的数量 - 匹配失败位前一位在部分匹配表中的值 因为匹配失败的位置是在第五位，那么获取部分匹配表中的值应该位前一位的值，通过查询下图得到数值2，然后匹配成功的字符数量为4，最后相减得到2。\n从上面得到数值后，就可以将搜索词当前开始的位置加2，因为此时的搜索词开始的位置是文本的第1位，那么加上后得到3，就意味着搜索词的第一位对应着文本的第三位：\n而通过KMP的算法就可以跳过对应普通查找方法的第二次匹配，这在大量的文本搜索当中提升是非常显著的，但是怎么来计算部分匹配表的中的值？ 部分匹配表指的是最长相同字符的长度，要计算部分匹配表首先需要知道前缀和后缀的概念，前缀指的是除了字符串第一个字符之外的所有字符串头部集合，而后缀指的是除了字符串最后一个字符之外的所有后部集合。 比如说单词home，其前后缀集合为：\n前缀集合为：{h, ho, hom} 后缀集合为：{ome, me, e} 而部分匹配表需要对每一位进行计算相应的值，而在搜索词的每一位取的范围字符为前面所有字符，比如ABABC，计算第一位因为前面没有字符，所以取的范围仅为A。到第二位则包含前面所有字符，所以等于AB。第三位则为ABA以此类推 再回到上面例子中，搜索词ABABC，其计算部分匹配表的过程为：\nA：前后缀都为空，则值为0 AB：前缀为{A},后缀为{B},没有相同的字符，部分匹配表中的值为0 ABA：前缀为{A, AB},后缀为{BA, A}，其中有字符A交集，其长度为1，部分匹配表中的值为1 ABAB：前缀为{A,AB,ABA},后缀为{BAB,AB,B}，有相同字符AB，长度为2，部分匹配表中的值为2 ABABC：前缀为{A,AB,ABA,ABAB},后缀为{BABC,ABC,BC,C}，没有相同字符，部分匹配表中的值为0 AC自动机 AC自动机(Aho-Corasick automaton)是一种基于Trie树进行匹配的一种字符串搜索算法，在1975年由Alfred V. Aho和Margaret J.Corasick发明，该算法其实和KMP算法并无太大的关联，KMP算法是1对1（一个搜索词匹配一个文本）进行搜索，而AC自动机则是1对多（多个搜索词匹配一个文本）进行搜索。 AC自动机对比Trie树的优点在于Trie树每次匹配后进行下一个字符查找的时候都需要回到顶点继续再搜索，而AC自动机则是将该文本中的字符串搜索一次性完成。 AC自动机核心是利用一个叫fail指针(失败指针)的东西，fail指针主要的用途是如果当前字符在当前节点的子元素中没有找到，那么就利用fail指针指向另外一个节点继续搜索，直到搜索完成，下图中的红线就是一个fail指针。\n比如单词列表为['he', 'hers', 'his', 'she']，待分词文本为hershe，正常Trie匹配为先找到he，然后字符r再从0开始匹配，此时r没有在顶层节点的子节点当中，所以跳过，继续查找，直到找到了she完成。 而AC自动机的算法则为当找到了he单词后，继续在当前节点的子节点当中搜索字符r，如果有继续搜索下一个字符s，然后得到单词信息hers，然后继续搜索字符h，此时搜索位置为下图红色节点位置，但该节点下没有h：\n这个时候就查看当前节点（即红色节点）的fail指针(红线)指向的节点下是否有字符h，此时发现有，则通过fail指针继续查找，直到找到了单词she。 AC自动机的理念是比较好理解，而难点在于如何计算fail指针指向谁，计算fail指针可以通过BFS（层次遍历），BFS将Trie每一层进行遍历，遍历的时候将计算所有子节点的fail指针，并将子节点放入到一个先进先出容器当中（队列）便于访问子节点的子节点。 而计算fail指针的时候一定是当前字符不存在于当前节点的子节点当中，所以查找当前节点的子节点的fail指针的时候，可以通过将当前节点的子节点中的所有fail指针都可以获取到所有父节点的fail指针，然后一层一层的找，如果找到后就指向谁，如果没有找到则指向最顶层。 下面是实现的代码：\nclass TrieNode(object): def __init__(self) -\u003e None: self._children = {} self._fail = None self._exist = [] def _add_child(self, char, value, overwrite = None): child = self._children.get(char) if child is None: child = TrieNode() self._children[char] = child if overwrite: child._exist.append(value) return child class Trie(TrieNode): def __init__(self) -\u003e None: super().__init__() def _find_text(self, text): state = self cut_word = [] for i,t in enumerate(text): while state._children.get(t) is None and state._fail: state = state._fail if state._children.get(t) is None: continue state = state._children.get(t) if len(state._exist) != 0: for x in state._exist: max_cut = text[i - x + 1:i + 1] cut_word.append(max_cut) return cut_word def __setitem__(self, key, value): state = self for char in key: if char == key[-1] : state = state._add_child(char, len(value), True) break state = state._add_child(char, None, False) def _init_fail(self): q = queue.Queue() for i in self._children: state = self._children.get(i) state._fail = self q.put(state) while q.empty() == False: state = q.get() for i in state._children: v = state._children.get(i) fafail = state._fail while fafail is not None and fafail._children.get(i) is not None: fafail = fafail._children.get(i) v._fail = fafail if v._fail: if len(fafail._exist) != 0: v._exist.extend(v._fail._exist) q.put(v) 参考文档 如何更好地理解和掌握 KMP 算法? KMP算法-维基百科 字符串匹配的KMP算法\n",
  "wordCount" : "426",
  "inLanguage": "en",
  "datePublished": "2020-11-18T08:51:13Z",
  "dateModified": "2020-11-18T08:51:13Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://wuyizhou.com/posts/chinesecutwords-2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Yizhou",
    "logo": {
      "@type": "ImageObject",
      "url": "https://wuyizhou.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wuyizhou.com/" accesskey="h" title="Yizhou (Alt + H)">Yizhou</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wuyizhou.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
            <li>
                <a href="https://wuyizhou.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      (二)漫话中文分词：Trie、KMP、AC自动机
    </h1>
    <div class="post-meta"><span title='2020-11-18 08:51:13 +0000 UTC'>2020-11-18</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#trie%e6%a0%91" aria-label="Trie树">Trie树</a></li>
                <li>
                    <a href="#kmp%e7%ae%97%e6%b3%95" aria-label="KMP算法">KMP算法</a></li>
                <li>
                    <a href="#ac%e8%87%aa%e5%8a%a8%e6%9c%ba" aria-label="AC自动机">AC自动机</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e6%96%87%e6%a1%a3" aria-label="参考文档">参考文档</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="trie树">Trie树<a hidden class="anchor" aria-hidden="true" href="#trie树">#</a></h2>
<p>在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[&lsquo;中国人&rsquo;, &lsquo;中东人&rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词<code>retrieval</code>，发音和<code>try</code>相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如&quot;中国人&quot;、&ldquo;中东人&quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以&quot;中&quot;开头，所以可以使用同一个父辈节点。</p>
<p><img loading="lazy" src="/post/images/2020/11/1605767937-1-0012449.jpg" alt="1605767937-1"  />
</p>
<p>除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如<code>中国人</code>，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。</p>
<p><img loading="lazy" src="/post/images/2020/11/1605767940-2-0012449.jpg" alt="1605767940-2"  />
</p>
<p>Trie树的查找方式则是通过层层查询，而不是直接遍历词典，比如&quot;中国人&rdquo;，首先会查找第一层中是否有&quot;中&quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找&quot;中&quot;字符对应的下一层是否有&quot;国&quot;，如果没有则返回查询识别，如果有则继续查找&quot;国&quot;下一层是否有&quot;人&quot;，此时找到存在&quot;人&quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：</p>
<ol>
<li>查询词</li>
<li>添加词</li>
</ol>
<p>除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回&quot;False&quot;表示为未查询到或设置失败，而返回&quot;True&quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的<code>__value</code>表示是否为结束节点（即一个词的尾字符），如果是则为<code>True</code>，不是则为<code>False</code>，整体可以采用函数或者类来定义。 实现代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span>():  <span style="color:#75715e">#定义一个Trie类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):  <span style="color:#75715e">#为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_children <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_add_word</span>(self, word):  <span style="color:#75715e"># 定义一个添加词的实例方法</span>
</span></span><span style="display:flex;"><span>        child <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>_children  <span style="color:#75715e"># 首先会将_children的对象赋值给child</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i,char <span style="color:#f92672">in</span> enumerate(word):  <span style="color:#75715e"># 然后从头遍历添加词的每一个字符</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> char <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> child:  <span style="color:#75715e"># 查看当前字符是否存在Trie树上</span>
</span></span><span style="display:flex;"><span>                child[char] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;__value&#39;</span>: <span style="color:#66d9ef">False</span>} <span style="color:#75715e"># 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> (len(word) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):  <span style="color:#75715e"># 判断是否为结尾字符</span>
</span></span><span style="display:flex;"><span>                child[char][<span style="color:#e6db74">&#39;__value&#39;</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span> <span style="color:#75715e"># 如果是则将特殊key：__value设为True，表明为结尾字符</span>
</span></span><span style="display:flex;"><span>            child <span style="color:#f92672">=</span> child[char]  <span style="color:#75715e"># 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span> <span style="color:#75715e"># 添加完成返回True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_get_word</span>(self, word):  <span style="color:#75715e"># 查找词</span>
</span></span><span style="display:flex;"><span>        child <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>_children  <span style="color:#75715e"># 同样设置一个child变量，用于控制当前的字符对象 </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> char <span style="color:#f92672">in</span> word:  
</span></span><span style="display:flex;"><span>            child <span style="color:#f92672">=</span> child<span style="color:#f92672">.</span>get(char)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> child <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> :  <span style="color:#75715e"># 只要其中一个没有查找到，那么说明匹配识别，则返回False</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> child[<span style="color:#e6db74">&#39;__value&#39;</span>]  <span style="color:#75715e"># 如果没有匹配失败则返回特殊__value的值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#回True表示词典中存在该词，返回False表示不存在或者传递进来的词不成词 </span>
</span></span></code></pre></div><p>将Trie实现后，就可以在正向或者反向等算法中来进行使用，从而提高运算的效率，但是使用Trie树的时候，可能无法动态的计算其词的长度，所以根据上一篇文章当中修改的最大正向匹配算法的长度计算我手动计算填写。 下面的代码是基于<a href="/posts/2022-04-15-1-chinese-words-cut/">《[一]漫话中文分词：最大匹配,双向最大,最小词数》</a>文章中的最大正向匹配算法，但其中的词典则是使用Trie结构，改动了两处：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>trie <span style="color:#f92672">=</span> Trie()
</span></span><span style="display:flex;"><span>trie<span style="color:#f92672">.</span>_add_word(<span style="color:#e6db74">&#39;分词&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sentence <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;中文分词算法&#39;</span> 
</span></span><span style="display:flex;"><span>start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span>maxWidth <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e"># 改动1：手动填写最大长度</span>
</span></span><span style="display:flex;"><span>cut_result <span style="color:#f92672">=</span> [] 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (start <span style="color:#f92672">&lt;=</span> len(sentence)): 
</span></span><span style="display:flex;"><span>    end <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> maxWidth     
</span></span><span style="display:flex;"><span>    word <span style="color:#f92672">=</span> sentence[start: end] 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ( word ) :  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( trie<span style="color:#f92672">.</span>_get_word(word) ) :  <span style="color:#75715e"># 改动2：利用Trie的查询函数，该返回查询到为词则返回True，否则False</span>
</span></span><span style="display:flex;"><span>            cut_result<span style="color:#f92672">.</span>append(word)
</span></span><span style="display:flex;"><span>            start <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> len(word) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (len(word[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>            cut_result<span style="color:#f92672">.</span>append(word) 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        word <span style="color:#f92672">=</span> word[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]  
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(cut_result)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[&#39;中&#39;, &#39;文&#39;, &#39;分词&#39;, &#39;算&#39;, &#39;法&#39;] </span>
</span></span></code></pre></div><h2 id="kmp算法">KMP算法<a hidden class="anchor" aria-hidden="true" href="#kmp算法">#</a></h2>
<p>高效的数据结构有了，然而还可以更近一步，在Trie结构的基础上采用一些高效的查询算法，比如下面的AC自动机，在了解AC自动机之前，可以先了解一下KMP算法，虽然了解AC自动机不需要了解KMP算法就可以理解，但是理解了KMP算法过后，实际上会更容易理解AC自动机。 KMP算法于1977年由James H. Morris](<a href="https://en.wikipedia.org/wiki/James">https://en.wikipedia.org/wiki/James</a>_H._Morris)、<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>、<a href="https://en.wikipedia.org/wiki/Vaughan_Pratt">Vaughan Pratt</a>三位发明者联合发表，其算法名称KMP是由三位发明者首字母命名。 KMP算法其核心主要为利用已匹配字符串中的已知信息来减少无效匹配的次数，从而提升查找的效率。首先可以来看看普通查找方式，找到一个字符串在另外一个字符串中出现的位置该怎么来匹配。 比如搜索词<code>ABABC</code>，需要查找在文本<code>ABABABC</code>中出现的位置，那么按照常规的方式应该首先第一个字符，是否相等：</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672037-1-20220415155505386-0012449.jpg" alt=""  />
</p>
<p>如果第一个字符相等，那么继续匹配第二个字符，查看第二个字符是否相等：</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672040-2-20220415155505393-0012449.jpg" alt=""  />
</p>
<p>如果第二字符相等再匹配下一个字符是否相等，一直匹配，直到第五个字符出现了问题，不相等：</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672043-3-20220415155505388-0012449.jpg" alt=""  />
</p>
<p>此时，将搜索词的位置往后移动一位，即搜索词的第一个字符从文本的第二个字符开始匹配：</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672046-4-20220415155505839-0012449.jpg" alt=""  />
</p>
<p>移动过后，第一位不匹配，那么继续将模式串移动一位，将模式串第一个字符对准字符串第三个字符，继续重新匹配，第一次匹配：</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672048-5-20220415155505441-0012449.jpg" alt=""  />
 第一次匹配成功，继续第二位，第三位匹配，一直遍历匹配到搜索词最后一个字符成功，那么整个搜索结束，并返回该搜索词第一次出现的位置为文本的第三位。</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672051-6-20220415155505388-0012449.jpg" alt="6"  />
</p>
<p>从上面的例子来看，第二次明显属于无效匹配，如果在大量的文本中搜索词的话，会造成更多这样的无效匹配出现，而KMP算法就是解决这样的问题，用来减少无效的匹配次数，从而来增加匹配的效率。 KMP算法首先需要维护一个特殊的表，名字为<code>部分匹配表</code>或者<code>失配函数</code>，这个表由非负数数值构成，并且搜索词的字符都会对应一个数值，大概为下面这样：</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672053-7-20220415155506493-0012449.png" alt="7"  />
</p>
<p>关于这个值是如何计算的先不用管，先看看如何使用这个值来跳过无效的匹配，还是拿刚刚例子，搜索词<code>ABABC</code>，文本<code>ABABABC</code>，首先进行第一次匹配：</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672037-1-20220415155505386-0012449.jpg" alt=""  />
</p>
<p>第一次匹配成功，进入第二次匹配：</p>
<p><img loading="lazy" src="/post/images/2020/11/1607672040-2-20220415155505393-0012449.jpg" alt=""  />
</p>
<p>第二次匹配成功，重复该动作，直到匹配到第五次出现了问题，此时搜索词第五位的<code>C</code>和文本的第五位<code>A</code>不相等，此时KMP算法中的<code>部分匹配表</code>就派上了用场，可以通过该表计算出需要搜索词下一个开始匹配的位置是从什么地方开始，这样就可以跳过无效匹配位的值。其计算公式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>位移值 <span style="color:#f92672">=</span> 成功匹配的数量 - 匹配失败位前一位在部分匹配表中的值 
</span></span></code></pre></div><p>因为匹配失败的位置是在第五位，那么获取<code>部分匹配表</code>中的值应该位前一位的值，通过查询下图得到数值<code>2</code>，然后匹配成功的字符数量为<code>4</code>，最后相减得到<code>2</code>。</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672053-7-20220415155506493-0012449.png" alt="7"  />
</p>
<p>从上面得到数值后，就可以将搜索词当前开始的位置加<code>2</code>，因为此时的搜索词开始的位置是文本的第1位，那么加上后得到3，就意味着搜索词的第一位对应着文本的第三位：</p>
<p><img loading="lazy" src="/post/images/2020/11/1607672056-8-20220415155505925-0012449.png" alt=""  />
</p>
<p>而通过KMP的算法就可以跳过对应普通查找方法的第二次匹配，这在大量的文本搜索当中提升是非常显著的，但是怎么来计算<code>部分匹配表</code>的中的值？ <code>部分匹配表</code>指的是最长相同字符的长度，要计算<code>部分匹配表</code>首先需要知道<code>前缀</code>和<code>后缀</code>的概念，<code>前缀</code>指的是除了字符串第一个字符之外的所有字符串头部集合，而<code>后缀</code>指的是除了字符串最后一个字符之外的所有后部集合。 比如说单词<code>home</code>，其前后缀集合为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>前缀集合为：<span style="color:#f92672">{</span>h, ho, hom<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>后缀集合为：<span style="color:#f92672">{</span>ome, me, e<span style="color:#f92672">}</span> 
</span></span></code></pre></div><p>而<code>部分匹配表</code>需要对每一位进行计算相应的值，而在搜索词的每一位取的范围字符为前面所有字符，比如<code>ABABC</code>，计算第一位因为前面没有字符，所以取的范围仅为<code>A</code>。到第二位则包含前面所有字符，所以等于<code>AB</code>。第三位则为<code>ABA</code>以此类推 再回到上面例子中，搜索词<code>ABABC</code>，其计算<code>部分匹配表</code>的过程为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>A：前后缀都为空，则值为0
</span></span><span style="display:flex;"><span>AB：前缀为<span style="color:#f92672">{</span>A<span style="color:#f92672">}</span>,后缀为<span style="color:#f92672">{</span>B<span style="color:#f92672">}</span>,没有相同的字符，部分匹配表中的值为0
</span></span><span style="display:flex;"><span>ABA：前缀为<span style="color:#f92672">{</span>A, AB<span style="color:#f92672">}</span>,后缀为<span style="color:#f92672">{</span>BA, A<span style="color:#f92672">}</span>，其中有字符A交集，其长度为1，部分匹配表中的值为1
</span></span><span style="display:flex;"><span>ABAB：前缀为<span style="color:#f92672">{</span>A,AB,ABA<span style="color:#f92672">}</span>,后缀为<span style="color:#f92672">{</span>BAB,AB,B<span style="color:#f92672">}</span>，有相同字符AB，长度为2，部分匹配表中的值为2
</span></span><span style="display:flex;"><span>ABABC：前缀为<span style="color:#f92672">{</span>A,AB,ABA,ABAB<span style="color:#f92672">}</span>,后缀为<span style="color:#f92672">{</span>BABC,ABC,BC,C<span style="color:#f92672">}</span>，没有相同字符，部分匹配表中的值为0 
</span></span></code></pre></div><h2 id="ac自动机">AC自动机<a hidden class="anchor" aria-hidden="true" href="#ac自动机">#</a></h2>
<p>AC自动机(Aho-Corasick automaton)是一种基于Trie树进行匹配的一种字符串搜索算法，在1975年由Alfred V. Aho和Margaret J.Corasick发明，该算法其实和KMP算法并无太大的关联，KMP算法是1对1（一个搜索词匹配一个文本）进行搜索，而AC自动机则是1对多（多个搜索词匹配一个文本）进行搜索。 AC自动机对比Trie树的优点在于Trie树每次匹配后进行下一个字符查找的时候都需要回到顶点继续再搜索，而AC自动机则是将该文本中的字符串搜索一次性完成。 AC自动机核心是利用一个叫fail指针(失败指针)的东西，fail指针主要的用途是如果当前字符在当前节点的子元素中没有找到，那么就利用fail指针指向另外一个节点继续搜索，直到搜索完成，下图中的红线就是一个fail指针。</p>
<p><img loading="lazy" src="/post/images//2020/11/1607672059-9-20220415155506496-0012449.jpg" alt=""  />
</p>
<p>比如单词列表为<code>['he', 'hers', 'his', 'she']</code>，待分词文本为<code>hershe</code>，正常Trie匹配为先找到<code>he</code>，然后字符<code>r</code>再从0开始匹配，此时<code>r</code>没有在顶层节点的子节点当中，所以跳过，继续查找，直到找到了<code>she</code>完成。 而AC自动机的算法则为当找到了<code>he</code>单词后，继续在当前节点的子节点当中搜索字符<code>r</code>，如果有继续搜索下一个字符<code>s</code>，然后得到单词信息<code>hers</code>，然后继续搜索字符<code>h</code>，此时搜索位置为下图红色节点位置，但该节点下没有<code>h</code>：</p>
<p><img loading="lazy" src="/post/images/2020/11/1607672063-10-20220415155506488-0012449.jpg" alt=""  />
</p>
<p>这个时候就查看当前节点（即红色节点）的fail指针(红线)指向的节点下是否有字符<code>h</code>，此时发现有，则通过fail指针继续查找，直到找到了单词<code>she</code>。 AC自动机的理念是比较好理解，而难点在于如何计算fail指针指向谁，计算fail指针可以通过BFS（层次遍历），BFS将Trie每一层进行遍历，遍历的时候将计算所有子节点的fail指针，并将子节点放入到一个先进先出容器当中（队列）便于访问子节点的子节点。 而计算fail指针的时候一定是当前字符不存在于当前节点的子节点当中，所以查找当前节点的子节点的fail指针的时候，可以通过将当前节点的子节点中的所有fail指针都可以获取到所有父节点的fail指针，然后一层一层的找，如果找到后就指向谁，如果没有找到则指向最顶层。 下面是实现的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TrieNode</span>(object):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_children <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_fail <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_exist <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_add_child</span>(self, char, value, overwrite <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        child <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>_children<span style="color:#f92672">.</span>get(char)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> child <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>            child <span style="color:#f92672">=</span> TrieNode()
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>_children[char] <span style="color:#f92672">=</span> child
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> overwrite:
</span></span><span style="display:flex;"><span>            child<span style="color:#f92672">.</span>_exist<span style="color:#f92672">.</span>append(value)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> child
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span>(TrieNode):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_find_text</span>(self, text):
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> self
</span></span><span style="display:flex;"><span>        cut_word <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i,t <span style="color:#f92672">in</span> enumerate(text):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> state<span style="color:#f92672">.</span>_children<span style="color:#f92672">.</span>get(t) <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> state<span style="color:#f92672">.</span>_fail:
</span></span><span style="display:flex;"><span>                state <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>_fail
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> state<span style="color:#f92672">.</span>_children<span style="color:#f92672">.</span>get(t) <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            state <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>_children<span style="color:#f92672">.</span>get(t)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(state<span style="color:#f92672">.</span>_exist) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> state<span style="color:#f92672">.</span>_exist:
</span></span><span style="display:flex;"><span>                    max_cut <span style="color:#f92672">=</span> text[i <span style="color:#f92672">-</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                    cut_word<span style="color:#f92672">.</span>append(max_cut)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cut_word
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __setitem__(self, key, value):
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> self
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> char <span style="color:#f92672">in</span> key:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> char <span style="color:#f92672">==</span> key[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] :
</span></span><span style="display:flex;"><span>                state <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>_add_child(char, len(value), <span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            state <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>_add_child(char, <span style="color:#66d9ef">None</span>, <span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_init_fail</span>(self):
</span></span><span style="display:flex;"><span>        q <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>Queue()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>_children:
</span></span><span style="display:flex;"><span>            state <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>_children<span style="color:#f92672">.</span>get(i)
</span></span><span style="display:flex;"><span>            state<span style="color:#f92672">.</span>_fail <span style="color:#f92672">=</span> self
</span></span><span style="display:flex;"><span>            q<span style="color:#f92672">.</span>put(state)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> q<span style="color:#f92672">.</span>empty() <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>            state <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>get()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> state<span style="color:#f92672">.</span>_children:
</span></span><span style="display:flex;"><span>                v <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>_children<span style="color:#f92672">.</span>get(i)
</span></span><span style="display:flex;"><span>                fafail <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>_fail
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> fafail <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> fafail<span style="color:#f92672">.</span>_children<span style="color:#f92672">.</span>get(i) <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>                    fafail <span style="color:#f92672">=</span> fafail<span style="color:#f92672">.</span>_children<span style="color:#f92672">.</span>get(i)
</span></span><span style="display:flex;"><span>                v<span style="color:#f92672">.</span>_fail <span style="color:#f92672">=</span> fafail
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> v<span style="color:#f92672">.</span>_fail:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> len(fafail<span style="color:#f92672">.</span>_exist) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                        v<span style="color:#f92672">.</span>_exist<span style="color:#f92672">.</span>extend(v<span style="color:#f92672">.</span>_fail<span style="color:#f92672">.</span>_exist)
</span></span><span style="display:flex;"><span>                q<span style="color:#f92672">.</span>put(v) 
</span></span></code></pre></div><h2 id="参考文档">参考文档<a hidden class="anchor" aria-hidden="true" href="#参考文档">#</a></h2>
<p><a href="https://www.zhihu.com/question/21923021/answer/1032665486">如何更好地理解和掌握 KMP 算法?</a> <a href="https://zh.wikipedia.org/wiki/KMP%E7%AE%97%E6%B3%95">KMP算法-维基百科</a> <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://wuyizhou.com/tags/%E6%95%B0%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95/">数学与算法</a></li>
    </ul>
  </footer><script src="https://giscus.app/client.js"
        data-repo="wyizhou/YizhouWebsite"
        data-repo-id="R_kgDOK59ReQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOK59Rec4CcNSZ"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://wuyizhou.com/">Yizhou</a></span>
    <span>
        <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
    </span>
    <span>
        Build: 2024-03-08 09:02:12
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
