<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Developer on Lucas Wu</title>
    <link>https://vec6.com/categories/developer/</link>
    <description>Recent content in Developer on Lucas Wu</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 19 Oct 2023 05:24:00 +0000</lastBuildDate>
    <atom:link href="https://vec6.com/categories/developer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>最近搭建了一台家用Nas</title>
      <link>https://vec6.com/blog/home-nas/</link>
      <pubDate>Thu, 19 Oct 2023 05:24:00 +0000</pubDate>
      <guid>https://vec6.com/blog/home-nas/</guid>
      <description>&lt;p&gt;从两个月前，我着手搭建了一套家用Nas，起因之前自己的资料一直存放在ICloud，因为自己的资料比较多，在600多G，所以自己一直购买的国区2T，每个月68元，一年816元，也不算便宜了。再加上自己的资料和储存的数据越来越大，所以就有就有了这个需求。&lt;/p&gt;&#xA;&lt;p&gt;对于资料不多、储存量不大的用户，不建议使用Nas，使用自带的云储存足够了，自己组建Nas只有在一定储存量级，才会有价值，所以对于数据量少的朋友，看看就行了，别折腾了。&lt;/p&gt;&#xA;&lt;p&gt;同时自己电脑有两台，一台苹果笔记本，一台Windows笔记本，ICloud对于Windows系统同步是真的难用，甚至打开文件夹都会卡顿，所以也是其自己搭建Nas的一个小因素了。&lt;/p&gt;&#xA;&lt;p&gt;选购之前对比了多种方式，购买其他国内云储存服务、自己购买云主机自己搭建、购买成品NAS、自己搭组NAS。&lt;/p&gt;&#xA;&lt;p&gt;先说说前两者，国内云服务研究了一番后，排除了，具体原因暂时不好说。然后就是云主机搭建，后面研究一番发现不论国内还是国内的云主机，硬盘都贵得要死。&lt;/p&gt;&#xA;&lt;p&gt;再说说后两者，也是我纠结最久的，成品Nas的优点就是不用折腾、省心以及有技术服务支撑，缺点就是配置低、价格贵。自己组Nas的优点在于便宜、配置高，缺点就是折腾，也不省心。&lt;/p&gt;&#xA;&lt;p&gt;那作为以技术出身的人来说，自己组Nas的缺点到成了一个有趣的过程，而配置高也满足了技术人员常常的幻想”配置不够“这一假说。&lt;/p&gt;&#xA;&lt;p&gt;所以最终思考了一下，准备折腾一下自己，组建Nas就成了最优选择。&lt;/p&gt;&#xA;&lt;h2 id=&#34;选购&#34;&gt;选购&lt;/h2&gt;&#xA;&lt;p&gt;既然是自己组建，就得自己挑选硬件、考虑配置、选择系统，系统我选择的是群晖，也就是所谓的黑群晖，主要考虑到配套的软件足够好用，关于硬件选配，可以参考隔壁网这篇文章&lt;a href=&#34;https://www.gebi1.com/thread-301584-1-1.html&#34;&gt;《2022年组建群晖实体机的一些建议 – 黑白群晖 – 隔壁网 (gebi1.com)》&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;我的配置目前是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU：考虑到需要看电影做解码，所以选择了i3-8100T，然后带T属于低功耗，对于Nas来说也完全够用了。&lt;/li&gt;&#xA;&lt;li&gt;内存：32G。&lt;/li&gt;&#xA;&lt;li&gt;硬盘：8TB硬盘两块，用于存放资料、文件。16TB硬盘一块，用于存放电影。&lt;/li&gt;&#xA;&lt;li&gt;主板：选择了大厂微星的Z370M Mortar。&lt;/li&gt;&#xA;&lt;li&gt;机箱：Treasure宝藏盒，快700多的一个机箱了，已经算比较贵了，但是买回来看了一下外观，真香。&lt;/li&gt;&#xA;&lt;li&gt;风扇：利民AXP90&lt;/li&gt;&#xA;&lt;li&gt;电源：Flex台达250W电源&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这里需要说一个事情，我没有配备缓存，群晖的系统可以配备2块M2 Nvme硬盘作为缓存组，可以用于读写缓存，单盘只能作为读缓存。我研究了一番后，决定还是不用缓存，第一个对于我这样的家用环境上缓存提升不大，也有很多家用小伙伴测试后发了相关的结论。第二个就是缓存可能导致故障，第三个性价比不高。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2024/03/DraggedImage-16.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;系统&#34;&gt;系统&lt;/h2&gt;&#xA;&lt;p&gt;系统采用的是群晖，既然是自己搭建的，所以也就是所谓的黑群晖了，采用的引导是最简单的引导arpl-i18n，该引导是基于巴西大佬arpl的版本上改进的，对于两者我还真不知道差距在哪里，但只要好用，然后用的人多就行了。&lt;/p&gt;&#xA;&lt;p&gt;然后黑群晖的引导是需要一个U盘的，正常情况下U盘可以插在机箱前面或者后面，但是对于花了700多买了这么漂亮的机箱，U盘插在前后，犹如”一坨牛屎抹在鲜花上“。&lt;/p&gt;&#xA;&lt;p&gt;所以我就购买了一个主板的usb插座，然后将引导U盘插在上面，这样就可以把usb隐藏在机箱内了。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2024/03/DraggedImage-1-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;备份&#34;&gt;备份&lt;/h2&gt;&#xA;&lt;p&gt;我的备份组合主要集中为四种，分别RAID1+Cloud Sync+Hyper Backup网盘+Hyper Backup硬盘，其中RAID1虽然说起来不算是”备份“方案，但本质提供冗余还是一种数据的保障，所以也就算了进来。&lt;/p&gt;&#xA;&lt;p&gt;Hyper Backup则是提供了一个完整的套件、文件增量备份，每天执行一次。&lt;/p&gt;&#xA;&lt;p&gt;Cloud Sync则是作为一个补充，提供一个实时的文件同步，将文件同步到我的Onedrive，至于为什么是Onedrive，第一个原因是支持，第二个原因是因为我每年要买Office365，所以有1TB的免费网盘容量。&lt;/p&gt;&#xA;&lt;p&gt;Hyper Backup是目前我觉得最好的备份方案，Hyper Backup支持备份到云服务商、本地USB储存设备等方式。Hyper Backup我采用了两种方式，分别为阿里云盘通过Alist以WebDAV的方式挂载到本地，然后Hyper Backup选择WebDAV方式进行备份，好处在于阿里云盘服务器在国内比较稳定，关于如何通过查看Alist关于阿里云盘的文档。&lt;/p&gt;&#xA;&lt;p&gt;第二种方式，我采用的是本地USB插入硬盘的方式，这个方式有个好处在于能无限扩大备份目的地的容量，比如你可以通过一个硬盘盒做多个盘用USB接入，同时配置好了也比较省电省电。&lt;/p&gt;&#xA;&lt;p&gt;为什么说省电呢？在设置为USB为备份目的地的时候，配置可以选择，当备份完成后自动断开卸载USB，然后再加上硬盘盒的自动休眠，就可以在备份完成后的耗电降到最低，比如下图（因为我目前已经设置完成，所以找不到这个选项了，就借用了一张图片）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2024/03/DraggedImage-2-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;但这种方式有一个问题，就是你在下次备份的时候没有办法自动挂载，你需要通过定时任务，将在定时的自动备份任务开始之前将USB重新挂载好。&lt;/p&gt;&#xA;&lt;p&gt;重新挂载USB需要两个步骤，第一个步骤确定USB编号，需要打开群晖的SSH，然后进入到终端后使用lsusb命令，我找到我备份目的地的硬盘为2-3：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2024/03/DraggedImage-3-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;第二个步骤是将如下代码放入群晖的任务计划，选择运行的用户为root（一定注意，卸载挂载外置设备需要root权限）：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2024/03/DraggedImage-4-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;然后将如下代码放入脚本中，其中的2-3需要替换为备份的外置目的地设备编号。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;echo 0 &amp;amp;gt; /sys/bus/usb/devices/2-3/authorized&#xA;echo 1 &amp;amp;gt; /sys/bus/usb/devices/2-3/authorized&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2024/03/DraggedImage-5-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;最后，设定好计划时间，我目前是在Hyper Backup之前的5分钟挂载。&lt;/p&gt;&#xA;&lt;h2 id=&#34;结尾&#34;&gt;结尾&lt;/h2&gt;&#xA;&lt;p&gt;说完了后，说说成品Nas和自己搭建Nas推荐哪个，整体就是完全不建议没有技术或者不想折腾的人来自己搭建Nas，更建议直接买群晖或者其他厂商的成品Nas，对于有技术的用户，这种方式就挺推荐的。&lt;/p&gt;&#xA;&lt;p&gt;搭建到如今，也算是对稳定性比较信任了，将自己照片、文件都转移到了群晖，同时也说服了自己的爱人将手机照片转到了群晖，不得不说群晖的配套软件是真的好用，买软件送硬件也不是无道理，看来以后买一个白裙也不是不可以。&lt;/p&gt;</description>
    </item>
    <item>
      <title>GPU服务器的多人环境搭建</title>
      <link>https://vec6.com/blog/gpu-server/</link>
      <pubDate>Thu, 20 Oct 2022 20:52:00 +0000</pubDate>
      <guid>https://vec6.com/blog/gpu-server/</guid>
      <description>&lt;h2 id=&#34;环境&#34;&gt;环境&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;CPU: Intel(R) Xeon(R) Gold 6154 &lt;em&gt;2&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;Momery: 128G GPU: 3080TI &lt;em&gt;2&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;Disk: 16T HD &amp;amp; 512 SSD&lt;/li&gt;&#xA;&lt;li&gt;System: Ubuntu 22.04 Server&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。&lt;/p&gt;&#xA;&lt;p&gt;在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于LXC容器，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;16T的机械盘，分为两个分区（分区可以使用fdisk），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的/data目录，后期映射到每个容器的/data目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置/data，即使容器出现了问题，也不会影响到数据的丢失问题。&lt;/li&gt;&#xA;&lt;li&gt;显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入nvidia-smi，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。&lt;/li&gt;&#xA;&lt;li&gt;使用apt安装zfsutils-linux，前者用于安装LXD的储存池驱动，LXD支持多种储存池，这用于储存LXD、LXC相关的数据。&lt;/li&gt;&#xA;&lt;li&gt;使用apt安装bridge-utils，该工具是用于管理和创建网桥设备所需要的工具和程序。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;初始化lxd&#34;&gt;初始化LXD&lt;/h2&gt;&#xA;&lt;p&gt;通过命令执行sudo lxd init，就会得到如下的问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可&lt;/li&gt;&#xA;&lt;li&gt;new storage pool：需要创建一个存储池，输入yes&lt;/li&gt;&#xA;&lt;li&gt;Name of storage pool：给存储池命名，默认为default，回车即可&lt;/li&gt;&#xA;&lt;li&gt;storage backend：存储后端，默认使用zfs，回车即可&lt;/li&gt;&#xA;&lt;li&gt;Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes&lt;/li&gt;&#xA;&lt;li&gt;use an existing block device：使用现有的块设备（硬盘），输入yes&lt;/li&gt;&#xA;&lt;li&gt;Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1&lt;/li&gt;&#xA;&lt;li&gt;MAAS server：MAAS是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可&lt;/li&gt;&#xA;&lt;li&gt;new local network bridge：是否创建一个新的桥接网络，输入yes&lt;/li&gt;&#xA;&lt;li&gt;new bridge be called：命名新的网桥名称，默认即可&lt;/li&gt;&#xA;&lt;li&gt;IPv4：IPv4相关配置，默认为auto，回车即可&lt;/li&gt;&#xA;&lt;li&gt;IPv6：IPv6相关配置，默认为auto，回车即可&lt;/li&gt;&#xA;&lt;li&gt;would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可&lt;/li&gt;&#xA;&lt;li&gt;would you like stale cached images to be updated automatically：默认yes，回车即可&lt;/li&gt;&#xA;&lt;li&gt;YAML printed：是否打印出lxd init的配置信息，默认为no，回车即可&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;创建容器模板&#34;&gt;创建容器模板&lt;/h2&gt;&#xA;&lt;p&gt;创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的国内镜像用于提升下载镜像的速度。 添加清华大学镜像源：&lt;/p&gt;</description>
    </item>
    <item>
      <title>基于LXC容器的Openwrt搭建</title>
      <link>https://vec6.com/blog/lxcopenwrt/</link>
      <pubDate>Mon, 05 Sep 2022 21:02:00 +0000</pubDate>
      <guid>https://vec6.com/blog/lxcopenwrt/</guid>
      <description>&lt;h2 id=&#34;前期工作&#34;&gt;前期工作&lt;/h2&gt;&#xA;&lt;p&gt;环境和机器配置：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;机器：5105v4 i226-v版本&lt;/li&gt;&#xA;&lt;li&gt;pve： 7.1.2，内核Linux 5.13.19-2-pve&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;准备工作：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将网线连接到pve管理口，如果已安装openwrt，然后关闭原openwrt虚拟机，删除直通的网卡。&lt;/li&gt;&#xA;&lt;li&gt;准备一份没有引导的openwrt固件包，可以是img也可以是tar.gz，但一定是没有引导的包，可以看文件名中包含rootfs字符，比如openwrt-x86-64-generic-ext4-rootfs.img或openwrt-21.02.0-x86-64-rootfs.tar.gz（前者是我自己编译的，重点在于rootfs）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;pve直通配置&#34;&gt;PVE直通配置&lt;/h2&gt;&#xA;&lt;p&gt;连接到PVE，输入命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;nano /etc/default/grub &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;找到下面这一行：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后添加&lt;code&gt;intel_iommu=on&lt;/code&gt;，这是英特尔的直通配置，AMD需要自行查找配置命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet intel_iommu=on&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后更新引导：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;update-grub &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;修改nano /etc/modules内核模块文件，添加直通的驱动，让系统启动的时候载入这些驱动：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;vfio&#xA;vfio_iommu_type1&#xA;vfio_pci&#xA;vfio_virqfd &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;执行命令来更新内核：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;update-initramfs -u -k all. &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;创建基础环境文件包&#34;&gt;创建基础环境文件包&lt;/h2&gt;&#xA;&lt;h3 id=&#34;targz格式&#34;&gt;tar.gz格式&lt;/h3&gt;&#xA;&lt;p&gt;如果包后缀为tar.gz，则通过scp直接上传至pve，以下&lt;code&gt;[]&lt;/code&gt;内的字符根据自己情况进行替换（包括&lt;code&gt;[和]&lt;/code&gt;符号），然后跳至下一章节：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;scp [固件路径.tar.gz] root@[pveIP地址]:/var/lib/vz/template/cache &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;img格式&#34;&gt;img格式&lt;/h3&gt;&#xA;&lt;p&gt;上传固件：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;scp [固件路径.img] root@[pveIP地址]:/root &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这里需要注意，如果你的固件包是带squashfs字符，比如openwrt-x86-64-generic-squashfs-rootfs.img，你需要按照下面的方式进行解压。 安装解压包：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;apt install squashfs-tools &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;解压镜像文件：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;unsquashfs [固件路径.img] &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;解压完成后你在同级目录下会得到squashfs-root文件夹，然后进入该文件夹，跳至3步骤。 如果你是不带squashfs字符，比如openwrt-x86-64-generic-ext4-rootfs.img，则需要通过挂载镜像，得到内部文件，首先创建一个挂载点（下面操作在root目录中进行）：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;mkdir op &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后挂载镜像：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;mount -t ext4 -o loop [固件路径.img] /root/op &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后进入/root/op，跳至3步骤（完成后，通过使用umount /root/op进行卸载镜像）。 打包为pve的CT模板包： 进入上述2步骤中得到的文件夹中，然后使用下列命令进行打包，得到的文件下文称为op-ct模版：&lt;/p&gt;</description>
    </item>
    <item>
      <title>前端的技术栈理解</title>
      <link>https://vec6.com/blog/frontend-terms/</link>
      <pubDate>Fri, 22 Apr 2022 01:52:54 +0000</pubDate>
      <guid>https://vec6.com/blog/frontend-terms/</guid>
      <description>&lt;p&gt;最近几年单页应用程序发展非常迅速，从早期通过Javascript写入大量&lt;code&gt;html模版&lt;/code&gt;去做单页程序（SPA），到现在的React、Vue（最为流行），但不得不说，前端的技术进步太快了，稍不关注技术，就会出来很多的新的技术。&lt;/p&gt;&#xA;&lt;p&gt;但归根结底，每次新的技术出来，埋头深入发现远比想象的复杂，而到了一定的时间后则能够想明白一些事情，这也就是&amp;quot;深入浅出&amp;quot;的道理。 单页应用是一个复杂的技术，要解决这些问题，出现了很多&amp;quot;框架&amp;quot;、工具，比如React、Vue、React-router、Redux等。对于新手来说更是学了一圈后出来也是懵的。但总体来说，React和Vue这类库本质都没有什么区别，都是为了解决SPA提出的方案。这类库大部分主要的理念是将Web应用划分为一个一个的组件为单元，这些组件可以包含另一个组件，以此来达到复用性。&lt;/p&gt;&#xA;&lt;p&gt;而每个组件不可能都显示一样，那这样复用性是没有意义的。 那这个时候提出了“状态”的概念，来让每个复用的组件显示不同的内容，状态分为了&lt;code&gt;props&lt;/code&gt;和&lt;code&gt;state&lt;/code&gt;，&lt;code&gt;props&lt;/code&gt;是由外部传入进来的状态，&lt;code&gt;state&lt;/code&gt;则是组件内部自己的状态。而这类UI库对于状态的变化，都会根据一些优秀的算法去重新渲染组件，并且渲染的时候仅仅涉及到改变的那一部分内容。&lt;/p&gt;&#xA;&lt;p&gt;之所以需要状态，其实告诉React这类库需要监听哪些值，方便在改变这些值的时候，React可以及时的进行计算和重新渲染组件。 比如下面的代码就可以通过传递&lt;code&gt;name&lt;/code&gt;值进行重复使用包含&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;标签的组件，这种方式传递的状态在内部就是使用&lt;code&gt;props&lt;/code&gt;获取。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Header&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&amp;gt; // 输出：&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt;Hello&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;Header&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&amp;gt; // 输出：&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt;world&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h2&lt;/span&gt;&amp;gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而&lt;code&gt;state&lt;/code&gt;则更多用于组件内部，比如当你鼠标点击需要获取一个报价，这个时候组件内部会发起一个请求，从服务器获取到报价后返回，改变状态，UI库进行重新渲染，这个时候就能获取到报价。 虽然说React提供了这些方便的功能，也提倡组件化和重复使用，但很多的组件是需要自己去一个一个写的。那这个时候，就有很多个人、组织开发出了&amp;quot;组件库&amp;quot;，&amp;ldquo;组件库&amp;quot;中包含了很多已经开发好可复用的组件，可以直接通过调用直接使用，这就是我们为什么看见除了React还有Ant Design、MaterialUI库。&lt;/p&gt;&#xA;&lt;p&gt;介绍完UI库和组件库后，单页应用还差一个东西，就是路由功能，路由也可以通过简单的Javascript来判断，比如当点击了一个链接后，Javascript将当前页面内容清除（隐藏），然后再渲染点击的目标内容。但是这个时候有一些问题，比如需要编写大量的代码、丢失浏览器的前进后退、没有办法收藏等问题（后面两个问题可以再通过增加代码去解决）。所以React-router-dom`这类的库就出现了，把所有的底层的逻辑和代码都进行封装提供一些接口，即大部分的人不需要再编写、理解这类的代码直接可以开箱即用，这也就是这类路由库出现的原因。 我们从前面了解到了状态分别为&lt;code&gt;props&lt;/code&gt;和&lt;code&gt;state&lt;/code&gt;，一个是外部，一个是内部的。&lt;/p&gt;&#xA;&lt;p&gt;那这个时候如果组件的嵌套过于&amp;quot;多层次&amp;quot;了后，比如从顶层的组件需要传递一个状态到第N层的组件中，那么每一层即使不需要不处理也要将状态进行传递，那这个时候涉及到的组件其中会包含非常多的和组件无关的代码。 所以这个时候需要一个通用的状态管理的解决方案（如Redux），让整个Web应用都共享一个大的状态，需要多层传递的状态则可以放在这个大状态内部，让不关心有些状态的组件不用去关心无关状态，而有些状态的组件去关心自己关心的状态。&lt;/p&gt;&#xA;&lt;p&gt;Redux本身设计是非常有趣的，整个应用的状态不能直接修改，这是因为如果大家都直接修改很有可能会造成状态的管理的混乱，所以Redux的修改状态流程是组件发起动作-&amp;gt;Dispatch函数接收动作-&amp;gt;reducer处理动作-&amp;gt;影响状态-&amp;gt;重新渲染组件。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(二)漫话中文分词：Trie、KMP、AC自动机</title>
      <link>https://vec6.com/blog/chinesecutwords-2/</link>
      <pubDate>Wed, 18 Nov 2020 08:51:13 +0000</pubDate>
      <guid>https://vec6.com/blog/chinesecutwords-2/</guid>
      <description>&lt;h2 id=&#34;trie树&#34;&gt;Trie树&lt;/h2&gt;&#xA;&lt;p&gt;在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[&amp;lsquo;中国人&amp;rsquo;, &amp;lsquo;中东人&amp;rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词&lt;code&gt;retrieval&lt;/code&gt;，发音和&lt;code&gt;try&lt;/code&gt;相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如&amp;quot;中国人&amp;quot;、&amp;ldquo;中东人&amp;quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以&amp;quot;中&amp;quot;开头，所以可以使用同一个父辈节点。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1605767937-1-0012449.jpg&#34; alt=&#34;1605767937-1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如&lt;code&gt;中国人&lt;/code&gt;，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://vec6.com/post/images/2020/11/1605767940-2-0012449.jpg&#34; alt=&#34;1605767940-2&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Trie树的查找方式则是通过层层查询，而不是直接遍历词典，比如&amp;quot;中国人&amp;rdquo;，首先会查找第一层中是否有&amp;quot;中&amp;quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找&amp;quot;中&amp;quot;字符对应的下一层是否有&amp;quot;国&amp;quot;，如果没有则返回查询识别，如果有则继续查找&amp;quot;国&amp;quot;下一层是否有&amp;quot;人&amp;quot;，此时找到存在&amp;quot;人&amp;quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查询词&lt;/li&gt;&#xA;&lt;li&gt;添加词&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回&amp;quot;False&amp;quot;表示为未查询到或设置失败，而返回&amp;quot;True&amp;quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的&lt;code&gt;__value&lt;/code&gt;表示是否为结束节点（即一个词的尾字符），如果是则为&lt;code&gt;True&lt;/code&gt;，不是则为&lt;code&gt;False&lt;/code&gt;，整体可以采用函数或者类来定义。 实现代码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Trie&lt;/span&gt;():  &lt;span style=&#34;color:#75715e&#34;&gt;#定义一个Trie类型&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self):  &lt;span style=&#34;color:#75715e&#34;&gt;#为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_children &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_add_word&lt;/span&gt;(self, word):  &lt;span style=&#34;color:#75715e&#34;&gt;# 定义一个添加词的实例方法&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_children  &lt;span style=&#34;color:#75715e&#34;&gt;# 首先会将_children的对象赋值给child&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i,char &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(word):  &lt;span style=&#34;color:#75715e&#34;&gt;# 然后从头遍历添加词的每一个字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; char &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; child:  &lt;span style=&#34;color:#75715e&#34;&gt;# 查看当前字符是否存在Trie树上&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                child[char] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__value&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;} &lt;span style=&#34;color:#75715e&#34;&gt;# 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; (len(word) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):  &lt;span style=&#34;color:#75715e&#34;&gt;# 判断是否为结尾字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                child[char][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__value&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 如果是则将特殊key：__value设为True，表明为结尾字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; child[char]  &lt;span style=&#34;color:#75715e&#34;&gt;# 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 添加完成返回True&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_get_word&lt;/span&gt;(self, word):  &lt;span style=&#34;color:#75715e&#34;&gt;# 查找词&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_children  &lt;span style=&#34;color:#75715e&#34;&gt;# 同样设置一个child变量，用于控制当前的字符对象 &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; char &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; word:  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; child&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(char)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; child &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt; :  &lt;span style=&#34;color:#75715e&#34;&gt;# 只要其中一个没有查找到，那么说明匹配识别，则返回False&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; child[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__value&amp;#39;&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;# 如果没有匹配失败则返回特殊__value的值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#回True表示词典中存在该词，返回False表示不存在或者传递进来的词不成词 &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将Trie实现后，就可以在正向或者反向等算法中来进行使用，从而提高运算的效率，但是使用Trie树的时候，可能无法动态的计算其词的长度，所以根据上一篇文章当中修改的最大正向匹配算法的长度计算我手动计算填写。 下面的代码是基于&lt;a href=&#34;https://vec6.com/posts/2022-04-15-1-chinese-words-cut/&#34;&gt;《[一]漫话中文分词：最大匹配,双向最大,最小词数》&lt;/a&gt;文章中的最大正向匹配算法，但其中的词典则是使用Trie结构，改动了两处：&lt;/p&gt;</description>
    </item>
    <item>
      <title>(一)漫话中文分词：最大匹配,双向最大,最小词数</title>
      <link>https://vec6.com/blog/chinesecutwords-1/</link>
      <pubDate>Sun, 08 Nov 2020 10:36:34 +0000</pubDate>
      <guid>https://vec6.com/blog/chinesecutwords-1/</guid>
      <description>&lt;p&gt;中文分词是指将文本拆分为单词的过程，而结果集合连接起来是等于原始的文本，而中文分词一直作为NLP领域的比较重要的领域，而大多数的文本挖掘都是以分词为基础，但中文不同于英文，英文每个单词是用空格分隔，整体语义上相对于中文难度低很多。 而业务上一直有中文分词的需求，但是之前因为在忙于另外一个项目，所以一直没有研究。 近期稍空闲开始研究了相关的中文分词算法，发现中文分词总体算比较成熟，但是其中对于未登录词或者某个特定专业领域文本大部分算法分词的结果不尽人意，需要结合多种算法或者人工词典才能达到稍微好一点的效果。 中文分词的方式一共有两种，分别为：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;词典分词：如正向最大匹配算法、反向最大匹配算法、双向最大匹配算法、最少词数法等&lt;/li&gt;&#xA;&lt;li&gt;字标注分词：如HMM（隐马尔可夫）模型等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;而这几种方式很难说出谁好谁坏，比如词典分词的方式速度非常快，但对于未登录词的识别又不太好，而HMM和Pkuseg都能识别部分未登录词，但是运行速度又降下来了，这对于在实际应用场景当中是非常致命的问题，所以最大的优解就是集各家所长，比如结巴分词就使用了词典分词算法识别能识别的词，而不能识别的则继续使用了HMM模型来处理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;词典分词&#34;&gt;词典分词&lt;/h2&gt;&#xA;&lt;p&gt;基于词典的分词算法实际上就是对于类似字典的数据结构进行查询，对于未在词典内的词识别较弱和交集型歧义理解能力也较弱，比如“结婚的和尚未结婚的”，理想的情况是&amp;quot;结婚/的/和/尚未/结婚/的&amp;quot;，而实际中则会被分词为&amp;quot;结婚/的/和尚/未/结婚/的&amp;quot;。 但好在词典分词的速度则非常快，词典分词目前已有非常成熟高效的解决方案，并且有非常多的工具来帮你实现相关的高效数据结构和查询方式，比如&lt;a href=&#34;https://zh.wikipedia.org/wiki/Trie&#34;&gt;Trie树&lt;/a&gt;和&lt;a href=&#34;https://zh.wikipedia.org/wiki/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%97%E6%B3%95&#34;&gt;AC自动机&lt;/a&gt;，但在这里为了方便理解和记录，只采用了尽可能简单的方式来记录其几种算法的实现和原理。&lt;/p&gt;&#xA;&lt;h3 id=&#34;正向最大匹配算法forward-maximum-matching&#34;&gt;正向最大匹配算法（Forward Maximum Matching）&lt;/h3&gt;&#xA;&lt;p&gt;正向最大匹配算法类似于人的阅读习惯，即从左到右进行识别，而其中的&amp;quot;最大&amp;quot;是基于词典中最长字符的长度作为最大的匹配宽度，然后每次根据这个宽度对文本进行切分并取出来查询词典。如果当前取出来的词能在词典当中查询当则返回，并下一次切分的开始位置为该词的位置+1。而如果当前取出的部分没有在词典中查找到，则将该部分去掉最后一个字符后再进行查找，一直重复直到匹配到了词典中的词。如果整个部分只剩余一个字符，并没有匹配到词典中的词，则将最后剩余的这个字符输出，然后根据这个字符的位置+1开始再次进行切分和查询。 比如，有一段文本&amp;quot;中文分词算法&amp;quot;，字典中只包含了一个词&amp;quot;分词&amp;quot;，这个时候最大的匹配宽度也为2，所以整段文本按照2个字符进行切分。第一次得到&amp;quot;中文&amp;quot;文本，查找词典并无该词，则在该部分上去掉最后的字符，得到&amp;quot;中&amp;quot;，再次查询词典并无该词，此时查找结束，所以不需要再进行匹配，则这个切分记为[&amp;ldquo;中&amp;rdquo;]。 继续进行第二次切分，得到的文本为&amp;quot;文分&amp;quot;，进行查询词典，第一次查询&amp;quot;文分&amp;quot;在字典中不存在，去掉最后一个字符，继续以剩余部分&amp;rsquo;文&amp;rsquo;查询第二次，未查询到，那么返回最后这个字符&amp;quot;文&amp;quot;，加上次的结果记作[&amp;ldquo;中&amp;rdquo;,&amp;ldquo;文&amp;rdquo;] 继续第三次切分，得到文本&amp;quot;分词&amp;quot;，进行查询词典，查询到该词在字典当中，所以直接记录在之前的结果当中，记作[&amp;ldquo;中&amp;rdquo;, &amp;ldquo;文&amp;rdquo;, &amp;ldquo;分词&amp;rdquo;]。 继续第四次切分，得到文本&amp;quot;算法&amp;quot;，进行查询字典，第一次查询&amp;quot;算法&amp;quot;在字典中不存在，去掉最后一个字符，继续以剩余部分&amp;rsquo;算&amp;rsquo;查询第二次，未查询到，那么返回最后这个字符&amp;quot;算&amp;quot;，加上次的结果记作[&amp;ldquo;中&amp;rdquo;, &amp;ldquo;文&amp;rdquo;, &amp;ldquo;分词&amp;rdquo;, &amp;ldquo;算&amp;rdquo;] 继续第五次切分，因为最后只剩余一个字符，所以这个时候可以不进行匹配即返回，所以最终的结果为[&amp;ldquo;中&amp;rdquo;, &amp;ldquo;文&amp;rdquo;, &amp;ldquo;分词&amp;rdquo;, &amp;ldquo;算&amp;rdquo;, &amp;ldquo;法&amp;rdquo;] 整体分词的过程本质对每个分块进行查找，并依次去掉最后字符查询，而网上还有一部分是没有使用最大宽度切分，即会对每个字符到文本结束的位置都会依次遍历，这样的方式实际上会浪费较多的资源，因为即使从头到尾依次遍历匹配，但最长词的长度是固定的，所以真正开始匹配还是从最长词的长度开始，而其余的遍历都是浪费了资源。 正向最大匹配算法具体的实现代码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sentence &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;中文分词算法&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 输入的句子&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cutList &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;分词&amp;#39;&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;# 分词词典&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;#设置切分起始位置&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;maxWidth &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(max(cutList, key&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;len)) &lt;span style=&#34;color:#75715e&#34;&gt;# 得到字典当中最大的切分宽度&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cut_result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [] &lt;span style=&#34;color:#75715e&#34;&gt;# 设置一个空的分词结果&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; len(sentence)):  &lt;span style=&#34;color:#75715e&#34;&gt;#开始循环，如果start大于等于句子长度则停止分词&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    end &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; maxWidth     &lt;span style=&#34;color:#75715e&#34;&gt;# 计算每次切分的停止位置&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    word &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sentence[start: end] &lt;span style=&#34;color:#75715e&#34;&gt;# 开始切分，文本为变量start和end的区间内字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ( word ) :  &lt;span style=&#34;color:#75715e&#34;&gt;# python对于空字符串会转换为False&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( word &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; cutList ) :  &lt;span style=&#34;color:#75715e&#34;&gt;# 查看第一次切分后是否能在词典中匹配，如果匹配则放入最终的分词结果列表cut_result,并跳出循环&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cut_result&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(word)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; len(word) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 然后将开始位置设置为当前开始位置加上被匹配词的长度&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (len(word[:&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cut_result&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(word) &lt;span style=&#34;color:#75715e&#34;&gt;# 如果最后一个字符也没有被匹配到，那么返回最后一个字符&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        word &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; word[:&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;# 将word去掉最后一个字符串并重新计算&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 将位置加1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(cut_result)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[&amp;#39;中&amp;#39;, &amp;#39;文&amp;#39;, &amp;#39;分词&amp;#39;, &amp;#39;算&amp;#39;, &amp;#39;法&amp;#39;] &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;反向最大匹配算法backward-maximum-matching&#34;&gt;反向最大匹配算法（Backward Maximum Matching）&lt;/h3&gt;&#xA;&lt;p&gt;反向最大匹配算法与正向最大匹配算法是相反的，比如&amp;quot;中文分词算法&amp;quot;文本的正向最大匹配算法在切分宽度为2的时候，是从&amp;quot;中文&amp;quot;开始切分的，而反向则是从&amp;quot;算法&amp;quot;开始切分的。 除了反向的切分，其中对于切分块内的文本依次去掉最后一个字符也变为了依次去掉第一个字符，比如正向第一个切分块&amp;quot;中文&amp;quot;后，如果没有匹配到，则去掉&amp;quot;文&amp;quot;，再对&amp;quot;中&amp;quot;字符进行匹配，而反向则是拿到&amp;quot;算法&amp;quot;后，如果没有匹配到，则是去掉&amp;quot;算&amp;quot;，再对&amp;quot;法&amp;quot;进行匹配。 反向最大匹配算法对比于正向最大匹配算法来说，可以解决一定的交集型歧义，比如本文&amp;quot;他说的确实在理&amp;quot;，理想情况下希望的分词结果中包含&amp;quot;确实&amp;quot;这一词，而正向最大匹配算法结果为&amp;quot;他/说/的确/实/在理&amp;quot;，而反向最大匹配算法的结果为&amp;quot;他/说/的/确实/在理&amp;quot;。 这两种方式很难区分到底谁好谁坏，比如上面的问题中，如果你希望的分词为&amp;quot;的确&amp;quot;，但是如果使用反向的话就很难被分出来。 反向最大匹配算法具体的实现代码：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
