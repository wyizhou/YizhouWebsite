<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发者手册 on Yizhou</title>
    <link>https://wuyizhou.com/tags/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/</link>
    <description>Recent content in 开发者手册 on Yizhou</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Apr 2022 01:52:54 +0000</lastBuildDate>
    <atom:link href="https://wuyizhou.com/tags/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>前端的技术栈理解</title>
      <link>https://wuyizhou.com/posts/frontend-terms/</link>
      <pubDate>Fri, 22 Apr 2022 01:52:54 +0000</pubDate>
      <guid>https://wuyizhou.com/posts/frontend-terms/</guid>
      <description>最近几年单页应用程序发展非常迅速，从早期通过Javascript写入大量html模版去做单页程序（SPA），到现在的React、Vue（最为流行），但不得不说，前端的技术进步太快了，稍不关注技术，就会出来很多的新的技术。
但归根结底，每次新的技术出来，埋头深入发现远比想象的复杂，而到了一定的时间后则能够想明白一些事情，这也就是&amp;quot;深入浅出&amp;quot;的道理。 单页应用是一个复杂的技术，要解决这些问题，出现了很多&amp;quot;框架&amp;quot;、工具，比如React、Vue、React-router、Redux等。对于新手来说更是学了一圈后出来也是懵的。但总体来说，React和Vue这类库本质都没有什么区别，都是为了解决SPA提出的方案。这类库大部分主要的理念是将Web应用划分为一个一个的组件为单元，这些组件可以包含另一个组件，以此来达到复用性。
而每个组件不可能都显示一样，那这样复用性是没有意义的。 那这个时候提出了“状态”的概念，来让每个复用的组件显示不同的内容，状态分为了props和state，props是由外部传入进来的状态，state则是组件内部自己的状态。而这类UI库对于状态的变化，都会根据一些优秀的算法去重新渲染组件，并且渲染的时候仅仅涉及到改变的那一部分内容。
之所以需要状态，其实告诉React这类库需要监听哪些值，方便在改变这些值的时候，React可以及时的进行计算和重新渲染组件。 比如下面的代码就可以通过传递name值进行重复使用包含&amp;lt;h2&amp;gt;标签的组件，这种方式传递的状态在内部就是使用props获取。
&amp;lt;Header name=&amp;#39;hello&amp;#39;&amp;gt; // 输出：&amp;lt;h2&amp;gt;Hello&amp;lt;/h2&amp;gt; &amp;lt;Header name=&amp;#39;world&amp;#39;&amp;gt; // 输出：&amp;lt;h2&amp;gt;world&amp;lt;/h2&amp;gt; 而state则更多用于组件内部，比如当你鼠标点击需要获取一个报价，这个时候组件内部会发起一个请求，从服务器获取到报价后返回，改变状态，UI库进行重新渲染，这个时候就能获取到报价。 虽然说React提供了这些方便的功能，也提倡组件化和重复使用，但很多的组件是需要自己去一个一个写的。那这个时候，就有很多个人、组织开发出了&amp;quot;组件库&amp;quot;，&amp;ldquo;组件库&amp;quot;中包含了很多已经开发好可复用的组件，可以直接通过调用直接使用，这就是我们为什么看见除了React还有Ant Design、MaterialUI库。
介绍完UI库和组件库后，单页应用还差一个东西，就是路由功能，路由也可以通过简单的Javascript来判断，比如当点击了一个链接后，Javascript将当前页面内容清除（隐藏），然后再渲染点击的目标内容。但是这个时候有一些问题，比如需要编写大量的代码、丢失浏览器的前进后退、没有办法收藏等问题（后面两个问题可以再通过增加代码去解决）。所以React-router-dom`这类的库就出现了，把所有的底层的逻辑和代码都进行封装提供一些接口，即大部分的人不需要再编写、理解这类的代码直接可以开箱即用，这也就是这类路由库出现的原因。 我们从前面了解到了状态分别为props和state，一个是外部，一个是内部的。
那这个时候如果组件的嵌套过于&amp;quot;多层次&amp;quot;了后，比如从顶层的组件需要传递一个状态到第N层的组件中，那么每一层即使不需要不处理也要将状态进行传递，那这个时候涉及到的组件其中会包含非常多的和组件无关的代码。 所以这个时候需要一个通用的状态管理的解决方案（如Redux），让整个Web应用都共享一个大的状态，需要多层传递的状态则可以放在这个大状态内部，让不关心有些状态的组件不用去关心无关状态，而有些状态的组件去关心自己关心的状态。
Redux本身设计是非常有趣的，整个应用的状态不能直接修改，这是因为如果大家都直接修改很有可能会造成状态的管理的混乱，所以Redux的修改状态流程是组件发起动作-&amp;gt;Dispatch函数接收动作-&amp;gt;reducer处理动作-&amp;gt;影响状态-&amp;gt;重新渲染组件。</description>
    </item>
    <item>
      <title>汇编语言学习笔记（四）：寄存器[内存访问]</title>
      <link>https://wuyizhou.com/posts/learning-assembly-4/</link>
      <pubDate>Fri, 23 Feb 2018 16:45:57 +0000</pubDate>
      <guid>https://wuyizhou.com/posts/learning-assembly-4/</guid>
      <description>内存中字的储存 在8086CPU中，寄存器为16位，可以储存一个字(1Word=2Byte)，拿ax来说，低8位放在al中，高8位放在ah中。
在内存单元一个内存单元只能存储一个字节，那么如果存储一个字型数据就会用到两个内存单元，低8位放在低地址当中，高8位放在高地址当中，比如下图中，储存了两个字型数据，一个是4E20H，一个是0012H，它们的存放数据大概如下：
而当连续两个内存单元储存的是一个字型数据的时候，可以将这字型数据的起始地址称为N地址字单元，比如00001内存单元和00002内存单元，可以直接称为00001地址字单元。
数据的读写 在第二章中写到如何操作CPU的执行指令，让内存中的数据当作指令还是数据都取决于程序员，当CS和IP指向的地址则当作指令执行，那读取数据也需要由段地址和偏移地址组成。
8086CPU中，数据地址的段地址由段寄存器DS来指定，并且不能直接将数据送入DS段寄存器，只能通过其他寄存器来传送给段寄存器DS（这是8086CPU的硬件设计，只需要知道就可以了），那偏移地址呢？
先来看看下面的代码，下面的代码是通过ax寄存器把内存单元2000H段地址传送给DS，然后读取内存单元2000段中的0001单元：
mov bx,2000H mov ds,bx mov al,[0001H] 偏移地址是由程序员手动输入的，当编译器看见[]的时候，会自动把段寄存器DS中的值与[]号中数据进行合成为一个20位的物理地址，然后读取这个物理地址中的数据。
那么如何把寄存器中的数据写入内存中呢？只需要将两个位置相关换一下，就可以了，比如下面代码，把ax的低位寄存器al中的12H数据写入内存2000段中的0001单元。
mov bx,2000H mov ds,bx mov al,12H mov [0001H],al 字型数据传送 8086CPU是16位架构，那么意味着一次性可以传输16位数据，上面操作的都是8位数据，也可以传输16位数据，只需要给出16位寄存器的名字就可以传送了，但是16位寄存器分两个内存单元储存，一个内存单元只能储存8位数据，比如储存一个8E20H数据到2000:0000内存单元中，那么20H储存在2000:0000中，而8E储存在2000:0001中。
CPU提供的栈以及机制 栈是一种特殊方式访问的内存单元，那么它有什么用呢？以后会慢慢来说到，在这里只是先对栈空间有一个大概的认识，栈的特殊性在于后进先出，英文缩写为LIFO(Last in First Out)。
这个是什么意思呢？可以把栈看作一个放书的盒子，依次放3本书进去的时候，需要取出放进去的第一本书的时候，就会先把上面的两本书依次拿出来，才能取到放进去的第一本书。
当需要取出哪一本书的时候，我们总会先拿出最上面的那一本书，不然无法拿到需要的书，而每取出一本书，下一本总是在最上面。
在程序化的角度上来说是应该有一个标记，这个标记中指向最上面的书，也就是栈顶，如下图所示：
现今的CPU中都有栈的设计，包含8086，既然有栈的设计，肯定也有对栈访问的指令，其中最基本的就是PUSH（入栈）和POP（出栈），比如push ax代表将ax寄存器的数据送入栈中，入栈和出栈都是字型数据操作，比如下图是一个操作栈的例子：
虽然说现在可以操作栈了，但是有两个疑问：
栈中的数据存储在哪里？ 上面说到，有一个标记，总是指向栈顶，那这个栈顶在哪里？ 上面两个问题可以归于一个，其实栈也是在内存单元中，只是它是一段特殊访问方式的空间，那既然是内存单元，那可能也有类似与段寄存器和偏移寄存器这样的寄存器来指向栈，它们就是SS:SP。
SS存放栈的段地址，而SP存放栈的偏移地址，SS:SP在任意时刻指向的是栈顶，我们可以通过修改SS和SP来指定哪一段内存单元为栈，那么现在就可以很好的解释push和pop指令的工作方式，比如push ax的执行，由以下两部分完成：
SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶起前面的单元为新栈顶。 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。 上面的步骤可以用下图来表示：
从图中可以看出，8086CPU中，入栈时，由栈顶高地址向低地址增长，而出栈就是由低地址到高地址增长。
栈顶超界 可以想象一下，当栈空间为2000H:0000H-2000H:000FH的16个内存单元时，那么当栈为空，栈顶在0010H位置，如果这时我们操作出栈，那么SP应该+2，即为0012H，那如果入栈低于了20000H这个内存空间的时候呢？这两种情况都超出了栈的范围，就会覆盖相应的内存单元的数据，比如在下面两个图中，分别对出栈和入栈都演示了一个超界的情况：
在内存单元中，可能存放数据，代码，也有可能存放其他应用的数据代码等，如果超出了就会出现其他未知的问题，在8086CPU中，并没有什么机制来预防这样的问题，应为8086CPU只需要关注栈顶在哪里，并不会关注栈的空间有多大，所以我们需要特别注意，这是非常危险的一个操作。</description>
    </item>
    <item>
      <title>汇编语言学习笔记（三）：初识Debug</title>
      <link>https://wuyizhou.com/posts/learning-assembly-3/</link>
      <pubDate>Fri, 09 Feb 2018 09:06:14 +0000</pubDate>
      <guid>https://wuyizhou.com/posts/learning-assembly-3/</guid>
      <description>什么是Debug？Debug是DOS、Windows提供的8086程序调试工具，可以查看CPU各种寄存器的内容，内存情况和机器码级跟踪程序的运行。
Debug一共有20多个命令，但我们在目前为止会使用到Debug的6个命令：
R命令：查看、改变寄存器的内容 D命令：查看内存中的内容 E命令：改写内存中的内容 U命令：将内存中的机器指令翻译成汇编指令 T命令：执行一条机器指令 A命令：以汇编指令的格式向内存中写入一条机器指令 Windows下的Debug 在Windows下自带提供了Debug，可以直接通过Window提供的DOS进入到Debug，可以通过开始命令，输入cmd然后进入到DOS界面后直接输入Debug后就进行Debug程序了。
Mac下的Debug 在Mac下，你需要通过Boxer这个程序来模拟DOS环境，打开后类似于这样的界面：
点击Open a DOS prompt后就会弹出如下的界面，可以在这个环境下使用任何的DOS界面：
但是这个DOS环境只包含了最基础的DOS环境，所以这个DOS环境是不带Debug程序的，你需要下载一个Debug程序或者下载由我提供的一个学习汇编需要的程序包，然后解压后把这个文件夹拖放进DOS窗口后，你就会看见Boxer提供的DOS环境会自动把这个目录加载成C盘，这样就可以正常使用Debug程序了，类似于下图这样：
进入界面后，你会看见一个&amp;quot;-&amp;ldquo;后面跟着闪烁的下划线，说明已经进入Debug。
R命令 R命令有两个作用：
查看当前CPU的各个寄存器状态、以及当前CS、IP指向的代码以及机器指令翻译后的汇编指令。 修改各个寄存器的内容 输入r后，会返回当前CPU的各个寄存器状态，就如下图这样：
如果需要修改某个寄存器的内容，可以通过r命令后跟一个寄存器的命令，比如r ax，输入后会返回一个ax当前寄存器的内容，然后会有一个提示符:等待输入，比如下图中，通过r ax命令设置ax的内容为1000H：
D命令 通过下面的格式可以查看需要的内容中的内容：
d 段地址:偏移地址 比如下图用d命令查看内容20000H处的内容：
返回的内容中包含了三个显示部分：
第一部分位于最左边类似于2000:0000，是每行开始的第一个内存单元的段地址和偏移地址。 第二部分位于中间的十六进制编码，是开始部分的内存单元一直显示128个内存单元的内容，而每行等于16个字节，注意在每行在第八个内存单元的后面会有一个-来分割，有利于我们辨识。 第三部分位于最右边，是每个内存单元中的数据可以对应显示的ASCII，如果没有对应的ASCII码，就会用.代替。 还有一种限制D命令输出的方式，可以通过使用结束偏移地址来限制D命令的返回结果，它的格式为：
d 段地址:偏移地址 结束偏移地址 比如下图中只需要返回内存地址为2000:0000到2000:0009的十个内存单元的内容：
E命令 e 段地址:偏移地址 可以通过E命令来改写内存中的内容，不管是汇编指令还是数据。
通过E命令可以连续更改也可以更改一个内存单元，当修改指定内存单元的内容时，会把当前内存单元的内容显示出来，然后用一个.号连接需要写入的数据，比如需要修改内存单元20000H的内容为10，然后再用d命令查看修改后的内容：
当然也可以连续修改指定内存单元后的连续内存单元中的内容，只需要在输入需要写入的内存单元后按空格间，会自动跳到下一个内存单元进行修改，直到按回车键，就会写入内存：
U命令 u命令会将某一段内存单元中的内容翻译成汇编指令，并返回16个内存单元的内容，返回的内容中包含三部分：
每一条机器指令的地址 对应的机器指令 对应的汇编指令 比如查看内存单元2000:0000的数据，并翻译成汇编指令：
当然也可以限制返回的内容，比如下面返回内存单元2000:0000到内存单元2000:0009的汇编指令：
这里需要注意的是在计算机中储存在内存单元中的不管是数据还是代码，都是以二进制形式储存的，所以是代码还是数据，得看程序员怎么去控制。
T命令 T命令是执行当前CS和IP指向的内存单元中的汇编指令，执行后IP自动增加代码长度并正确的指向到下一个代码的内存单元：
A命令 以汇编指令的方式写入到内存单元，格式为：
a 段地址:偏移地址 当指定修改某一个内存单元的内容时，会显示出当前修改的内存单元地址，并等待输入汇编指令，当输入完成后会自动跳到上一条代码长度后的内存单元继续等待输入，如果不想继续写入汇编指令，按回车键就结束写入。
比如下图中，通过在内存单元20000H处以汇编指令形式写入：
mov ax,20 并通过u命令查看内存单元20000H处是否写入成功：
并且再通过r命令查看当前AX寄存器的内容，然后修改CS和IP寄存器，让CPU代码指针指向20000H处
然后用t命令执行，再次查看AX寄存器的结果：</description>
    </item>
  </channel>
</rss>
